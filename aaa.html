<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Brutalist Bot Towers</title>
    <style>
        body {
            background-color: #222;
            color: #eee;
            font-family: 'Courier New', Courier, monospace;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            margin: 0;
            padding: 20px;
        }
        #container {
            text-align: center;
        }
        h1 {
            font-weight: normal;
            letter-spacing: 2px;
            border-bottom: 2px solid #555;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        canvas {
            background-color: #333;
            border: 2px solid #555;
            margin-bottom: 20px;
            /* This ensures a crisp, pixelated look */
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }
        button {
            background-color: #444;
            color: #eee;
            border: 2px solid #666;
            padding: 10px 20px;
            font-family: inherit;
            font-size: 1em;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        button:hover {
            background-color: #555;
        }
        #legend {
            margin-top: 20px;
            display: flex;
            justify-content: center;
            gap: 20px;
            color: #aaa;
        }
        #legend div {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .swatch {
            width: 15px;
            height: 15px;
            display: inline-block;
            border: 1px solid #777;
        }
    </style>
</head>
<body>
    <div id="container">
        <h1>Brutalist Bot Towers</h1>
        <canvas id="worldCanvas"></canvas>
        <button id="regenButton">Regenerate World</button>
        <div id="legend">
            <div><span class="swatch" style="background-color: #ffde03;"></span> Goal</div>
            <div><span class="swatch" style="background-color: #ff4757;"></span> FlexiBot (Stairs & Lifts)</div>
            <div><span class="swatch" style="background-color: #1e90ff;"></span> LiftBot (Lifts Only)</div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('worldCanvas');
            const ctx = canvas.getContext('2d');
            const regenButton = document.getElementById('regenButton');

            // --- Configuration ---
            const TILE_SIZE = 10;
            const WORLD_WIDTH_TILES = 160; // Increased width for more towers
            const WORLD_HEIGHT_TILES = 90;
            const BOT_SPEED = 0.25;

            canvas.width = WORLD_WIDTH_TILES * TILE_SIZE;
            canvas.height = WORLD_HEIGHT_TILES * TILE_SIZE;

            const Tile = {
                EMPTY: 0, CONCRETE: 1, FLOOR: 2, STAIRS: 3, LIFT_SHAFT: 4, LIFT_DOOR: 5, BRIDGE: 6,
            };

            const COLORS = {
                [Tile.EMPTY]: '#3a3a3a', [Tile.CONCRETE]: '#8d8d8d', [Tile.FLOOR]: '#b0b0b0',
                [Tile.STAIRS]: '#d9a400', [Tile.LIFT_SHAFT]: '#5a5a5a', [Tile.LIFT_DOOR]: '#00b894',
                [Tile.BRIDGE]: '#a37c58', GOAL: '#ffde03', FLEXI_BOT: '#ff4757', LIFT_BOT: '#1e90ff',
                PATH: 'rgba(255, 255, 255, 0.3)',
            };

            let worldGrid = [], walkableTiles = [], bots = [], goal = null;
            let animationFrameId, sourceCodeLines = [], codeScrollOffset = 0;

            // --- World Generation ---

            function generateWorld() {
                worldGrid = Array(WORLD_HEIGHT_TILES).fill(0).map(() => Array(WORLD_WIDTH_TILES).fill(Tile.EMPTY));
                
                // More towers in a wider world
                const numTowers = Math.floor(Math.random() * 4) + 5; // 5 to 8 towers
                let currentX = 4;

                for (let i = 0; i < numTowers; i++) {
                    if (currentX >= WORLD_WIDTH_TILES - 15) break;
                    // Slightly narrower towers to fit more
                    const towerWidth = Math.floor(Math.random() * 9) + 7; // 7 to 15 tiles
                    generateTower(currentX, towerWidth);
                    // Smaller gaps between towers
                    currentX += towerWidth + Math.floor(Math.random() * 7) + 4; // 4 to 10 tile gap
                }

                addBridges();
                findWalkableTiles();
            }

            function generateTower(startX, width) {
                const maxHeight = WORLD_HEIGHT_TILES - 10;
                const towerHeight = Math.floor(Math.random() * (maxHeight / 2)) + Math.floor(maxHeight / 2.5);
                let currentY = WORLD_HEIGHT_TILES - 1;
                const moduleTypes = ['solid', 'stairs', 'lift'];
                const numModules = Math.floor(Math.random() * 5) + 4;
                
                let hasTransport = { stairs: false, lift: false };
                let modules = [];

                for (let i=0; i < numModules; i++) {
                    let type = moduleTypes[Math.floor(Math.random() * moduleTypes.length)];
                    modules.push(type);
                    if (type === 'stairs') hasTransport.stairs = true;
                    if (type === 'lift') hasTransport.lift = true;
                }
                
                // **Crucial modification**: Ensure tall towers have lifts for LiftBot accessibility
                if (towerHeight > 40 && !hasTransport.lift) {
                    modules[Math.floor(Math.random() * modules.length)] = 'lift';
                }

                modules.forEach(type => {
                    if (currentY <= 15) return;
                    const moduleHeight = Math.floor(Math.random() * 8) + 6;
                    switch(type) {
                        case 'solid': currentY = createSolidModule(startX, currentY, width, moduleHeight); break;
                        case 'stairs': currentY = createStairsModule(startX, currentY, width, moduleHeight); break;
                        case 'lift': currentY = createLiftModule(startX, currentY, width, moduleHeight); break;
                    }
                    currentY--;
                });
            }

            function createSolidModule(x, y, w, h) {
                for (let j = 0; j < h; j++) {
                    const ry = y - j; if (ry < 0) continue;
                    for (let i = 0; i < w; i++) {
                        const rx = x + i; if (rx >= WORLD_WIDTH_TILES) continue;
                        worldGrid[ry][rx] = (j === 0) ? Tile.FLOOR : Tile.CONCRETE;
                    }
                }
                return y - h;
            }
            
            function createStairsModule(x, y, w, h) {
                const stairX = Math.random() > 0.5 ? x + 1 : x + w - 4;
                let stairDirection = Math.random() > 0.5 ? 1 : -1;
                let currentStairX = stairDirection === 1 ? stairX : stairX + 2;
                for (let j = 0; j < h; j++) {
                    const ry = y - j; if (ry < 0) continue;
                    for (let i = 0; i < w; i++) if(worldGrid[ry][x+i] === Tile.EMPTY) worldGrid[ry][x+i] = Tile.FLOOR;
                    worldGrid[ry][currentStairX] = Tile.STAIRS;
                    if (j > 0 && j % 2 === 1) {
                         currentStairX += stairDirection;
                         if (currentStairX >= stairX + 3 || currentStairX < stairX) {
                            stairDirection *= -1;
                            currentStairX += stairDirection * 2;
                        }
                    }
                }
                for (let j = 1; j < h; j++) {
                    const ry = y - j; if (ry < 0) continue;
                    for (let i = 0; i < w; i++) {
                        if (worldGrid[ry+1][x+i] === Tile.FLOOR && worldGrid[ry][x+i] === Tile.EMPTY) {
                             worldGrid[ry][x+i] = Tile.CONCRETE;
                        }
                    }
                }
                return y - h;
            }

            function createLiftModule(x, y, w, h) {
                const liftX = x + Math.floor(w / 2);
                for(let j = 0; j < h; j++) {
                    let ry = y - j; if (ry < 0) continue;
                    for(let i = 0; i < w; i++) {
                        const rx = x + i;
                        if (rx === liftX) worldGrid[ry][rx] = Tile.LIFT_SHAFT;
                        else if (j === 0) worldGrid[ry][rx] = Tile.FLOOR;
                        else worldGrid[ry][rx] = Tile.CONCRETE;
                    }
                    if (j === 0) worldGrid[ry][liftX] = Tile.LIFT_DOOR;
                }
                if (y - h + 1 > 0) worldGrid[y-h+1][liftX] = Tile.LIFT_DOOR;
                return y - h;
            }
            
            function addBridges() {
                for (let y = WORLD_HEIGHT_TILES - 2; y > 0; y--) {
                    let lastConcreteX = -1;
                    for (let x = 0; x < WORLD_WIDTH_TILES; x++) {
                        const tile = worldGrid[y][x];
                        if (tile === Tile.CONCRETE || tile === Tile.FLOOR) {
                            if (lastConcreteX !== -1 && x - lastConcreteX > 1 && x - lastConcreteX < 15) {
                                if ((worldGrid[y][lastConcreteX] === Tile.FLOOR) && (tile === Tile.FLOOR)) {
                                     for (let i = lastConcreteX + 1; i < x; i++) worldGrid[y][i] = Tile.BRIDGE;
                                }
                            }
                            lastConcreteX = x;
                        }
                    }
                }
            }
            
            function findWalkableTiles() {
                walkableTiles = [];
                for (let y = 0; y < WORLD_HEIGHT_TILES; y++) {
                    for (let x = 0; x < WORLD_WIDTH_TILES; x++) {
                        const tile = worldGrid[y][x];
                        if (tile === Tile.FLOOR || tile === Tile.STAIRS || tile === Tile.LIFT_DOOR || tile === Tile.BRIDGE) {
                            walkableTiles.push({ x, y });
                        }
                    }
                }
            }

            // --- Pathfinding & Accessibility ---

            function findPath(start, end, rules) {
                const queue = [{ ...start, path: [start] }];
                const visited = new Set([`${start.x},${start.y}`]);
                while (queue.length > 0) {
                    const current = queue.shift();
                    if (current.x === end.x && current.y === end.y) return current.path;
                    const neighbors = getNeighbors(current.x, current.y, rules);
                    for (const neighbor of neighbors) {
                        const key = `${neighbor.x},${neighbor.y}`;
                        if (!visited.has(key)) {
                            visited.add(key);
                            queue.push({ ...neighbor, path: [...current.path, neighbor] });
                        }
                    }
                }
                return null;
            }

            function findAllReachable(start, rules) {
                const queue = [start];
                const reachable = new Set([`${start.x},${start.y}`]);
                while(queue.length > 0) {
                    const current = queue.shift();
                    const neighbors = getNeighbors(current.x, current.y, rules);
                    for(const neighbor of neighbors) {
                        const key = `${neighbor.x},${neighbor.y}`;
                        if(!reachable.has(key)) {
                            reachable.add(key);
                            queue.push(neighbor);
                        }
                    }
                }
                return reachable;
            }

            function getNeighbors(x, y, rules) {
                const neighbors = [];
                const currentTile = worldGrid[y][x];
                for (const dx of [-1, 1]) {
                    if (isValid(x + dx, y, rules)) neighbors.push({ x: x + dx, y: y });
                }
                if (rules.canUseStairs) {
                    for (const dy of [-1, 1]) {
                        const ny = y + dy; if (ny < 0 || ny >= WORLD_HEIGHT_TILES) continue;
                        const destTile = worldGrid[ny]?.[x];
                        if ((currentTile === Tile.STAIRS || destTile === Tile.STAIRS) && isValid(x, ny, rules)) {
                            neighbors.push({ x: x, y: ny });
                        }
                    }
                }
                if (rules.canUseLifts && currentTile === Tile.LIFT_DOOR) {
                    for (let ny = 0; ny < WORLD_HEIGHT_TILES; ny++) {
                        if (ny !== y && worldGrid[ny][x] === Tile.LIFT_DOOR) {
                            neighbors.push({ x: x, y: ny });
                        }
                    }
                }
                return neighbors;
            }
            
            function isValid(x, y, rules) {
                if (x < 0 || x >= WORLD_WIDTH_TILES || y < 0 || y >= WORLD_HEIGHT_TILES) return false;
                const tile = worldGrid[y][x];
                if (tile === Tile.STAIRS) return rules.canUseStairs;
                return tile !== Tile.EMPTY && tile !== Tile.CONCRETE && tile !== Tile.LIFT_SHAFT;
            }

            // --- Bot Class ---
            class Bot {
                constructor(x, y, color, rules) {
                    this.x = x; this.y = y; this.pixelX = x * TILE_SIZE; this.pixelY = y * TILE_SIZE;
                    this.color = color; this.rules = rules; this.path = null; this.pathIndex = 0;
                }
                findNewPath() {
                    if (!goal) return;
                    const path = findPath({ x: this.x, y: this.y }, goal, this.rules);
                    this.path = (path && path.length > 1) ? path : null;
                    this.pathIndex = this.path ? 1 : 0;
                }
                update() {
                    if (!this.path || this.pathIndex >= this.path.length) { this.findNewPath(); return; }
                    const targetNode = this.path[this.pathIndex];
                    const targetX = targetNode.x * TILE_SIZE; const targetY = targetNode.y * TILE_SIZE;
                    const dx = targetX - this.pixelX; const dy = targetY - this.pixelY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < 1.5) {
                        this.x = targetNode.x; this.y = targetNode.y;
                        this.pixelX = targetX; this.pixelY = targetY;
                        this.pathIndex++;
                        if (this.x === goal.x && this.y === goal.y) { spawnNewGoal(); bots.forEach(b => b.findNewPath()); }
                    } else {
                        const moveSpeed = TILE_SIZE * BOT_SPEED;
                        this.pixelX += (dx / dist) * moveSpeed; this.pixelY += (dy / dist) * moveSpeed;
                    }
                }
                draw() {
                    if (this.path) {
                        ctx.beginPath(); ctx.strokeStyle = COLORS.PATH; ctx.lineWidth = 2;
                        ctx.moveTo(this.pixelX + TILE_SIZE / 2, this.pixelY + TILE_SIZE / 2);
                        for (let i = this.pathIndex; i < this.path.length; i++) {
                            ctx.lineTo(this.path[i].x * TILE_SIZE + TILE_SIZE / 2, this.path[i].y * TILE_SIZE + TILE_SIZE / 2);
                        }
                        ctx.stroke();
                    }
                    ctx.fillStyle = this.color; ctx.fillRect(this.pixelX, this.pixelY, TILE_SIZE, TILE_SIZE);
                    ctx.strokeStyle = '#222'; ctx.strokeRect(this.pixelX, this.pixelY, TILE_SIZE, TILE_SIZE);
                }
            }

            // --- Drawing & Game Loop ---

            function draw() {
                ctx.fillStyle = COLORS[Tile.EMPTY]; ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#2c2c2c'; ctx.font = '9px "Courier New", Courier, monospace';
                const lineHeight = 10;
                codeScrollOffset = (codeScrollOffset + 0.2) % lineHeight;
                if (sourceCodeLines.length > 0) {
                    let lineIndex = 0;
                    for (let y = -codeScrollOffset; y < canvas.height; y += lineHeight) {
                        const line = sourceCodeLines[lineIndex % sourceCodeLines.length];
                        ctx.fillText(line.substring(0, 250), 5, y);
                        lineIndex++;
                    }
                }
                for (let y = 0; y < WORLD_HEIGHT_TILES; y++) {
                    for (let x = 0; x < WORLD_WIDTH_TILES; x++) {
                        const tile = worldGrid[y][x];
                        if (tile !== Tile.EMPTY) {
                            ctx.fillStyle = COLORS[tile];
                            ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                        }
                    }
                }
                if (goal) {
                    ctx.fillStyle = COLORS.GOAL; ctx.fillRect(goal.x * TILE_SIZE, goal.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    ctx.strokeStyle = 'white'; ctx.lineWidth = 1;
                    ctx.strokeRect(goal.x * TILE_SIZE, goal.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                }
                bots.forEach(bot => bot.draw());
            }

            function gameLoop() {
                bots.forEach(bot => bot.update());
                draw();
                animationFrameId = requestAnimationFrame(gameLoop);
            }
            
            function spawnNewGoal() {
                const flexiBot = bots[0]; const liftBot = bots[1];
                if (!flexiBot || !liftBot) { goal = null; return; }

                // Find all tiles reachable by each bot
                const flexiReachable = findAllReachable(flexiBot, flexiBot.rules);
                const liftReachable = findAllReachable(liftBot, liftBot.rules);
                
                // Find the intersection of the two sets
                const commonReachable = [...flexiReachable].filter(tile => liftReachable.has(tile));

                if (commonReachable.length > 0) {
                    const goalString = commonReachable[Math.floor(Math.random() * commonReachable.length)];
                    const [x, y] = goalString.split(',').map(Number);
                    goal = {x, y};
                } else {
                    console.error("No common reachable tiles found for a new goal!");
                    // Fallback: spawn a goal that at least one bot can reach so the game doesn't stall
                    const fallbackTiles = [...liftReachable];
                    if (fallbackTiles.length > 0) {
                        const goalString = fallbackTiles[Math.floor(Math.random() * fallbackTiles.length)];
                         const [x, y] = goalString.split(',').map(Number);
                        goal = {x, y};
                    } else {
                        goal = null; // No possible goal
                    }
                }
            }

            function init() {
                if (animationFrameId) cancelAnimationFrame(animationFrameId);
                if (sourceCodeLines.length === 0) {
                     sourceCodeLines = document.documentElement.outerHTML.split('\n');
                }
                generateWorld();
                if (walkableTiles.length < 50) {
                     console.log("Regenerating world: insufficient walkable tiles.");
                     init(); return;
                }
                bots = [];
                const startPos1 = walkableTiles[Math.floor(Math.random() * walkableTiles.length)];
                let startPos2 = walkableTiles[Math.floor(Math.random() * walkableTiles.length)];
                // Ensure bots don't start at the same spot
                while(startPos1.x === startPos2.x && startPos1.y === startPos2.y) {
                    startPos2 = walkableTiles[Math.floor(Math.random() * walkableTiles.length)];
                }
                
                bots.push(new Bot(startPos1.x, startPos1.y, COLORS.FLEXI_BOT, { canUseStairs: true, canUseLifts: true }));
                bots.push(new Bot(startPos2.x, startPos2.y, COLORS.LIFT_BOT, { canUseStairs: false, canUseLifts: true }));
                
                spawnNewGoal();
                bots.forEach(b => b.findNewPath());
                gameLoop();
            }

            regenButton.addEventListener('click', init);
            init();
        });
    </script>
</body>
</html>
