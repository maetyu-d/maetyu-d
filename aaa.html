<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Brutalist Bot Towers</title>
    <style>
        body {
            background-color: #222;
            color: #eee;
            font-family: 'Courier New', Courier, monospace;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            margin: 0;
            padding: 20px;
        }
        #container {
            text-align: center;
        }
        h1 {
            font-weight: normal;
            letter-spacing: 2px;
            border-bottom: 2px solid #555;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        canvas {
            background-color: #333;
            border: 2px solid #555;
            margin-bottom: 20px;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }
        button {
            background-color: #444;
            color: #eee;
            border: 2px solid #666;
            padding: 10px 20px;
            font-family: inherit;
            font-size: 1em;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        button:hover {
            background-color: #555;
        }
        #legend {
            margin-top: 20px;
            display: flex;
            justify-content: center;
            gap: 20px;
            color: #aaa;
        }
        #legend div {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .swatch {
            width: 15px;
            height: 15px;
            display: inline-block;
            border: 1px solid #777;
        }
    </style>
</head>
<body>
    <div id="container">
        <h1>Brutalist Bot Towers</h1>
        <canvas id="worldCanvas"></canvas>
        <button id="regenButton">Regenerate World</button>
        <div id="legend">
            <div><span class="swatch" style="background-color: #ffde03;"></span> Goal</div>
            <div><span class="swatch" style="background-color: #ff4757;"></span> FlexiBot (Stairs & Lifts)</div>
            <div><span class="swatch" style="background-color: #1e90ff;"></span> LiftBot (Lifts Only)</div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('worldCanvas');
            const ctx = canvas.getContext('2d');
            const regenButton = document.getElementById('regenButton');

            // --- Configuration ---
            const TILE_SIZE = 9;
            const WORLD_WIDTH_TILES = 180;
            const WORLD_HEIGHT_TILES = 100;
            const BOT_SPEED = 0.2;

            canvas.width = WORLD_WIDTH_TILES * TILE_SIZE;
            canvas.height = WORLD_HEIGHT_TILES * TILE_SIZE;

            const Tile = {
                EMPTY: 0, CONCRETE: 1, FLOOR: 2, STAIRS: 3, LIFT_SHAFT: 4, LIFT_DOOR: 5, BRIDGE: 6,
            };

            const COLORS = {
                [Tile.EMPTY]: '#3a3a3a', [Tile.CONCRETE]: '#8d8d8d', [Tile.FLOOR]: '#b0b0b0',
                [Tile.STAIRS]: '#d9a400', [Tile.LIFT_SHAFT]: '#5a5a5a', [Tile.LIFT_DOOR]: '#00b894',
                [Tile.BRIDGE]: '#a37c58', GOAL: '#ffde03', FLEXI_BOT: '#ff4757', LIFT_BOT: '#1e90ff',
                PATH: 'rgba(255, 255, 255, 0.3)',
            };

            let worldGrid = [], walkableTiles = [], bots = [], goal = null;
            let animationFrameId, sourceCodeLines = [], codeScrollOffset = 0;

            // --- World Generation ---

            function generateWorld() {
                worldGrid = Array(WORLD_HEIGHT_TILES).fill(0).map(() => Array(WORLD_WIDTH_TILES).fill(Tile.EMPTY));
                
                const numTowers = Math.floor(Math.random() * 4) + 6; // 6 to 9 towers
                let currentX = 4;
                let previousTower = null;

                for (let i = 0; i < numTowers; i++) {
                    if (currentX >= WORLD_WIDTH_TILES - 15) break;
                    const towerWidth = Math.floor(Math.random() * 9) + 8; // 8 to 16 tiles wide
                    const towerHeight = Math.floor(Math.random() * (WORLD_HEIGHT_TILES * 0.4)) + Math.floor(WORLD_HEIGHT_TILES * 0.5);
                    
                    previousTower = generateTower(currentX, towerWidth, towerHeight, previousTower);
                    
                    const gap = Math.floor(Math.random() * 7) + 5; // 5 to 11 tile gap
                    currentX = previousTower.endX + gap + 1;
                }

                addExtraBridges();
                findWalkableTiles();
            }

            function generateTower(startX, width, height, previousTower) {
                const liftX = startX + 1;
                const stairAreaWidth = 3;
                const stairStartX = startX + width - 1 - stairAreaWidth;
                let stairCurrentX = stairStartX;
                let stairDirection = 1;

                // Build tower floor by floor from the bottom up
                for (let y = WORLD_HEIGHT_TILES - 1; y > WORLD_HEIGHT_TILES - 1 - height; y--) {
                    if (y <= 0) continue;
                    
                    for(let i=0; i<width; i++) {
                        const currentX = startX + i;
                        // **THE FIX IS HERE**: Only place concrete if the space below is empty.
                        // This prevents overwriting the floor of the level below.
                        if (worldGrid[y][currentX] === Tile.EMPTY) {
                            worldGrid[y][currentX] = Tile.CONCRETE;
                        }
                        // Always place the floor surface on the level above the foundation.
                        worldGrid[y-1][currentX] = Tile.FLOOR;
                    }
                    
                    worldGrid[y-1][liftX] = Tile.LIFT_DOOR;
                    worldGrid[y][liftX] = Tile.LIFT_SHAFT; 

                    worldGrid[y-1][stairCurrentX] = Tile.STAIRS;

                    if (y % 2 === 0) {
                        stairCurrentX += stairDirection;
                        if (stairCurrentX >= stairStartX + stairAreaWidth || stairCurrentX < stairStartX) {
                            stairDirection *= -1;
                            stairCurrentX += stairDirection;
                        }
                    }
                }

                if (previousTower) {
                    const minHeight = Math.min(height, previousTower.height);
                    const validBridgeYs = [];
                    for(let y = WORLD_HEIGHT_TILES - 2; y > WORLD_HEIGHT_TILES - minHeight; y--) {
                        if(worldGrid[y][startX-1] === Tile.EMPTY && worldGrid[y][previousTower.endX+1] === Tile.EMPTY) {
                             if(worldGrid[y][startX] === Tile.FLOOR && worldGrid[y][previousTower.endX] === Tile.FLOOR) {
                                validBridgeYs.push(y);
                            }
                        }
                    }
                    if (validBridgeYs.length > 0) {
                        const bridgeY = validBridgeYs[Math.floor(Math.random() * validBridgeYs.length)];
                        for(let x = previousTower.endX + 1; x < startX; x++) {
                            worldGrid[bridgeY][x] = Tile.BRIDGE;
                        }
                    }
                }
                
                return { startX: startX, endX: startX + width - 1, height: height };
            }

            function addExtraBridges() {
                for (let y = WORLD_HEIGHT_TILES - 2; y > 0; y--) {
                    let lastFloorX = -1;
                    for (let x = 0; x < WORLD_WIDTH_TILES; x++) {
                        const tile = worldGrid[y][x];
                        if (tile === Tile.FLOOR) {
                            if (lastFloorX !== -1 && x - lastFloorX > 1 && x - lastFloorX < 15) {
                                if (Math.random() < 0.1) {
                                     for (let i = lastFloorX + 1; i < x; i++) worldGrid[y][i] = Tile.BRIDGE;
                                }
                            }
                            lastFloorX = x;
                        }
                    }
                }
            }
            
            function findWalkableTiles() {
                walkableTiles = [];
                for (let y = 0; y < WORLD_HEIGHT_TILES; y++) {
                    for (let x = 0; x < WORLD_WIDTH_TILES; x++) {
                        const tile = worldGrid[y][x];
                        if (tile === Tile.FLOOR || tile === Tile.STAIRS || tile === Tile.LIFT_DOOR || tile === Tile.BRIDGE) {
                            walkableTiles.push({ x, y });
                        }
                    }
                }
            }

            // --- Pathfinding & Accessibility ---

            function findPath(start, end, rules) {
                const queue = [{ ...start, path: [start] }];
                const visited = new Set([`${start.x},${start.y}`]);
                while (queue.length > 0) {
                    const current = queue.shift();
                    if (current.x === end.x && current.y === end.y) return current.path;
                    const neighbors = getNeighbors(current.x, current.y, rules);
                    for (const neighbor of neighbors) {
                        const key = `${neighbor.x},${neighbor.y}`;
                        if (!visited.has(key)) {
                            visited.add(key);
                            queue.push({ ...neighbor, path: [...current.path, neighbor] });
                        }
                    }
                }
                return null;
            }

            function findAllReachable(start, rules) {
                const queue = [start];
                const reachable = new Set([`${start.x},${start.y}`]);
                while(queue.length > 0) {
                    const current = queue.shift();
                    const neighbors = getNeighbors(current.x, current.y, rules);
                    for(const neighbor of neighbors) {
                        const key = `${neighbor.x},${neighbor.y}`;
                        if(!reachable.has(key)) {
                            reachable.add(key);
                            queue.push(neighbor);
                        }
                    }
                }
                return reachable;
            }

            function getNeighbors(x, y, rules) {
                const neighbors = [];
                if (y < 0 || y >= WORLD_HEIGHT_TILES) return [];
                const currentTile = worldGrid[y][x];

                for (const dx of [-1, 1]) {
                    if (isValid(x + dx, y, rules)) neighbors.push({ x: x + dx, y: y });
                }
                if (rules.canUseStairs) {
                    for (const dy of [-1, 1]) {
                        const ny = y + dy; if (ny < 0 || ny >= WORLD_HEIGHT_TILES) continue;
                        const destTile = worldGrid[ny]?.[x];
                        if ((currentTile === Tile.STAIRS || destTile === Tile.STAIRS) && isValid(x, ny, rules)) {
                            neighbors.push({ x: x, y: ny });
                        }
                    }
                }
                if (rules.canUseLifts && currentTile === Tile.LIFT_DOOR) {
                    for (let ny = 0; ny < WORLD_HEIGHT_TILES; ny++) {
                        if (ny !== y && worldGrid[ny][x] === Tile.LIFT_DOOR) {
                            neighbors.push({ x: x, y: ny });
                        }
                    }
                }
                return neighbors;
            }
            
            function isValid(x, y, rules) {
                if (x < 0 || x >= WORLD_WIDTH_TILES || y < 0 || y >= WORLD_HEIGHT_TILES) return false;
                const tile = worldGrid[y][x];
                if (tile === Tile.STAIRS) return rules.canUseStairs;
                return tile !== Tile.EMPTY && tile !== Tile.CONCRETE && tile !== Tile.LIFT_SHAFT;
            }

            // --- Bot Class ---
            class Bot {
                constructor(x, y, color, rules) {
                    this.x = x; this.y = y; this.pixelX = x * TILE_SIZE; this.pixelY = y * TILE_SIZE;
                    this.color = color; this.rules = rules; this.path = null; this.pathIndex = 0;
                }
                findNewPath() {
                    if (!goal) return;
                    const path = findPath({ x: this.x, y: this.y }, goal, this.rules);
                    this.path = (path && path.length > 1) ? path : null;
                    this.pathIndex = this.path ? 1 : 0;
                }
                update() {
                    if (!this.path || this.pathIndex >= this.path.length) { this.findNewPath(); return; }
                    const targetNode = this.path[this.pathIndex];
                    const targetX = targetNode.x * TILE_SIZE; const targetY = targetNode.y * TILE_SIZE;
                    const dx = targetX - this.pixelX; const dy = targetY - this.pixelY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < 1.5) {
                        this.x = targetNode.x; this.y = targetNode.y;
                        this.pixelX = targetX; this.pixelY = targetY;
                        this.pathIndex++;
                        if (this.x === goal.x && this.y === goal.y) { spawnNewGoal(); bots.forEach(b => b.findNewPath()); }
                    } else {
                        const moveSpeed = TILE_SIZE * BOT_SPEED;
                        this.pixelX += (dx / dist) * moveSpeed; this.pixelY += (dy / dist) * moveSpeed;
                    }
                }
                draw() {
                    if (this.path) {
                        ctx.beginPath(); ctx.strokeStyle = COLORS.PATH; ctx.lineWidth = 2;
                        ctx.moveTo(this.pixelX + TILE_SIZE / 2, this.pixelY + TILE_SIZE / 2);
                        for (let i = this.pathIndex; i < this.path.length; i++) {
                            ctx.lineTo(this.path[i].x * TILE_SIZE + TILE_SIZE / 2, this.path[i].y * TILE_SIZE + TILE_SIZE / 2);
                        }
                        ctx.stroke();
                    }
                    ctx.fillStyle = this.color; ctx.fillRect(this.pixelX, this.pixelY, TILE_SIZE, TILE_SIZE);
                    ctx.strokeStyle = '#222'; ctx.strokeRect(this.pixelX, this.pixelY, TILE_SIZE, TILE_SIZE);
                }
            }

            // --- Drawing & Game Loop ---

            function draw() {
                ctx.fillStyle = COLORS[Tile.EMPTY]; ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#2c2c2c'; ctx.font = '9px "Courier New", Courier, monospace';
                const lineHeight = 10;
                codeScrollOffset = (codeScrollOffset + 0.2) % lineHeight;
                if (sourceCodeLines.length > 0) {
                    let lineIndex = 0;
                    for (let y = -codeScrollOffset; y < canvas.height; y += lineHeight) {
                        const line = sourceCodeLines[lineIndex % sourceCodeLines.length];
                        ctx.fillText(line.substring(0, 250), 5, y);
                        lineIndex++;
                    }
                }
                for (let y = 0; y < WORLD_HEIGHT_TILES; y++) {
                    for (let x = 0; x < WORLD_WIDTH_TILES; x++) {
                        const tile = worldGrid[y][x];
                        if (tile !== Tile.EMPTY) {
                            ctx.fillStyle = COLORS[tile];
                            ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                        }
                    }
                }
                if (goal) {
                    ctx.fillStyle = COLORS.GOAL; ctx.fillRect(goal.x * TILE_SIZE, goal.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    ctx.strokeStyle = 'white'; ctx.lineWidth = 1;
                    ctx.strokeRect(goal.x * TILE_SIZE, goal.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                }
                bots.forEach(bot => bot.draw());
            }

            function gameLoop() {
                bots.forEach(bot => bot.update());
                draw();
                animationFrameId = requestAnimationFrame(gameLoop);
            }
            
            function spawnNewGoal() {
                const flexiBot = bots.find(b => b.rules.canUseStairs);
                const liftBot = bots.find(b => !b.rules.canUseStairs);
                if (!flexiBot || !liftBot) { goal = null; return; }

                const flexiReachable = findAllReachable({x: flexiBot.x, y: flexiBot.y}, flexiBot.rules);
                const liftReachable = findAllReachable({x: liftBot.x, y: liftBot.y}, liftBot.rules);
                const commonReachable = [...flexiReachable].filter(tile => liftReachable.has(tile));

                if (commonReachable.length > 1) {
                    const validGoals = commonReachable.filter(g => g !== `${flexiBot.x},${flexiBot.y}` && g !== `${liftBot.x},${liftBot.y}`);
                    if (validGoals.length > 0) {
                        const goalString = validGoals[Math.floor(Math.random() * validGoals.length)];
                        const [x, y] = goalString.split(',').map(Number);
                        goal = {x, y};
                    } else {
                        goal = null; // No other place to go
                    }
                } else {
                    console.error("No common reachable tiles found for a new goal!");
                    goal = null;
                }
            }

            function init() {
                if (animationFrameId) cancelAnimationFrame(animationFrameId);
                if (sourceCodeLines.length === 0) {
                     sourceCodeLines = document.documentElement.outerHTML.split('\n');
                }
                generateWorld();
                if (walkableTiles.length < 50) {
                     console.log("Regenerating world: insufficient walkable tiles.");
                     init(); return;
                }
                bots = [];
                const startPos1 = walkableTiles[Math.floor(Math.random() * walkableTiles.length)];
                let startPos2 = walkableTiles[Math.floor(Math.random() * walkableTiles.length)];
                while(startPos1.x === startPos2.x && startPos1.y === startPos2.y) {
                    startPos2 = walkableTiles[Math.floor(Math.random() * walkableTiles.length)];
                }
                
                bots.push(new Bot(startPos1.x, startPos1.y, COLORS.FLEXI_BOT, { canUseStairs: true, canUseLifts: true }));
                bots.push(new Bot(startPos2.x, startPos2.y, COLORS.LIFT_BOT, { canUseStairs: false, canUseLifts: true }));
                
                spawnNewGoal();
                bots.forEach(b => b.findNewPath());
                gameLoop();
            }

            regenButton.addEventListener('click', init);
            init();
        });
    </script>
</body>
</html>
