<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modular Environment Explorer with Goal-Seeking Bot</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f0f2f5;
            color: #333;
            margin: 0;
            padding: 20px;
        }
        #bot-canvas {
            border: 2px solid #333;
            background-color: #fff;
        }
    </style>
</head>
<body>

    <canvas id="bot-canvas"></canvas>

    <script>
        // --- DOM Elements ---
        const canvas = document.getElementById('bot-canvas');
        const ctx = canvas.getContext('2d');

        // --- Configuration ---
        const GRID_SIZE = 140; 
        const CELL_SIZE = 8; 
        const CANVAS_SIZE = GRID_SIZE * CELL_SIZE;

        const TERRAIN = {
            EMPTY: 0,
            PATH: 1,
            PENALTY: 2,
            OBSTACLE: 3,
            VISITED_1: 4, // Red bot trail
            GOAL: 5,
            VISITED_2: 6  // Green bot trail
        };

        const COLORS = {
            [TERRAIN.EMPTY]: '#ffffff',
            [TERRAIN.PATH]: '#dcdcdc',
            [TERRAIN.PENALTY]: '#a9a9a9',
            [TERRAIN.OBSTACLE]: '#696969',
            [TERRAIN.VISITED_1]: '#ff8a80', // Brighter Light Red
            [TERRAIN.VISITED_2]: '#b9f6ca', // Brighter Light Green
            [TERRAIN.GOAL]: '#007bff',
            BOT_1: '#dc3545', // Red Bot
            BOT_2: '#28a745', // Green Bot
            BOT_1_RESTING: '#ffcdd2', // Lighter Red for resting
            BOT_2_RESTING: '#c8e6c9', // Lighter Green for resting
            grid: '#f5f5f5'
        };
        
        const MOVEMENT_COST = {
            [TERRAIN.PATH]: 1,
            [TERRAIN.VISITED_1]: 2,
            [TERRAIN.VISITED_2]: 2
        };

        // --- State ---
        let grid;
        let bot1, bot2; // Two bots
        let currentGoal;
        let bot1Interval, bot2Interval;

        // --- Bot Class ---
        class Bot {
            constructor(x, y, color, id) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.id = id; // 'bot1' or 'bot2'
                this.path = [];
                this.tilesMoved = 0;
                this.isResting = false;
                this.restThreshold = (id === 'bot1') ? 200 : 100;
            }

            move() {
                if (this.isResting) {
                    return; // Bot is resting, do nothing
                }

                // Mark current cell with this bot's specific visited trail
                if (grid[this.y][this.x] !== TERRAIN.OBSTACLE && grid[this.y][this.x] !== TERRAIN.GOAL) {
                    grid[this.y][this.x] = (this.id === 'bot1') ? TERRAIN.VISITED_1 : TERRAIN.VISITED_2;
                }
                
                if (this.path.length === 0) return;
                
                const nextStep = this.path.shift();
                this.x = nextStep.x;
                this.y = nextStep.y;
                this.tilesMoved++;

                // Check if it's time to rest
                if (this.tilesMoved >= this.restThreshold) {
                    this.isResting = true;
                    this.tilesMoved = 0;
                    setTimeout(() => {
                        this.isResting = false;
                        // Recalculate path after resting in case goal moved
                        this.recalculatePath(currentGoal, grid);
                    }, 5000); // 5 seconds rest
                }
            }
            
            recalculatePath(goal, grid) {
                const start = { x: this.x, y: this.y };
                this.path = aStar(start, goal, grid, this);
            }

            draw() {
                if (this.isResting) {
                    ctx.fillStyle = (this.id === 'bot1') ? COLORS.BOT_1_RESTING : COLORS.BOT_2_RESTING;
                } else {
                    ctx.fillStyle = this.color;
                }
                ctx.fillRect(this.x * CELL_SIZE + 1, this.y * CELL_SIZE + 1, CELL_SIZE - 2, CELL_SIZE - 2);
            }
        }
        
        // --- A* Pathfinding Algorithm ---
        function aStar(start, end, grid, bot) {
            function heuristic(a, b) { // Manhattan distance
                return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
            }

            function getNeighbors(node) {
                const neighbors = [];
                const { x, y } = node;
                if (x > 0) neighbors.push({ x: x - 1, y });
                if (x < GRID_SIZE - 1) neighbors.push({ x: x + 1, y });
                if (y > 0) neighbors.push({ x, y: y - 1 });
                if (y < GRID_SIZE - 1) neighbors.push({ x, y: y + 1 });
                
                return neighbors.filter(n => grid[n.y][n.x] !== TERRAIN.OBSTACLE);
            }

            const startNode = { ...start, g: 0, h: heuristic(start, end), f: heuristic(start, end), parent: null };
            const openSet = [startNode];
            const closedSet = new Set();

            while (openSet.length > 0) {
                openSet.sort((a, b) => a.f - b.f);
                const current = openSet.shift();

                if (current.x === end.x && current.y === end.y) {
                    const path = [];
                    let temp = current;
                    while (temp.parent) {
                        path.push({ x: temp.x, y: temp.y });
                        temp = temp.parent;
                    }
                    return path.reverse();
                }

                closedSet.add(`${current.x},${current.y}`);

                for (const neighbor of getNeighbors(current)) {
                    if (closedSet.has(`${neighbor.x},${neighbor.y}`)) continue;

                    const terrainType = grid[neighbor.y][neighbor.x];
                    let cost = MOVEMENT_COST[terrainType] || 1;

                    if (terrainType === TERRAIN.PENALTY) {
                        if (bot.id === 'bot1') {
                            cost = 1;
                        } else if (bot.id === 'bot2') {
                            cost = 4;
                        }
                    }
                    
                    const gScore = current.g + cost;
                    
                    let neighborNode = openSet.find(n => n.x === neighbor.x && n.y === neighbor.y);

                    if (!neighborNode || gScore < neighborNode.g) {
                        if (!neighborNode) {
                            neighborNode = { ...neighbor };
                            openSet.push(neighborNode);
                        }
                        neighborNode.g = gScore;
                        neighborNode.h = heuristic(neighbor, end);
                        neighborNode.f = neighborNode.g + neighborNode.h;
                        neighborNode.parent = current;
                    }
                }
            }
            return [];
        }

        // --- Environment & Goal Management ---
        function spawnGoal() {
            if (currentGoal) {
                grid[currentGoal.y][currentGoal.x] = TERRAIN.PATH;
            }
            
            let goalPos;
            while(true) {
                const x = Math.floor(Math.random() * GRID_SIZE);
                const y = Math.floor(Math.random() * GRID_SIZE);
                if (grid[y][x] === TERRAIN.PATH || grid[y][x] === TERRAIN.PENALTY) {
                    goalPos = { x, y };
                    break;
                }
            }
            currentGoal = goalPos;
            grid[currentGoal.y][currentGoal.x] = TERRAIN.GOAL;
        }

        function spawnGoalAndRecalculatePaths() {
            spawnGoal(); 
            bot1.recalculatePath(currentGoal, grid);
            bot2.recalculatePath(currentGoal, grid);
        }

        // --- Environment Generation ---
        function generateEnvironment() {
            grid = new Array(GRID_SIZE).fill(0).map(() => new Array(GRID_SIZE).fill(TERRAIN.OBSTACLE));
            const prefabs = [
                { type: 'room', width: 8, height: 8 }, { type: 'room', width: 12, height: 8 },
                { type: 'corridor', length: 18, dir: 'h' }, { type: 'corridor', length: 15, dir: 'v' }
            ];
            const placedModules = [];

            const startX = Math.floor(GRID_SIZE / 2), startY = Math.floor(GRID_SIZE / 2);
            carveRoom(startX, startY, 8, 8);
            placedModules.push({ x: startX, y: startY, width: 8, height: 8 });

            for (let i = 0; i < 850; i++) {
                const existingModule = placedModules[Math.floor(Math.random() * placedModules.length)];
                const newPrefab = prefabs[Math.floor(Math.random() * prefabs.length)];
                let newX, newY;
                const side = Math.floor(Math.random() * 4);
                
                if (side === 0) {
                    newX = existingModule.x + Math.floor(Math.random() * existingModule.width);
                    newY = existingModule.y - (newPrefab.type === 'room' ? newPrefab.height : newPrefab.length);
                } else if (side === 1) {
                    newX = existingModule.x + existingModule.width;
                    newY = existingModule.y + Math.floor(Math.random() * existingModule.height);
                } else if (side === 2) {
                    newX = existingModule.x + Math.floor(Math.random() * existingModule.width);
                    newY = existingModule.y + existingModule.height;
                } else {
                    newX = existingModule.x - (newPrefab.type === 'room' ? newPrefab.width : 1);
                    newY = existingModule.y + Math.floor(Math.random() * existingModule.height);
                }

                if (newPrefab.type === 'room') {
                    if (canPlace(newX, newY, newPrefab.width, newPrefab.height)) {
                        carveRoom(newX, newY, newPrefab.width, newPrefab.height);
                        placedModules.push({ x: newX, y: newY, width: newPrefab.width, height: newPrefab.height });
                    }
                } else {
                    const width = newPrefab.dir === 'h' ? newPrefab.length : 1;
                    const height = newPrefab.dir === 'v' ? newPrefab.length : 1;
                    if (canPlace(newX, newY, width, height)) {
                        carveCorridor(newX, newY, newPrefab.length, newPrefab.dir);
                        placedModules.push({ x: newX, y: newY, width, height });
                    }
                }
            }
            
            let bot1Start = findValidStart();
            let bot2Start = findValidStart();
            bot1 = new Bot(bot1Start.x, bot1Start.y, COLORS.BOT_1, 'bot1');
            bot2 = new Bot(bot2Start.x, bot2Start.y, COLORS.BOT_2, 'bot2');
            
            spawnGoal();
            bot1.recalculatePath(currentGoal, grid);
            bot2.recalculatePath(currentGoal, grid);
        }

        function canPlace(x, y, w, h) {
            return x > 1 && y > 1 && x + w < GRID_SIZE - 2 && y + h < GRID_SIZE - 2;
        }

        function carveRoom(x, y, w, h) {
            for (let i = y; i < y + h; i++) {
                for (let j = x; j < x + w; j++) {
                    if (i < GRID_SIZE && j < GRID_SIZE && i >= 0 && j >= 0) {
                        grid[i][j] = Math.random() < 0.5 ? TERRAIN.PENALTY : TERRAIN.PATH;
                    }
                }
            }
        }
        
        function carveCorridor(x, y, len, dir) {
             for (let i = 0; i < len; i++) {
                let curX = dir === 'h' ? x + i : x;
                let curY = dir === 'v' ? y + i : y;
                if (curY < GRID_SIZE && curX < GRID_SIZE && curY >= 0 && curX >= 0) {
                    grid[curY][curX] = TERRAIN.PATH;
                }
            }
        }
        
        function findValidStart() {
            for (let i = 0; i < 2000; i++) {
                const x = Math.floor(Math.random() * GRID_SIZE);
                const y = Math.floor(Math.random() * GRID_SIZE);
                if (grid[y][x] === TERRAIN.PATH) return { x, y };
            }
            return { x: 1, y: 1 }; // Fallback
        }

        // --- Drawing ---
        function draw() {
            ctx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    ctx.fillStyle = COLORS[grid[y][x]];
                    ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                }
            }
            bot1.draw();
            bot2.draw();
            requestAnimationFrame(draw);
        }

        // --- Main Update Loops for each bot ---
        function updateBot1() {
            if (bot1.x === currentGoal.x && bot1.y === currentGoal.y) {
                spawnGoalAndRecalculatePaths();
                return;
            }
            if (bot1.path.length === 0 && (bot1.x !== currentGoal.x || bot1.y !== currentGoal.y)) {
                 bot1.recalculatePath(currentGoal, grid);
            }
            bot1.move();
        }

        function updateBot2() {
            if (bot2.x === currentGoal.x && bot2.y === currentGoal.y) {
                spawnGoalAndRecalculatePaths();
                return;
            }
            if (bot2.path.length === 0 && (bot2.x !== currentGoal.x || bot2.y !== currentGoal.y)) {
                 bot2.recalculatePath(currentGoal, grid);
            }
            bot2.move();
        }

        function initialize() {
            canvas.width = CANVAS_SIZE;
            canvas.height = CANVAS_SIZE;
            if (bot1Interval) clearInterval(bot1Interval);
            if (bot2Interval) clearInterval(bot2Interval);
            
            generateEnvironment();

            const redBotSpeed = 200;
            const greenBotSpeed = redBotSpeed / 0.8; // 250ms

            bot1Interval = setInterval(updateBot1, redBotSpeed); 
            bot2Interval = setInterval(updateBot2, greenBotSpeed); 

            if (!initialize.hasRun) {
                requestAnimationFrame(draw);
                initialize.hasRun = true;
            }
        }
        
        initialize();
    </script>
</body>
</html>
