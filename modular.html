<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Isometric Mechanical Modular — Big Patch (Web Audio + p5)</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.3/p5.min.js"></script>
<style>
  :root{--bg:#0c0f14; --panel:#141824; --ink:#e6eefc; --muted:#98a7c6; --accent:#80b2ff; --sig:#a8f0a2; --aud:#ffd37f;}
  html,body{margin:0;background:var(--bg);color:var(--ink);font-family:ui-sans-serif,system-ui,Segoe UI,Helvetica,Arial}
  .ui{position:fixed;inset:auto 12px 12px auto;background:var(--panel);border:1px solid #21283a;border-radius:12px;padding:12px 14px;box-shadow:0 10px 30px rgba(0,0,0,.35);max-width:420px}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  .btn{background:#1b2131;border:1px solid #2a3550;color:var(--ink);border-radius:10px;padding:10px 12px;cursor:pointer}
  .btn:focus{outline:2px solid var(--accent);outline-offset:2px}
  .kv{display:grid;grid-template-columns:auto 1fr;gap:6px 10px;font-size:12px;color:var(--muted);margin-top:8px}
  .legend{font-size:12px;color:var(--muted);margin-top:6px}
  input[type=range]{width:140px}
  label{font-size:12px;color:var(--muted)}
</style>
</head>
<body>
<div class="ui">
  <div class="row">
    <button id="start" class="btn" aria-label="Start/Stop Audio (Space)">Start Audio</button>
    <button id="reroute" class="btn" aria-label="New patch (R)">New Patch</button>
    <label>K chains <input id="kchains" type="range" min="1" max="6" step="1" value="3"></label>
  </div>
  <div class="kv">
    <div>Drag</div><div>Pan view</div>
    <div>Wheel</div><div>Zoom</div>
    <div>Space</div><div>Start/Stop Audio</div>
    <div>R</div><div>Re-seed patch</div>
  </div>
  <div class="legend">Now uses a space-filling snake to route <span style="color:#ffd37f">multiple long chains</span>; mint lines are modulators.</div>
</div>

<script>
/* ===== Module types ===== */
const TYPES = {
  SOURCE_NOISE:'SOURCE_NOISE', SOURCE_STRING:'SOURCE_STRING',
  SHAPER_FILTER:'SHAPER_FILTER', SHAPER_SHUTTER:'SHAPER_SHUTTER', RESONATOR:'RESONATOR',
  VCA:'VCA', MIXER:'MIXER', OUTPUT:'OUTPUT',
  MOD_LFO:'MOD_LFO', MOD_CAM:'MOD_CAM'
};
const AUDIO_TYPES = new Set([TYPES.SOURCE_NOISE,TYPES.SOURCE_STRING,TYPES.SHAPER_FILTER,TYPES.SHAPER_SHUTTER,TYPES.RESONATOR,TYPES.VCA,TYPES.MIXER,TYPES.OUTPUT]);

/* ===== Grid + camera ===== */
const N=10, SPACING=28, CUBE=14;
let camera={ox:0,oy:0,zoom:1,drag:false,px:0,py:0};
function isoProject(x,y,z){ const ix=(x-z)*SPACING*0.866, iy=(x+z)*SPACING*0.5 - y*SPACING*0.9; return {x:ix*camera.zoom+width/2+camera.ox, y:iy*camera.zoom+height/2+camera.oy}; }

/* ===== World state ===== */
let grid=[], seed=(Math.random()*1e9>>>0), longPath=[];
let ctx, audioGraph=null, activePatch=null, K=3;

function initGrid(seed=1){
  grid = Array.from({length:N},(_,x)=>Array.from({length:N},(_,y)=>Array.from({length:N},(_,z)=>{
    const h=(x*73856093 ^ y*19349663 ^ z*83492791 ^ seed)>>>0, r=h%100;
    if(r<9) return TYPES.SOURCE_NOISE;
    if(r<16) return TYPES.SOURCE_STRING;
    if(r<30) return TYPES.SHAPER_FILTER;
    if(r<42) return TYPES.RESONATOR;
    if(r<53) return TYPES.SHAPER_SHUTTER;
    if(r<65) return TYPES.VCA;
    if(r<73) return TYPES.MIXER;
    if(r<78) return TYPES.OUTPUT; // sprinkle some outputs
    if(r<90) return TYPES.MOD_LFO;
    return TYPES.MOD_CAM;
  })));
}

/* Make a single Hamiltonian-like “snake” that walks the whole grid */
function buildSnakePath(){
  const path=[];
  for(let y=0;y<N;y++){
    const yEven = (y%2===0);
    for(let z=0;z<N;z++){
      const zEven = (z%2===0);
      if ((yEven && zEven) || (!yEven && !zEven)) {
        for(let x=0;x<N;x++) path.push({x,y,z});
      } else {
        for(let x=N-1;x>=0;x--) path.push({x,y,z});
      }
    }
    // flip z order per layer to keep Manhattan continuity
    if (y<N-1){
      path.push({x:path[path.length-1].x,y:y+1,z:path[path.length-1].z});
    }
  }
  return path;
}

/* Pick K long segments along the snake and force a valid chain layout on each */
function buildBigPatch(Kchains=3){
  const L = longPath.length;
  const segLen = Math.floor(L/(Kchains+0.5)); // generous length
  const patches = [];
  for(let k=0;k<Kchains;k++){
    const start = Math.floor((k+0.25)*segLen*0.8);
    const end   = Math.min(L-1, start + segLen - 1);
    const seg   = longPath.slice(start, end+1);

    // Force useful roles along the segment (spread out)
    const idxS = 0;
    const idxF = Math.floor(seg.length*0.20);
    const idxR = Math.floor(seg.length*0.35);
    const idxT = Math.floor(seg.length*0.50);
    const idxV = Math.floor(seg.length*0.70);
    const idxM = Math.floor(seg.length*0.85);
    const idxO = seg.length-1;

    const S = seg[idxS], F = seg[idxF], R = seg[idxR], T = seg[idxT], V = seg[idxV], M = seg[idxM], O = seg[idxO];

    // Stamp module types to guarantee an audible chain
    grid[S.x][S.y][S.z] = (k%2? TYPES.SOURCE_STRING : TYPES.SOURCE_NOISE);
    grid[F.x][F.y][F.z] = TYPES.SHAPER_FILTER;
    grid[R.x][R.y][R.z] = TYPES.RESONATOR;
    grid[T.x][T.y][T.z] = TYPES.SHAPER_SHUTTER;
    grid[V.x][V.y][V.z] = TYPES.VCA;
    grid[M.x][M.y][M.z] = TYPES.MIXER;
    grid[O.x][O.y][O.z] = TYPES.OUTPUT;

    // Find nearby modulators
    const nearMod = (p,type,rad=2)=>{
      let best=null,bestD=1e9;
      for(let dx=-rad;dx<=rad;dx++)for(let dy=-rad;dy<=rad;dy++)for(let dz=-rad;dz<=rad;dz++){
        const x=p.x+dx,y=p.y+dy,z=p.z+dz; if(x<0||y<0||z<0||x>=N||y>=N||z>=N) continue;
        if (grid[x][y][z]===type){ const d=Math.abs(dx)+Math.abs(dy)+Math.abs(dz); if(d<bestD){bestD=d;best={x,y,z};} }
      }
      return best;
    };
    const LFO = nearMod(V, TYPES.MOD_LFO) || nearMod(T, TYPES.MOD_LFO) || seg[Math.max(1, Math.floor(seg.length*0.6))];
    grid[LFO.x][LFO.y][LFO.z] = TYPES.MOD_LFO;
    const CAM = nearMod(F, TYPES.MOD_CAM) || nearMod(T, TYPES.MOD_CAM) || seg[Math.max(1, Math.floor(seg.length*0.4))];
    grid[CAM.x][CAM.y][CAM.z] = TYPES.MOD_CAM;

    // Store this chain
    patches.push({
      source:S, shapers:[F,R,T], vca:V, mixer:M, output:O, modLFO:LFO, modCAM:CAM,
      audioPath: seg.slice(), // whole segment = long path
      modLines: [ pathBetween(LFO,V), pathBetween(CAM,F) ]
    });
  }
  return patches;
}

/* Manhattan route between two points (on the snake this is already contiguous; still useful for modulators) */
function pathBetween(a,b){
  const path=[{...a}], p={...a};
  const step=(axis,dir)=>{ p[axis]+=dir; path.push({...p}); };
  while(p.x!==b.x) step('x', p.x<b.x?1:-1);
  while(p.y!==b.y) step('y', p.y<b.y?1:-1);
  while(p.z!==b.z) step('z', p.z<b.z?1:-1);
  return path;
}

/* ===== Web Audio helpers (file-safe) ===== */
function mkCtx(){ const AC=window.AudioContext||window.webkitAudioContext; return new AC(); }
function mkGain(ctx,v=1){ const g=ctx.createGain(); g.gain.value=v; return g; }
function mkBiquad(ctx,type='lowpass',f=1200,Q=0.7){ const b=ctx.createBiquadFilter(); b.type=type; b.frequency.value=f; b.Q.value=Q; return b; }
function mkNoise(ctx){ const len=ctx.sampleRate*2|0, buf=ctx.createBuffer(1,len,ctx.sampleRate), ch=buf.getChannelData(0); for(let i=0;i<len;i++) ch[i]=Math.random()*2-1; const src=ctx.createBufferSource(); src.buffer=buf; src.loop=true; return src; }
function mkCamSequencer(ctx,steps=6,rate=2,depth=0.25){
  const g=mkGain(ctx,0); // will control gain.gain
  const cs=ctx.createConstantSource(); cs.offset.value=0; cs.connect(g.gain); cs.start();
  let t=ctx.currentTime; const dur=1/rate; const seq=Array.from({length:steps},(_,i)=> i%2? 0.4:1.0);
  function program(){ cs.offset.cancelScheduledValues(t); let tt=t; for(const v of seq){ cs.offset.setValueAtTime(v*depth, tt); tt+=dur; } t+=seq.length*dur; }
  program(); const iv=setInterval(program, Math.max(50, (seq.length*dur*500)|0));
  g.stop=()=>{ clearInterval(iv); try{cs.stop();}catch{} };
  return g;
}

/* Build audio from multiple long chains */
function realizeAudio(patches){
  if (audioGraph && audioGraph.stop) audioGraph.stop();
  ctx = ctx || mkCtx();
  const master = mkGain(ctx, 0.9); master.connect(ctx.destination);
  const stops=[];

  patches.forEach((P, i)=>{
    // Source
    const sType = grid[P.source.x][P.source.y][P.source.z];
    let src, srcOut;
    if (sType===TYPES.SOURCE_NOISE){ src = mkNoise(ctx); srcOut = mkGain(ctx, 0.45); src.connect(srcOut); src.start(); stops.push(()=>{try{src.stop();}catch{}}); }
    else { const osc=ctx.createOscillator(); osc.type='triangle'; osc.frequency.value=160 + i*15; const g=mkGain(ctx,0.35); osc.connect(g); osc.start(); src=osc; srcOut=g; stops.push(()=>{try{osc.stop();}catch{}}); }

    // Shapers (serial)
    let chain = srcOut;
    const shapers = P.shapers || [];
    shapers.forEach((node,j)=>{
      const t = grid[node.x][node.y][node.z];
      if (t===TYPES.SHAPER_FILTER){ const b=mkBiquad(ctx,'lowpass', 1800 - i*200, 0.7); chain.connect(b); chain=b; }
      else if (t===TYPES.RESONATOR){ const b=mkBiquad(ctx,'bandpass', 900 + i*120, 6); chain.connect(b); chain=b; }
      else if (t===TYPES.SHAPER_SHUTTER){
        const g=mkGain(ctx,0.8), lfo=ctx.createOscillator(), amt=mkGain(ctx,0.3);
        lfo.type='sine'; lfo.frequency.value=3 + i*0.5; lfo.connect(amt); amt.connect(g.gain); lfo.start();
        stops.push(()=>{try{lfo.stop();}catch{}});
        chain.connect(g); chain=g;
      }
    });

    // VCA → Mixer → Master
    const vca=mkGain(ctx, 0.10 + 0.04*i);
    chain.connect(vca);
    const mix=mkGain(ctx,1.0); vca.connect(mix); mix.connect(master);

    // LFO → VCA.gain
    if (P.modLFO){
      const lfo=ctx.createOscillator(), amt=mkGain(ctx, 0.18);
      lfo.type='sine'; lfo.frequency.value = 0.25 + 0.15*i; lfo.connect(amt); amt.connect(vca.gain); lfo.start();
      stops.push(()=>{try{lfo.stop();}catch{}});
    }

    // CAM → VCA.gain (stepped trem)
    if (P.modCAM){
      const cam=mkCamSequencer(ctx, 6+i, 1.5+i*0.25, 0.22);
      cam.connect(vca.gain);
      stops.push(()=>cam.stop());
    }

    // Gentle pitch wander for string sources
    if (src && src.frequency){
      const base=160 + 20*i, t0=ctx.currentTime;
      const iv=setInterval(()=>{
        const t=ctx.currentTime - t0, f = base + 12*Math.sin(t*0.25 + i);
        try{ src.frequency.linearRampToValueAtTime(f, ctx.currentTime+0.05);}catch{}
      }, 60);
      stops.push(()=>clearInterval(iv));
    }
  });

  audioGraph = { stop(){ stops.forEach(fn=>{try{fn();}catch{}}); } };
}

/* ===== Visualization ===== */
function drawCube(x,y,z,col){ const p=isoProject(x,y,z), s=CUBE*camera.zoom; noStroke(); fill(col); rect(p.x-s*0.5,p.y-s*0.5,s,s,4); }
function drawLine3D(a,b,col){ const pa=isoProject(a.x,a.y,a.z), pb=isoProject(b.x,b.y,b.z); stroke(col); strokeWeight(2.2*camera.zoom); line(pa.x,pa.y,pb.x,pb.y); }

/* ===== App flow ===== */
function reseed(){
  initGrid(seed);
  longPath = buildSnakePath();
  const patches = buildBigPatch(K);
  activePatch = patches;
  if (ctx) realizeAudio(patches);
}

function setup(){
  createCanvas(window.innerWidth, window.innerHeight); pixelDensity(window.devicePixelRatio||1);
  camera.zoom=1.15;
  initGrid(seed);
  longPath = buildSnakePath();
  activePatch = buildBigPatch(K);
}

function windowResized(){ resizeCanvas(window.innerWidth, window.innerHeight); }

function draw(){
  background('#0b0e14');

  // Draw sparse background cubes for performance (every other)
  for (let y=0;y<N;y++){
    for (let x=0;x<N;x++){
      for (let z=0;z<N;z++){
        if ((x+y+z)%2) continue;
        const t=grid[x][y][z];
        let c='#131b2a'; if (AUDIO_TYPES.has(t)) c='#162138'; else c='#182532';
        drawCube(x-N/2,y-N/2,z-N/2,c);
      }
    }
  }

  // Draw all chains (audio = gold)
  activePatch.forEach(P=>{
    const AP=P.audioPath;
    for(let i=1;i<AP.length;i++){
      const a=AP[i-1], b=AP[i];
      drawLine3D({x:a.x-N/2,y:a.y-N/2,z:a.z-N/2},{x:b.x-N/2,y:b.y-N/2,z:b.z-N/2},'#ffd37f');
    }
    // mod lines (mint)
    P.modLines.forEach(path=>{
      for(let i=1;i<path.length;i++){
        const a=path[i-1], b=path[i];
        drawLine3D({x:a.x-N/2,y:a.y-N/2,z:a.z-N/2},{x:b.x-N/2,y:b.y-N/2,z:b.z-N/2},'#a8f0a2');
      }
    });
    // highlight endpoints
    drawCube(P.source.x-N/2,P.source.y-N/2,P.source.z-N/2,'#24416d');
    P.shapers.forEach(s=>drawCube(s.x-N/2,s.y-N/2,s.z-N/2,'#2c4f7f'));
    drawCube(P.vca.x-N/2,P.vca.y-N/2,P.vca.z-N/2,'#405a22');
    drawCube(P.mixer.x-N/2,P.mixer.y-N/2,P.mixer.z-N/2,'#4b3f1c');
    drawCube(P.output.x-N/2,P.output.y-N/2,P.output.z-N/2,'#6a2f2f');
  });
}

/* ===== Interactions ===== */
function mousePressed(){ camera.drag=true; camera.px=mouseX; camera.py=mouseY; }
function mouseReleased(){ camera.drag=false; }
function mouseDragged(){ if(camera.drag){ camera.ox += (mouseX-camera.px); camera.oy += (mouseY-camera.py); camera.px=mouseX; camera.py=mouseY; } }
function mouseWheel(e){ const k=1 + (-e.deltaY*0.001); camera.zoom=Math.max(0.35,Math.min(2.5,camera.zoom*k)); return false; }

window.addEventListener('keydown', (e)=>{
  if (e.code==='Space'){ e.preventDefault(); document.getElementById('start').click(); }
  if (e.key==='r' || e.key==='R'){ document.getElementById('reroute').click(); }
});

/* Buttons */
document.getElementById('start').onclick = async ()=>{
  if (!ctx){ ctx = mkCtx(); }
  if (ctx.state!=='running'){ await ctx.resume(); }
  if (!audioGraph){ realizeAudio(activePatch); document.getElementById('start').textContent='Stop Audio'; return; }
  // toggle off
  if (audioGraph){ audioGraph.stop(); audioGraph=null; try{ctx.close();}catch{} ctx=null; document.getElementById('start').textContent='Start Audio'; }
};
document.getElementById('reroute').onclick = ()=>{
  seed = (seed*1664525 + 1013904223)>>>0;
  K = +document.getElementById('kchains').value;
  reseed();
};
document.getElementById('kchains').addEventListener('input', e=>{
  K = +e.target.value;
  reseed();
});
</script>
</body>
</html>




