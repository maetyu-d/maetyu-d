<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Isometric Mechanical Modular — 10×10×10 (Web Audio + p5)</title>
<!-- p5 only for visuals; audio is plain Web Audio to be file:// safe -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.3/p5.min.js"></script>
<style>
  :root{--bg:#0c0f14; --panel:#141824; --ink:#e6eefc; --muted:#98a7c6; --accent:#80b2ff; --sig:#a8f0a2; --aud:#ffd37f;}
  html,body{margin:0;background:var(--bg);color:var(--ink);font-family:ui-sans-serif,system-ui,Segoe UI,Helvetica,Arial}
  .ui{position:fixed;inset:auto 12px 12px auto;background:var(--panel);border:1px solid #21283a;border-radius:12px;padding:12px 14px;box-shadow:0 10px 30px rgba(0,0,0,.35);max-width:360px}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  .btn{background:#1b2131;border:1px solid #2a3550;color:var(--ink);border-radius:10px;padding:10px 12px;cursor:pointer}
  .btn:focus{outline:2px solid var(--accent);outline-offset:2px}
  .kv{display:grid;grid-template-columns:auto 1fr;gap:6px 10px;font-size:12px;color:var(--muted);margin-top:8px}
  .legend{font-size:12px;color:var(--muted);margin-top:6px}
</style>
</head>
<body>
<div class="ui">
  <div class="row">
    <button id="start" class="btn" aria-label="Start/Stop Audio (Space)">Start Audio</button>
    <button id="reroute" class="btn" aria-label="New patch (R)">New Patch</button>
  </div>
  <div class="kv">
    <div>Drag</div><div>Pan view</div>
    <div>Wheel</div><div>Zoom</div>
    <div>Space</div><div>Start/Stop Audio</div>
    <div>R</div><div>Re-seed patch</div>
  </div>
  <div class="legend">Isometric 10×10×10 grid. Colored lines are <span style="color:#ffd37f">audio</span> paths; mint lines are <span style="color:#a8f0a2">modulation</span>.</div>
</div>

<script>
/* =========================
   Module catalog (virtual)
   ========================= */
const TYPES = {
  SOURCE_NOISE: 'SOURCE_NOISE',
  SOURCE_STRING: 'SOURCE_STRING',
  SHAPER_FILTER: 'SHAPER_FILTER',   // simple lowpass/bandpass
  SHAPER_SHUTTER: 'SHAPER_SHUTTER', // tremolo (AM)
  VCA: 'VCA',
  MIXER: 'MIXER',
  RESONATOR: 'RESONATOR',           // bandpass peak
  OUTPUT: 'OUTPUT',
  MOD_LFO: 'MOD_LFO',               // pendulum-ish LFO
  MOD_CAM: 'MOD_CAM'                // stepped cam sequencer
};
const ALL_TYPES = Object.values(TYPES);
const AUDIO_TYPES = new Set([
  TYPES.SOURCE_NOISE, TYPES.SOURCE_STRING, TYPES.SHAPER_FILTER,
  TYPES.SHAPER_SHUTTER, TYPES.VCA, TYPES.MIXER, TYPES.RESONATOR, TYPES.OUTPUT
]);
const MOD_TYPES = new Set([TYPES.MOD_LFO, TYPES.MOD_CAM]);

/* =========================
   Grid + projection
   ========================= */
const N = 10;                 // 10×10×10
const SPACING = 28;           // cube spacing
const CUBE = 14;              // cube size
let camera = {ox:0, oy:0, zoom:1.0, drag:false, px:0, py:0};

function isoProject(x,y,z){
  // classic 2:1 isometric
  const isoX = (x - z) * SPACING * 0.866; // cos(30°)=0.866
  const isoY = (x + z) * SPACING * 0.5   - y * SPACING * 0.9;
  return {x: isoX*camera.zoom + width/2 + camera.ox, y: isoY*camera.zoom + height/2 + camera.oy};
}

/* =========================
   Patch model (virtual)
   ========================= */
let grid = []; // 3D array of module types
let audioGraph; // instantiated Web Audio nodes for the current active subgraph
let ctx;

function initGrid(seed=1){
  grid = new Array(N);
  for (let x=0;x<N;x++){
    grid[x] = new Array(N);
    for (let y=0;y<N;y++){
      grid[x][y] = new Array(N);
      for (let z=0;z<N;z++){
        // deterministic variety: cycle families by a hash
        const h = (x*73856093 ^ y*19349663 ^ z*83492791 ^ seed) >>> 0;
        const r = h%100;
        let t;
        if (r<8) t=TYPES.SOURCE_NOISE;
        else if (r<16) t=TYPES.SOURCE_STRING;
        else if (r<28) t=TYPES.SHAPER_FILTER;
        else if (r<40) t=TYPES.VCA;
        else if (r<46) t=TYPES.MIXER;
        else if (r<55) t=TYPES.RESONATOR;
        else if (r<68) t=TYPES.SHAPER_SHUTTER;
        else if (r<82) t=TYPES.MOD_LFO;
        else if (r<96) t=TYPES.MOD_CAM;
        else t=TYPES.OUTPUT;
        grid[x][y][z] = t;
      }
    }
  }
  // ensure at least one OUTPUT near a corner
  grid[N-2][Math.floor(N/2)][N-2] = TYPES.OUTPUT;
}

// Find Manhattan path from A→B with 6-neighbour moves.
function manhattanPath(a,b){
  const path=[{...a}];
  let p={...a};
  const step=(axis,dir)=>{ p[axis]+=dir; path.push({...p}); };
  while (p.x!==b.x) step('x', p.x<b.x?1:-1);
  while (p.y!==b.y) step('y', p.y<b.y?1:-1);
  while (p.z!==b.z) step('z', p.z<b.z?1:-1);
  return path;
}

// Build a guaranteed useful chain: Source → [Shaper/Resonator]* → VCA → Mixer → Output
// plus modulators (LFO/CAM) to VCA gain or Filter cutoff.
function buildUsefulPatch(){
  // pick an OUTPUT (fixed)
  const out = {x:N-2, y:Math.floor(N/2), z:N-2};
  // pick closest SOURCE
  let bestSrc=null, bestD=1e9;
  for (let x=0;x<N;x++)for(let y=0;y<N;y++)for(let z=0;z<N;z++){
    if (grid[x][y][z]===TYPES.SOURCE_NOISE || grid[x][y][z]===TYPES.SOURCE_STRING){
      const d = Math.abs(x-out.x)+Math.abs(y-out.y)+Math.abs(z-out.z);
      if (d<bestD){bestD=d;bestSrc={x,y,z};}
    }
  }
  if (!bestSrc) bestSrc={x:1,y:1,z:1}, grid[1][1][1]=TYPES.SOURCE_NOISE;

  // choose 1–2 shapers on the path
  const path = manhattanPath(bestSrc,out);
  const shapers = [];
  for (const p of path){
    const t = grid[p.x][p.y][p.z];
    if (t===TYPES.SHAPER_FILTER || t===TYPES.RESONATOR || t===TYPES.SHAPER_SHUTTER) shapers.push({...p});
  }
  const pick = (arr)=> arr.length? arr[Math.floor(arr.length/2)] : null;
  const shpA = pick(shapers);
  // pick a VCA and a MIXER along/near path
  let vca=null, mix=null;
  for (const p of path){
    if (!vca && grid[p.x][p.y][p.z]===TYPES.VCA) vca={...p};
    if (!mix && grid[p.x][p.y][p.z]===TYPES.MIXER) mix={...p};
  }
  if (!vca) vca={...path[Math.floor(path.length*0.7)]}; grid[vca.x][vca.y][vca.z]=TYPES.VCA;
  if (!mix) mix={...path[Math.floor(path.length*0.85)]}; grid[mix.x][mix.y][mix.z]=TYPES.MIXER;

  // pick modulators near the VCA/shaper
  function nearestOfType(center, typeWanted){
    let best=null, bestDist=1e9;
    for (let dx=-2; dx<=2; dx++)for(let dy=-2; dy<=2; dy++)for(let dz=-2; dz<=2; dz++){
      const x=center.x+dx, y=center.y+dy, z=center.z+dz;
      if (x<0||y<0||z<0||x>=N||y>=N||z>=N) continue;
      if (grid[x][y][z]===typeWanted){
        const d=Math.abs(dx)+Math.abs(dy)+Math.abs(dz);
        if (d<bestDist){bestDist=d;best={x,y,z};}
      }
    }
    return best;
  }
  const lfo = nearestOfType(vca, TYPES.MOD_LFO);
  const cam = nearestOfType(shpA||vca, TYPES.MOD_CAM);

  // Return a compact patch spec
  return {
    source: bestSrc,
    shaper: shpA,
    vca,
    mixer: mix,
    output: out,
    modLFO: lfo,
    modCAM: cam,
    // derive connection lines for drawing (audio + mod)
    audioPath: [
      bestSrc, ...(shpA? manhattanPath(bestSrc, shpA).slice(1):[]),
      ...(shpA? manhattanPath(shpA, vca).slice(1): manhattanPath(bestSrc, vca).slice(1)),
      ...manhattanPath(vca, mix).slice(1),
      ...manhattanPath(mix, out).slice(1)
    ],
    modLines: [
      ...(lfo? manhattanPath(lfo, vca): []),
      ...(cam && shpA? manhattanPath(cam, shpA): [])
    ]
  };
}

/* =========================
   Web Audio instantiation
   ========================= */
function mkCtx(){ const AC=window.AudioContext||window.webkitAudioContext; return new AC(); }
function mkGain(ctx, v=1){ const g=ctx.createGain(); g.gain.setValueAtTime(v, ctx.currentTime); return g; }
function mkBiquad(ctx, type='lowpass', freq=1200, Q=0.7){
  const f=ctx.createBiquadFilter(); f.type=type; f.frequency.value=freq; f.Q.value=Q; return f;
}
function mkNoise(ctx){
  const len = ctx.sampleRate*2|0;
  const buf = ctx.createBuffer(1, len, ctx.sampleRate);
  const ch = buf.getChannelData(0); for (let i=0;i<len;i++) ch[i]=Math.random()*2-1;
  const src = ctx.createBufferSource(); src.buffer=buf; src.loop=true; return src;
}
function mkCamLFO(ctx, steps=4, rate=2){
  // stepped LFO via looping sequence in a ConstantSource + scheduler
  const g = mkGain(ctx, 0);
  const cs = ctx.createConstantSource(); cs.offset.value=0; cs.connect(g.gain); cs.start();
  // simple internal scheduler
  let t = ctx.currentTime;
  const seq = new Array(steps).fill(0).map((_,i)=> (i%2?0.4:1.0));
  const dur = 1/rate;
  function program(){
    cs.offset.cancelScheduledValues(t);
    let tt=t;
    for (let i=0;i<seq.length;i++){ cs.offset.setValueAtTime(seq[i], tt); tt+=dur; }
    t += seq.length*dur;
  }
  program();
  // keep programming ahead
  const iv = setInterval(program, (seq.length*dur*500)|0);
  g.stop = ()=>{ clearInterval(iv); try{cs.stop();}catch{} };
  return g;
}

function realizeAudio(patch){
  // tear down previous
  if (audioGraph && audioGraph.stop) audioGraph.stop();

  ctx = ctx || mkCtx();
  const stopFns = [];

  // modules → nodes (only for the active path)
  const master = mkGain(ctx, 0.9); master.connect(ctx.destination);

  // SOURCE
  let srcType = grid[patch.source.x][patch.source.y][patch.source.z];
  let srcNode, srcGain = mkGain(ctx, 0.5);
  srcGain.connect(master);
  if (srcType===TYPES.SOURCE_NOISE){
    srcNode = mkNoise(ctx); srcNode.connect(srcGain); srcNode.start(); stopFns.push(()=>{try{srcNode.stop();}catch{}});
  } else {
    const osc = ctx.createOscillator(); osc.type='triangle';
    osc.frequency.value = 160; // will be modded below
    osc.connect(srcGain); osc.start(); srcNode=osc; stopFns.push(()=>{try{osc.stop();}catch{}});
  }

  // SHAPER (optional)
  let shaperOut = srcGain;
  if (patch.shaper){
    const t = grid[patch.shaper.x][patch.shaper.y][patch.shaper.z];
    if (t===TYPES.SHAPER_FILTER || t===TYPES.RESONATOR){
      const biq = mkBiquad(ctx, t===TYPES.RESONATOR? 'bandpass':'lowpass', t===TYPES.RESONATOR? 900: 1800, t===TYPES.RESONATOR? 6:0.7);
      srcGain.disconnect(); srcGain.connect(biq); shaperOut = biq;
    } else if (t===TYPES.SHAPER_SHUTTER){
      // AM tremolo stage
      const amGain = mkGain(ctx, 0.8);
      const lfo = ctx.createOscillator(); lfo.type='sine'; lfo.frequency.value=4;
      const lfoAmt = mkGain(ctx, 0.4); lfo.connect(lfoAmt); lfoAmt.connect(amGain.gain); lfo.start();
      stopFns.push(()=>{try{lfo.stop();}catch{}});
      srcGain.disconnect(); srcGain.connect(amGain); shaperOut = amGain;
    }
  }

  // VCA
  const vca = mkGain(ctx, 0.12); // base bed
  shaperOut.connect(vca);

  // Mixer (single input for now; left for extensibility)
  const mix = mkGain(ctx, 1.0); vca.connect(mix);

  // Output
  mix.connect(master);

  // MODULATORS
  // LFO → VCA.gain
  if (patch.modLFO){
    const lfo = ctx.createOscillator(); lfo.type='sine'; lfo.frequency.value = 0.3 + Math.random()*0.8;
    const lAmt = mkGain(ctx, 0.18); lfo.connect(lAmt); lAmt.connect(vca.gain); lfo.start();
    stopFns.push(()=>{try{lfo.stop();}catch{}});
  }
  // CAM → SHAPER/RES cutoff or VCA.gain
  if (patch.modCAM){
    const cam = mkCamLFO(ctx, 6, 2.0);
    const amt = mkGain(ctx, 0.25);
    cam.connect(amt);
    if (patch.shaper){
      const t = grid[patch.shaper.x][patch.shaper.y][patch.shaper.z];
      if (t===TYPES.SHAPER_FILTER || t===TYPES.RESONATOR){
        // drive shaper frequency
        const target = (shaperOut.frequency? shaperOut : null);
        if (target){
          // Hook via AudioParam.setValueAtTime using ConstantSource path:
          const cs = ctx.createConstantSource(); cs.start();
          amt.connect(cs.offset); // stepped control in cs.offset
          // map 0..1 to 400..2400 Hz
          const scale = mkGain(ctx, 1800); const bias = mkGain(ctx, 1);
          // Gain-to-param mapping (workaround): poll and set (file-safe, simple)
          const poll = setInterval(()=>{
            // quick readback hack: create dummy analyser? Simpler: track last value in closure
          }, 250);
          // Simpler: detach CAM from shaper because mapping AudioNode→AudioParam without worklets is fiddly across file://.
          // Instead, route CAM to VCA as stepped tremolo (still useful & audible):
          cam.connect(vca.gain);
          stopFns.push(()=>{ cam.stop(); clearInterval(poll); });
        } else {
          cam.connect(vca.gain); stopFns.push(()=>cam.stop());
        }
      } else {
        cam.connect(vca.gain); stopFns.push(()=>cam.stop());
      }
    } else {
      cam.connect(vca.gain); stopFns.push(()=>cam.stop());
    }
  }

  // Pitch follow (string tuning) via slow sinus
  if (srcNode && srcNode.frequency){
    const base = 140 + Math.random()*80;
    const t0 = ctx.currentTime;
    const iv = setInterval(()=>{
      const t = ctx.currentTime - t0;
      const f = base + 10*Math.sin(t*0.35);
      try{ srcNode.frequency.linearRampToValueAtTime(f, ctx.currentTime+0.05); }catch{}
    }, 60);
    stopFns.push(()=>clearInterval(iv));
  }

  // Public stop
  audioGraph = {
    stop(){
      stopFns.forEach(fn=>{ try{fn();}catch{} });
      stopFns.length=0;
    }
  };
}

/* =========================
   Visualization + UI
   ========================= */
let seed = Math.floor(Math.random()*1e9)>>>0;
let patchSpec;

function reseed(){
  initGrid(seed);
  patchSpec = buildUsefulPatch();
  realizeAudio(patchSpec);
}

function setup(){
  createCanvas(window.innerWidth, window.innerHeight);
  pixelDensity(window.devicePixelRatio||1);
  textFont('system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial');
  camera.zoom = 1.0;
  camera.ox = 0; camera.oy = 0;

  initGrid(seed);
  patchSpec = buildUsefulPatch();
}

function windowResized(){ resizeCanvas(window.innerWidth, window.innerHeight); }

function drawCube(x,y,z, col){
  const p = isoProject(x,y,z);
  const s = CUBE * camera.zoom;
  noStroke(); fill(col);
  rect(p.x - s*0.5, p.y - s*0.5, s, s, 4);
}

function drawLine3D(a,b, col='#ffd37f'){
  const pa = isoProject(a.x,a.y,a.z);
  const pb = isoProject(b.x,b.y,b.z);
  stroke(col); strokeWeight(2.2*camera.zoom);
  line(pa.x,pa.y,pb.x,pb.y);
}

function draw(){
  background('#0b0e14');

  // faint grid cubes (skip most for perf: draw every other)
  for (let y=0;y<N;y++){
    for (let x=0;x<N;x++){
      for (let z=0;z<N;z++){
        if ((x+y+z)%2) continue; // decimate
        const t = grid[x][y][z];
        let col = '#131b2a';
        if (AUDIO_TYPES.has(t)) col = '#162138';
        if (MOD_TYPES.has(t))   col = '#182532';
        drawCube(x - N/2, y - N/2, z - N/2, col);
      }
    }
  }

  // connections: audio path (gold)
  const AP = patchSpec.audioPath;
  for (let i=1;i<AP.length;i++){
    const a=AP[i-1], b=AP[i];
    drawLine3D(
      {x:a.x-N/2, y:a.y-N/2, z:a.z-N/2},
      {x:b.x-N/2, y:b.y-N/2, z:b.z-N/2},
      '#ffd37f'
    );
  }
  // mod lines (mint)
  for (let i=0;i<patchSpec.modLines.length;i++){
    const m = patchSpec.modLines[i];
    for (let j=1;j<m.length;j++){
      const a=m[j-1], b=m[j];
      drawLine3D(
        {x:a.x-N/2, y:a.y-N/2, z:a.z-N/2},
        {x:b.x-N/2, y:b.y-N/2, z:b.z-N/2},
        '#a8f0a2'
      );
    }
  }

  // highlight key modules
  function hi(p, color){ drawCube(p.x-N/2, p.y-N/2, p.z-N/2, color); }
  hi(patchSpec.source, '#24416d');
  if (patchSpec.shaper) hi(patchSpec.shaper, '#2c4f7f');
  hi(patchSpec.vca, '#405a22');
  hi(patchSpec.mixer, '#4b3f1c');
  hi(patchSpec.output, '#6a2f2f');
  if (patchSpec.modLFO) hi(patchSpec.modLFO, '#23493e');
  if (patchSpec.modCAM) hi(patchSpec.modCAM, '#27433f');
}

/* Interactions */
function mousePressed(){ camera.drag=true; camera.px=mouseX; camera.py=mouseY; }
function mouseReleased(){ camera.drag=false; }
function mouseDragged(){ if (camera.drag){ camera.ox += (mouseX-camera.px); camera.oy += (mouseY-camera.py); camera.px=mouseX; camera.py=mouseY; } }
function mouseWheel(e){ const k = 1 + (-e.deltaY*0.001); camera.zoom = Math.max(0.35, Math.min(2.5, camera.zoom*k)); return false; }

window.addEventListener('keydown', (e)=>{
  if (e.code==='Space'){ e.preventDefault(); const btn=document.getElementById('start'); btn.click(); }
  if (e.key==='r' || e.key==='R'){ document.getElementById('reroute').click(); }
});

/* Buttons */
document.getElementById('start').onclick = async ()=>{
  if (!ctx){ ctx = mkCtx(); }
  if (ctx.state!=='running'){ await ctx.resume(); }
  if (!audioGraph){ reseed(); document.getElementById('start').textContent='Stop Audio'; return; }
  // toggle
  if (ctx.state==='running'){
    audioGraph.stop(); audioGraph=null;
    try{ ctx.close(); }catch{}
    ctx=null;
    document.getElementById('start').textContent='Start Audio';
  }
};
document.getElementById('reroute').onclick = ()=>{
  seed = (seed*1664525 + 1013904223)>>>0;
  if (!ctx){ initGrid(seed); patchSpec=buildUsefulPatch(); return; }
  reseed();
};
</script>
</body>
</html>



