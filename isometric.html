<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Spectral Triangulation — Prototype (Procedural)</title>
<style>
  :root{ --tile:32px; }
  html,body{margin:0;height:100%}
  body{background:#000;color:#e6f0ff;font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace}
  .wrap{display:grid;grid-template-columns:1fr 320px;min-height:100vh}
  #view{position:relative;background:#000}
  canvas{display:block;width:100%;height:100%;background:#000;image-rendering:pixelated;outline:none}
  /* HUD */
  aside#hud{background:#0a0d14;border-left:1px solid #142034;display:flex;flex-direction:column}
  .hud-section{padding:10px 12px;border-bottom:1px solid #142034}
  .hud-section h3{margin:0 0 8px;font-size:12px;letter-spacing:.12em;text-transform:uppercase;color:#8aa6c9}
  .radio{display:grid;gap:8px}
  .kbd{background:#0f141c;border:1px solid #233047;border-radius:6px;padding:0 6px;color:#79ffe1}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .bar{height:10px;background:#0e1420;border:1px solid #233047;border-radius:999px;overflow:hidden}
  .bar>span{display:block;height:100%;background:linear-gradient(90deg,#5ad1ff,#79ffe1)}
  input[type=range]{width:100%}
  #log{flex:1;overflow:auto;font-size:12px;color:#cfe4ff}
  #log p{margin:0 0 8px}

  /* On-screen widgets */
  #badgeToggle{position:absolute;left:12px;top:12px;background:#0b1220;color:#d8f8ff;border:1px solid #1c2940;padding:8px 12px;border-radius:999px;cursor:pointer;user-select:none;z-index:5}
  #badgeToggle small{display:block;color:#8aa6c9;margin-top:2px}
  #toast{position:absolute;left:50%;transform:translateX(-50%);bottom:18px;background:#0b0f18;border:1px solid #1e2b44;padding:8px 12px;border-radius:8px;color:#9bb3d1;opacity:0;transition:opacity .25s;pointer-events:none;max-width:70%}
  #dialogueBox{position:absolute;left:50%;top:10%;transform:translateX(-50%);max-width:70%;background:rgba(10,15,20,0.88);border:1px solid #233047;color:#cfe4ff;padding:12px;border-radius:10px;font-size:14px;line-height:1.4;z-index:6;display:none}
</style>
</head>
<body>
  <div class="wrap">
    <section id="view">
      <canvas id="game" tabindex="0"></canvas>
      <div id="badgeToggle" title="Toggle Spectral (Space)">
        <div><b>Mode:</b> <span id="modeLabel">Explore</span></div>
        <small>Space • Click</small>
      </div>
      <div id="toast"></div>
      <div id="dialogueBox"></div>
    </section>

    <aside id="hud">
      <div class="hud-section">
        <h3>Radio HUD</h3>
        <div class="radio">
          <label>Frequency <span class="kbd" id="freqLbl">0.500</span>
            <input id="freq" type="range" min="0" max="1000" value="500">
          </label>
          <label>Q-Factor <span class="kbd" id="qLbl">2.5</span>
            <input id="q" type="range" min="5" max="300" value="150">
          </label>
          <div class="row">
            <span>Alignment</span>
            <div class="bar" style="flex:1"><span id="alignBar" style="width:0%"></span></div>
            <span id="alignTxt" class="kbd">0%</span>
          </div>
          <div class="row"><span>Band hint:</span> <span id="bandHint" class="kbd">—</span></div>
        </div>
      </div>

      <div class="hud-section">
        <h3>Controls</h3>
        <div class="row" style="gap:6px;font-size:12px;color:#9bb3d1">
          <div>Move (<b>Explore</b>): <span class="kbd">WASD</span>/<span class="kbd">Arrows</span></div>
          <div>Crosshair (<b>Spectral</b>): <span class="kbd">WASD</span>/<span class="kbd">Arrows</span></div>
          <div>Tuning: <span class="kbd">[ ]</span> freq, <span class="kbd">- =</span> Q</div>
          <div>Toggle: <span class="kbd">Space</span></div>
          <div>Archive: <span class="kbd">Enter</span></div>
        </div>
      </div>

      <div id="log" class="hud-section"></div>
    </aside>
  </div>

<script>
/* ---------- Utilities & constants ---------- */
const clamp=(v,a,b)=>Math.min(Math.max(v,a),b);
function rand(seed){ let t = seed>>>0; return ()=>((t+=0x6D2B79F5),t=Math.imul(t^t>>>15,t|1),t^=t+Math.imul(t^t>>>7,t|61),((t^t>>>14)>>>0)/4294967296); }
function choose(rng,arr){ return arr[Math.floor(rng()*arr.length)]; }

const MODE={EXPLORE:'explore',SPECTRAL:'spectral'};
const GRID={W:21,H:15,TILE:32,MARGIN_X:32,MARGIN_Y:32};
const DIFFICULTY={mode:'Balanced'}; // 'Guided' | 'Balanced' | 'Hardcore'

const state={
  rng:rand(((Date.now()&0xfffffff)^0xC0DE)>>>0),
  mode:MODE.EXPLORE,
  mission:1,
  player:{x:0,y:0},
  camera:{x:0,y:0},
  antenna:{x:0,y:0},
  spectral:{freq:0.5,q:2.5,align:0,buffQ:0,heatPhase:0},
  transmitter:null
};

/* ---------- Canvas / HUD refs ---------- */
const canvas=document.getElementById('game');
const ctx=canvas.getContext('2d');
function resize(){ canvas.width=canvas.clientWidth; canvas.height=canvas.clientHeight; }
new ResizeObserver(resize).observe(canvas); resize();

const elModeLabel=document.getElementById('modeLabel');
const elFreq=document.getElementById('freq');
const elQL=document.getElementById('q');
const elFreqLbl=document.getElementById('freqLbl');
const elQLbl=document.getElementById('qLbl');
const elAlignBar=document.getElementById('alignBar');
const elAlignTxt=document.getElementById('alignTxt');
const elBandHint=document.getElementById('bandHint');
const elLog=document.getElementById('log');
const elToast=document.getElementById('toast');
const elDialogue=document.getElementById('dialogueBox');

function log(msg){
  const p=document.createElement('p');
  p.innerHTML=msg;
  elLog.appendChild(p);
  elLog.scrollTop=elLog.scrollHeight;
  while(elLog.children.length>140) elLog.removeChild(elLog.firstChild);
}
function toast(text,t=2000){
  elToast.textContent=text;
  elToast.style.opacity=1;
  clearTimeout(toast._t);
  toast._t=setTimeout(()=>elToast.style.opacity=0,t);
}

/* ---------- Procedural text (dialogue, vignettes, debriefs) ---------- */
const PROC={
  object:["dial","signal","valve","shadow","tape","grid","tower","loop","coil","archive"],
  place:["the corridor","the tower","the ruins","the stairwell","the listening post","the floodplain","the service tunnel"],
  concept:["memory","silence","ghosts","numbers","weather","maps","echoes","clearance"],
  verb:["sleeps","fractures","glows","evaporates","loops","rusts","whispers"],
  mood:["like rain on tin","like a stairwell dream","like a map that forgets itself","like a corridor turned inside out"],
  aside:["Do you remember when we stopped being real?","Who archived the archivists?","Some ghosts are just protocols.","The city was replaced by its spectrum."]
};
function procFill(tpl){
  return tpl.replace(/\{(\w+)\}/g,(_,k)=>{
    const bank=PROC[k];
    return bank ? bank[Math.floor(state.rng()*bank.length)] : '{'+k+'}';
  });
}
function procVignette(){
  const v=[
    "Aurora hum threads {place}.",
    "Tiles breathe in ultraviolet.",
    "Numbers leak from the drains.",
    "Your shadow glitches one square late.",
    "A dial tone puddles under the floor.",
    "The map folds into {place}."
  ];
  return procFill( v[Math.floor(state.rng()*v.length)] );
}
function procDialog(){
  const d=[
    "The {object} {verb} in {place}.",
    "{object} is filed under {concept}.",
    "The signal is {mood}.",
    choose(state.rng, PROC.aside)
  ];
  return procFill( d[Math.floor(state.rng()*d.length)] );
}
function procDebrief(){
  const core  = procFill("Archive complete. Coordinates resolved in {place}.");
  const color = procFill("Carrier folds through {concept}; signal is {mood}.");
  const aside = procFill( choose(state.rng, PROC.aside) );
  return core+"\n\n"+color+"\n\n"+aside;
}
function showDialogue(html){
  elDialogue.style.display='block';
  elDialogue.innerHTML=html;
  clearTimeout(showDialogue._t);
  showDialogue._t=setTimeout(()=>{ elDialogue.style.display='none'; }, 5000);
}

/* ---------- Bands & helpers ---------- */
function freqToBand(f){
  const bands=[
    {n:'VLF',r:[0.00,0.08]},{n:'LF',r:[0.08,0.18]},{n:'MF',r:[0.18,0.32]},
    {n:'HF',r:[0.32,0.58]},{n:'VHF',r:[0.58,0.78]},{n:'UHF',r:[0.78,0.92]},{n:'SHF',r:[0.92,1.00]}
  ];
  for(const b of bands){ if(f>=b.r[0] && f<b.r[1]) return b; }
  return bands[bands.length-1];
}
function gridToScreen(x,y){
  return { sx:GRID.MARGIN_X+(x-state.camera.x)*GRID.TILE,
           sy:GRID.MARGIN_Y+(y-state.camera.y)*GRID.TILE };
}
function updateCamera(){
  state.camera.x = state.player.x - Math.floor(GRID.W/2);
  state.camera.y = state.player.y - Math.floor(GRID.H/2);
}

/* ---------- Alignment (WORLD-SPACE) ---------- */
function spectralAlignment(){
  if(!state.transmitter) return 0;
  const t=state.transmitter;

  // antenna in world tile coords
  const ax=(state.antenna.x - GRID.MARGIN_X)/GRID.TILE + state.camera.x + 0.5;
  const ay=(state.antenna.y - GRID.MARGIN_Y)/GRID.TILE + state.camera.y + 0.5;

  const tx=t.x+0.5, ty=t.y+0.5;
  const dx=(ax-tx)*GRID.TILE, dy=(ay-ty)*GRID.TILE;
  const dist=Math.hypot(dx,dy);
  const distScore=Math.exp(-(dist*dist)/(2*t.sigma*t.sigma));

  const f=state.spectral.freq;
  const fErr = Math.min(Math.abs(f - t.freq), 1 - Math.abs(f - t.freq));
  const tol = t.tol * (state.spectral.q>0 ? (1/state.spectral.q) : 1);
  const buff = state.spectral.buffQ>0 ? 1.35 : 1.0;
  const freqScore=Math.exp(-(fErr*fErr)/(2*(tol*buff)*(tol*buff)));

  return clamp(distScore*freqScore,0,1);
}

/* ---------- Transmitter spawn (weighted distance) ---------- */
function spawnTransmitter(){
  let baseTol, tolMin;
  if(DIFFICULTY.mode==='Guided'){ baseTol=0.12; tolMin=0.035; }
  else if(DIFFICULTY.mode==='Hardcore'){ baseTol=0.07; tolMin=0.02; }
  else { baseTol=0.10; tolMin=0.025; }
  const tol = Math.max(tolMin, baseTol - (state.mission-1)*0.015);

  const rRoll=state.rng(); let minR,maxR;
  if(DIFFICULTY.mode==='Guided'){
    if(rRoll<0.60){ minR=4; maxR=10; } else if(rRoll<0.90){ minR=12; maxR=20; } else { minR=22; maxR=30; }
  } else if(DIFFICULTY.mode==='Hardcore'){
    if(rRoll<0.15){ minR=6; maxR=10; } else if(rRoll<0.60){ minR=14; maxR=24; } else { minR=26; maxR=40; }
  } else {
    if(rRoll<0.35){ minR=5; maxR=10; } else if(rRoll<0.80){ minR=12; maxR=22; } else { minR=24; maxR=36; }
  }

  const r = minR + Math.floor(state.rng()*(maxR-minR+1));
  const ang = state.rng()*Math.PI*2;
  const dx = Math.round(Math.cos(ang)*r);
  const dy = Math.round(Math.sin(ang)*r);
  const pos = { x:state.player.x + dx, y:state.player.y + dy };

  const sigma = Math.max(70, 120 - (state.mission-1)*15); // pixels
  const freq = state.rng();
  const band = freqToBand(freq);

  state.transmitter = {
    x:pos.x, y:pos.y, freq:freq, tol:tol, sigma:sigma, band:band,
    drift:(state.mission>=3 ? (state.rng()*0.0008 + 0.0003) : 0)
  };

  const p = gridToScreen(state.player.x, state.player.y);
  state.antenna.x = p.sx + GRID.TILE/2;
  state.antenna.y = p.sy + GRID.TILE/2;

  elBandHint.textContent = band.n + " (" + band.r[0].toFixed(2) + "–" + band.r[1].toFixed(2) + ")";
}

/* ---------- Drawing ---------- */
function drawExplore(){
  const w=canvas.width,h=canvas.height;
  ctx.fillStyle='#090c12'; ctx.fillRect(0,0,w,h);

  for(let y=0;y<GRID.H;y++){
    for(let x=0;x<GRID.W;x++){
      const wx=state.camera.x+x, wy=state.camera.y+y;
      const p=gridToScreen(wx,wy);
      ctx.fillStyle = ((wx+wy)&1) ? '#0c1320' : '#0a0f1a';
      ctx.fillRect(p.sx,p.sy,GRID.TILE,GRID.TILE);
      ctx.strokeStyle='rgba(50,80,120,.2)'; ctx.strokeRect(p.sx+0.5,p.sy+0.5,GRID.TILE-1,GRID.TILE-1);
    }
  }

  const P=gridToScreen(state.player.x,state.player.y);
  ctx.fillStyle='#79ffe1'; ctx.font='bold 20px ui-monospace, monospace';
  ctx.fillText('@', P.sx+10, P.sy+22);
}

function drawSpectral(dt){
  const w=canvas.width,h=canvas.height;
  ctx.clearRect(0,0,w,h);

  state.spectral.heatPhase += dt*0.25;
  const ph=state.spectral.heatPhase;

  // Psychedelic heatmap (soft contrast so it doesn't give away direction too much)
  for(let y=0;y<GRID.H;y++){
    for(let x=0;x<GRID.W;x++){
      const wx=state.camera.x+x, wy=state.camera.y+y;
      const p=gridToScreen(wx,wy);
      const n = Math.sin((wx*0.20+ph)*3) + Math.sin((wy*0.20+ph*1.2)*2) + Math.sin(((wx-wy)*0.13+ph*0.8));
      const t = 0.5 + 0.14 * Math.tanh(n * 0.6);
      const hue = (t*300 + ph*90)%360;
      ctx.fillStyle = "hsl("+hue+" 75% "+Math.floor(18+40*t)+"%)";
      ctx.fillRect(p.sx,p.sy,GRID.TILE,GRID.TILE);
    }
  }

  // Alignment + HUD
  const a = spectralAlignment();
  state.spectral.align = a;
  elAlignBar.style.width = Math.round(a*100) + "%";
  elAlignTxt.textContent = Math.round(a*100) + "%";

  // Gate ring visibility by rough distance & tuning
  let showRings=false;
  if(state.transmitter){
    const t=state.transmitter;
    const f=state.spectral.freq;
    const fErr=Math.min(Math.abs(f - t.freq), 1 - Math.abs(f - t.freq));
    const tolRough = t.tol * (DIFFICULTY.mode==='Guided' ? 2.2 : DIFFICULTY.mode==='Hardcore' ? 1.4 : 1.8);

    (function(){
      const ax=(state.antenna.x - GRID.MARGIN_X)/GRID.TILE + state.camera.x + 0.5;
      const ay=(state.antenna.y - GRID.MARGIN_Y)/GRID.TILE + state.camera.y + 0.5;
      const tx=t.x+0.5, ty=t.y+0.5;
      const dx=(ax-tx)*GRID.TILE, dy=(ay-ty)*GRID.TILE;
      const dist=Math.hypot(dx,dy);
      const distScore=Math.exp(-(dist*dist)/(2*t.sigma*t.sigma));
      const distGate = (DIFFICULTY.mode==='Hardcore') ? 0.22 : (DIFFICULTY.mode==='Guided' ? 0.12 : 0.18);
      showRings = (distScore > distGate) && (fErr < tolRough);
    })();
  }

  if(state.transmitter && showRings){
    const T=state.transmitter;
    const p=gridToScreen(T.x,T.y);
    const cx=p.sx+GRID.TILE/2, cy=p.sy+GRID.TILE/2;

    const vis = Math.max(0, (a - 0.35) / 0.65); // fade-in by alignment
    const alphaBase = vis*vis;

    for(let i=1;i<=6;i++){
      const r=(i/6)*Math.max(40, T.sigma*0.6);
      const alpha = 0.02 + alphaBase * (0.12 * (1 - i/6));
      ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2);
      ctx.strokeStyle = "rgba(230,250,255,"+alpha.toFixed(3)+")";
      ctx.lineWidth = 2; ctx.stroke();
    }
  }

  // Crosshair
  ctx.save(); ctx.translate(state.antenna.x, state.antenna.y);
  ctx.strokeStyle='rgba(255,255,255,.9)';
  ctx.beginPath(); ctx.moveTo(-10,0); ctx.lineTo(10,0); ctx.moveTo(0,-10); ctx.lineTo(0,10); ctx.stroke();
  ctx.restore();
}

/* ---------- Archive handler ---------- */
function tryArchive(){
  const a = spectralAlignment();
  if(a < 0.88){
    toast("Alignment too low");
    showDialogue("...the meter jitters; no lock.");
    return;
  }
  const text = procDebrief();
  log("<b>Debrief:</b> " + text.replace(/\n/g,"<br>"));
  showDialogue(text.replace(/\n/g,"<br>"));
  state.mission += 1;
  spawnTransmitter();
}

/* ---------- Input ---------- */
const keys=new Set();
window.addEventListener('keydown', (e)=>{
  if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)) e.preventDefault();
  keys.add(e.key);
  if(e.key===' '){ toggleMode(); }
  if(e.key==='Enter'){
    if(state.mode===MODE.SPECTRAL) tryArchive();
    else showDialogue(procDialog());
  }
  if(e.key==='['){
    state.spectral.freq = clamp(state.spectral.freq - 0.005, 0, 1);
    elFreq.value = Math.floor(state.spectral.freq*1000);
    elFreqLbl.textContent = state.spectral.freq.toFixed(3);
  }
  if(e.key===']'){
    state.spectral.freq = clamp(state.spectral.freq + 0.005, 0, 1);
    elFreq.value = Math.floor(state.spectral.freq*1000);
    elFreqLbl.textContent = state.spectral.freq.toFixed(3);
  }
  if(e.key==='-'){
    state.spectral.q = clamp(state.spectral.q - 0.1, 0.5, 6);
    elQL.value = Math.floor(state.spectral.q*60);
    elQLbl.textContent = state.spectral.q.toFixed(1);
  }
  if(e.key==='='){
    state.spectral.q = clamp(state.spectral.q + 0.1, 0.5, 6);
    elQL.value = Math.floor(state.spectral.q*60);
    elQLbl.textContent = state.spectral.q.toFixed(1);
  }
});
window.addEventListener('keyup', (e)=> keys.delete(e.key));
document.getElementById('badgeToggle').addEventListener('click', ()=> toggleMode());
elFreq.addEventListener('input', ()=>{ state.spectral.freq = elFreq.value/1000; elFreqLbl.textContent = state.spectral.freq.toFixed(3); });
elQL.addEventListener('input',  ()=>{ state.spectral.q    = (elQL.value/60);  elQLbl.textContent  = state.spectral.q.toFixed(1); });

function toggleMode(){
  state.mode = (state.mode===MODE.EXPLORE ? MODE.SPECTRAL : MODE.EXPLORE);
  elModeLabel.textContent = (state.mode===MODE.EXPLORE ? 'Explore' : 'Spectral');
  toast(state.mode==='Spectral' ? 'Spectral — scan & tune' : 'Explore — move on the grid');
}

/* ---------- Main loop ---------- */
let lastT=performance.now();
let moveCooldown=0; const MOVE_DELAY=120; // ms per step
function frame(t){
  const dt = Math.min(0.05,(t-lastT)/1000); lastT=t;

  if(state.mode===MODE.EXPLORE){
    moveCooldown -= dt*1000;
    if(moveCooldown<=0){
      let dx=0, dy=0;
      if(keys.has('ArrowUp')||keys.has('w')||keys.has('W')) dy-=1;
      if(keys.has('ArrowDown')||keys.has('s')||keys.has('S')) dy+=1;
      if(keys.has('ArrowLeft')||keys.has('a')||keys.has('A')) dx-=1;
      if(keys.has('ArrowRight')||keys.has('d')||keys.has('D')) dx+=1;
      dx=Math.sign(dx); dy=Math.sign(dy);
      if(dx||dy){
        state.player.x+=dx; state.player.y+=dy;
        updateCamera();
        moveCooldown=MOVE_DELAY;
        if(state.rng()<0.30){ showDialogue(procVignette()); }
      }
    }
    drawExplore();
  } else {
    const speed=220*dt; // px/s for crosshair
    if(keys.has('ArrowUp')||keys.has('w')||keys.has('W')) state.antenna.y -= speed;
    if(keys.has('ArrowDown')||keys.has('s')||keys.has('S')) state.antenna.y += speed;
    if(keys.has('ArrowLeft')||keys.has('a')||keys.has('A')) state.antenna.x -= speed;
    if(keys.has('ArrowRight')||keys.has('d')||keys.has('D')) state.antenna.x += speed;

    if(state.transmitter && state.transmitter.drift){
      state.transmitter.freq = (state.transmitter.freq + state.transmitter.drift*dt) % 1;
      const b=freqToBand(state.transmitter.freq);
      state.transmitter.band=b;
      elBandHint.textContent = b.n + " (" + b.r[0].toFixed(2) + "–" + b.r[1].toFixed(2) + ")";
    }
    drawSpectral(dt);
  }

  requestAnimationFrame(frame);
}

/* ---------- Boot ---------- */
function boot(){
  updateCamera();
  spawnTransmitter();
  const p=gridToScreen(state.player.x,state.player.y);
  state.antenna.x=p.sx+GRID.TILE/2; state.antenna.y=p.sy+GRID.TILE/2;
  elFreqLbl.textContent=state.spectral.freq.toFixed(3);
  elQLbl.textContent=state.spectral.q.toFixed(1);
  log("<b>Welcome.</b> " + procDialog());
  requestAnimationFrame(frame);
}
boot();
</script>
</body>
</html>


