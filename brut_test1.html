<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Asymmetric Modernism City — HUD + Heatmap + Solid Controls (Fixed UI)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { margin:0; height:100%; background:#0a0a0a; color:#eaeaea; font-family:system-ui, sans-serif; }

    /* Canvas gets a grab cursor for orbiting */
    #canvas { display:block; width:100%; height:100%; outline:none; cursor: grab; }
    #canvas.dragging { cursor: grabbing; }

    /* ✅ UI/HUD/tooltip accept pointer events so buttons are clickable */
    #ui, #hud, #tooltip { pointer-events: auto; }

    #ui {
      position: fixed; top: 12px; left: 12px; z-index: 20;
      background: rgba(10,10,10,0.7); backdrop-filter: blur(6px);
      border: 1px solid #333; padding: 10px 12px; border-radius: 12px; max-width: 380px
    }
    #ui h1 { margin: 0 0 8px 0; font-size: 14px; letter-spacing: .06em; text-transform: uppercase; color:#b6f0ff }
    #ui .small { font-size: 12px; line-height: 1.4; color:#cbd5e1 }
    #ui kbd { background:#1c1c1c; border:1px solid #333; border-bottom-color:#222; padding:1px 6px; border-radius:6px; font-size:11px }
    .chip { display:inline-block; padding:2px 8px; border:1px solid #3a3a3a; border-radius:999px; margin-right:6px; margin-bottom:4px; font-size:11px; color:#c3f6d4 }

    #hud {
      position: fixed; right: 12px; top: 12px; z-index: 20;
      background: rgba(10,10,14,0.75); border:1px solid #2e3440; border-radius:12px; padding:10px 12px; min-width: 260px;
      font-size:12px; line-height:1.35;
    }
    #hud h2 { margin:0 0 6px 0; font-size:12px; letter-spacing:.08em; text-transform:uppercase; color:#c0eaff }
    #hud .row { display:flex; justify-content:space-between; margin:2px 0 }
    #legend { margin-top:6px; display:flex; align-items:center; gap:8px }
    #grad { width:120px; height:8px; background: linear-gradient(90deg, #62e077 0%, #ffe066 50%, #ff5b5b 100%); border-radius:999px; border:1px solid #2a2a2a }

    #tooltip {
      position: fixed; pointer-events: none; z-index: 30;
      background: rgba(15,20,22,0.9); border:1px solid #2e3440; border-radius:8px; padding:6px 8px; font-size:12px; display:none;
      box-shadow: 0 8px 20px rgba(0,0,0,0.35);
    }
  </style>
</head>
<body>
<div id="ui">
  <h1>Asymmetric Modernism — Generative City</h1>
  <div class="small">
    <div class="chip">Broken symmetry</div>
    <div class="chip">Circulation as care</div>
    <div class="chip">Variable modulor</div>
    <div class="chip">Assemblage over purity</div>
    <p><kbd>R</kbd> regenerate · <kbd>P</kbd> pause “settling” · <kbd>G</kbd> guidance · <kbd>H</kbd> HUD</p>
    <label style="display:block;margin-top:6px">Seed:
      <input id="seedInput" type="text" value="asym-001" style="width:160px;background:#0f0f0f;border:1px solid #333;color:#eaeaea;border-radius:6px;padding:4px 6px">
      <button id="regenBtn" style="margin-left:6px;background:#101010;color:#eaeaea;border:1px solid #333;border-radius:8px;padding:4px 8px;cursor:pointer">Regenerate</button>
    </label>
  </div>
</div>

<div id="hud">
  <h2>Circulation HUD</h2>
  <div class="row"><span>Total ramp segments</span><span id="hudSegs">–</span></div>
  <div class="row"><span>Compliant (≤ limit)</span><span id="hudOk">–</span></div>
  <div class="row"><span>Max slope (segment)</span><span id="hudMax">–</span></div>
  <div class="row"><span>Avg landing spacing</span><span id="hudAvg">–</span></div>
  <div class="row"><span>Spacing spread (σ)</span><span id="hudStd">–</span></div>
  <div id="legend">
    <div id="grad" title="Slope heatmap: green → gentle, yellow → at limit, red → exceeds limit"></div>
    <div style="font-size:11px;color:#a8b3bd">Heatmap vs slope limit</div>
  </div>
</div>
<div id="tooltip"></div>

<!-- tabindex makes sure wheel zoom works even after clicking UI -->
<canvas id="canvas" tabindex="0"></canvas>

<!-- Three.js + controls (version pins THREE.OrbitControls) -->
<script src="https://unpkg.com/three@0.138.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.138.0/examples/js/controls/OrbitControls.js"></script>

<script>
/* ======================= utilities ======================= */
function mulberry32(a){return function(){let t=a+=0x6D2B79F5;t=Math.imul(t^(t>>>15),t|1);t^=t+Math.imul(t^(t>>>7),t|61);return((t^(t>>>14))>>>0)/4294967296;}}
function strToSeed(str){let h=2166136261>>>0;for(let i=0;i<str.length;i++){h^=str.charCodeAt(i);h=Math.imul(h,16777619);}return h>>>0;}
function valueNoise2D(x,y,rand2){const xi=Math.floor(x),yi=Math.floor(y);function h(sx,sy){const key=(xi+sx)*374761393+(yi+sy)*668265263;const r=mulberry32((key^rand2())>>>0)();return r;}const xf=x-xi,yf=y-yi;const v00=h(0,0),v10=h(1,0),v01=h(0,1),v11=h(1,1);const u=xf*xf*(3-2*xf),v=yf*yf*(3-2*yf);const a=v00*(1-u)+v10*u,b=v01*(1-u)+v11*u;return a*(1-v)+b*v;}
function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }
function lerp(a,b,t){ return a+(b-a)*t; }
function slopeToColor(s, limit){
  const r = s/limit; let R,G,B;
  if (r <= 1){ const g0=[0.0,0.72,0.35], g1=[1.0,0.88,0.40];
    R=lerp(g0[0],g1[0],r); G=lerp(g0[1],g1[1],r); B=lerp(g0[2],g1[2],r);
  } else { const t=clamp(r-1,0,1), y=[1.0,0.88,0.40], red=[1.0,0.36,0.36];
    R=lerp(y[0],red[0],t); G=lerp(y[1],red[1],t); B=lerp(y[2],red[2],t);
  }
  return ( (Math.round(R*255)<<16) | (Math.round(G*255)<<8) | Math.round(B*255) );
}

/* ======================= scene ======================= */
const canvas = document.getElementById('canvas');
const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:false });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.shadowMap.enabled = true;

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x07090a);
const camera = new THREE.PerspectiveCamera(55, window.innerWidth/window.innerHeight, 0.1, 2000);
camera.position.set(-120, 140, 180);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.06;
controls.rotateSpeed = 0.9;
controls.zoomSpeed = 1.0;
controls.panSpeed = 0.8;
controls.minDistance = 20;
controls.maxDistance = 600;
controls.maxPolarAngle = Math.PI * 0.495; // keep horizon visible
controls.touches = { ONE: THREE.TOUCH.ROTATE, TWO: THREE.TOUCH.DOLLY_PAN };
controls.addEventListener('start', ()=> canvas.classList.add('dragging'));
controls.addEventListener('end',   ()=> canvas.classList.remove('dragging'));
canvas.addEventListener('mousedown', ()=> canvas.focus());
canvas.addEventListener('keydown',   ()=> canvas.focus());

const hemi = new THREE.HemisphereLight(0xbcdfff, 0x202020, 0.8);
scene.add(hemi);
const dir = new THREE.DirectionalLight(0xffffff, 0.9);
dir.position.set(120, 200, 80);
dir.castShadow = true;
scene.add(dir);

/* ======================= params ======================= */
let rng, rand2;
const params = {
  gridCount: 17,
  blockSize: 20,
  streetProb: 0.22,
  undulationAmp: 8,
  undulationScale: 0.08,
  assemblageJitter: 0.35,
  rampMaxSlope: 1/14,
  rampRestEvery: 18,
  variableModulorSteps: [0.9, 1.0, 1.2, 1.35],
  prostheticDensity: 0.55,
  guidanceVisible: true,
  hudVisible: true
};
let ground, cityGroup, guidanceGroup, settleAnim = true;

/* HUD elements */
const hudSegs = document.getElementById('hudSegs');
const hudOk   = document.getElementById('hudOk');
const hudMax  = document.getElementById('hudMax');
const hudAvg  = document.getElementById('hudAvg');
const hudStd  = document.getElementById('hudStd');
const hudBox  = document.getElementById('hud');
const uiBox   = document.getElementById('ui');
const tooltip = document.getElementById('tooltip');

/* ✅ Pause controls while pointer is over UI/HUD; re-enable on leave */
['pointerenter','mouseenter','touchstart'].forEach(ev=>{
  uiBox.addEventListener(ev,  ()=> controls.enabled = false, {passive:true});
  hudBox.addEventListener(ev, ()=> controls.enabled = false, {passive:true});
});
['pointerleave','mouseleave','touchend','touchcancel'].forEach(ev=>{
  uiBox.addEventListener(ev,  ()=> controls.enabled = true, {passive:true});
  hudBox.addEventListener(ev, ()=> controls.enabled = true, {passive:true});
});

/* picking */
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

/* ramp metadata */
let rampSegments = [];
let landingSpacings = [];

/* ======================= generation ======================= */
function clearScene(){
  [ground, cityGroup, guidanceGroup].forEach(g=>{
    if (!g) return;
    scene.remove(g);
    g.traverse?.(o=>{
      if (o.geometry) o.geometry.dispose();
      if (o.material){ if (Array.isArray(o.material)) o.material.forEach(m=>m.dispose()); else o.material.dispose(); }
    });
  });
  ground = new THREE.Group();
  cityGroup = new THREE.Group();
  guidanceGroup = new THREE.Group();
  scene.add(ground, cityGroup, guidanceGroup);
  rampSegments = [];
  landingSpacings = [];
}

function generate(seedStr="asym-001"){
  clearScene();
  rng = mulberry32(strToSeed(seedStr));
  rand2 = mulberry32((strToSeed(seedStr)^0x9e3779b9)>>>0);

  // ground
  const citySize = params.gridCount * params.blockSize;
  const res = params.gridCount * 3 + 1;
  const geo = new THREE.PlaneGeometry(citySize, citySize, res, res);
  geo.rotateX(-Math.PI/2);
  const pos = geo.attributes.position;
  for (let i=0;i<pos.count;i++){
    const x=pos.getX(i), z=pos.getZ(i);
    const nx = x*params.undulationScale*0.7+100;
    const nz = z*params.undulationScale*0.63+200;
    const h = (valueNoise2D(nx, nz, rand2)-0.5)*2*params.undulationAmp
            + (valueNoise2D(nx*0.4+42, nz*0.4+7, rand2)-0.5)*2*params.undulationAmp*0.5;
    pos.setY(i,h);
  }
  geo.computeVertexNormals();
  const groundMat = new THREE.MeshStandardMaterial({ color:0x0f1416, roughness:0.95, metalness:0.02 });
  const groundMesh = new THREE.Mesh(geo, groundMat);
  groundMesh.receiveShadow = true;
  ground.add(groundMesh);

  // parcels
  const half = citySize/2;
  const parcels=[];
  for (let gx=0; gx<params.gridCount; gx++){
    for (let gz=0; gz<params.gridCount; gz++){
      const cx = -half + (gx+0.5)*params.blockSize;
      const cz = -half + (gz+0.5)*params.blockSize;
      const jx = (rng()-0.5)*params.blockSize*0.7;
      const jz = (rng()-0.5)*params.blockSize*0.7;
      const x = cx + jx, z = cz + jz;
      const isVoid = rng() < params.streetProb;
      parcels.push({x,z,isVoid});
    }
  }

  function sampleHeightAt(x,z){
    const nx = x*params.undulationScale*0.7+100;
    const nz = z*params.undulationScale*0.63+200;
    const h = (valueNoise2D(nx, nz, rand2)-0.5)*2*params.undulationAmp
            + (valueNoise2D(nx*0.4+42, nz*0.4+7, rand2)-0.5)*2*params.undulationAmp*0.5;
    return h;
  }

  // materials
  const matConcrete = new THREE.MeshStandardMaterial({ color:0x2b353a, roughness:0.9, metalness:0.04 });
  const matPatch = new THREE.MeshStandardMaterial({ color:0x47565d, roughness:0.85, metalness:0.05 });
  const matRest = new THREE.MeshStandardMaterial({ color:0x6db691, roughness:0.7, metalness:0.1, emissive:0x183025, emissiveIntensity:0.2 });
  const matRail = new THREE.MeshStandardMaterial({ color:0xb3c7d6, roughness:0.6, metalness:0.7 });
  const matGuide = new THREE.MeshStandardMaterial({ color:0x9fe3ff, roughness:0.6, metalness:0.2, transparent:true, opacity: params.guidanceVisible ? 0.25 : 0.0 });

  const rampsToBuild=[]; const entrances=[];

  parcels.forEach(p=>{
    const baseY = sampleHeightAt(p.x, p.z);

    if (p.isVoid){
      // rest fields
      const w = params.blockSize*(0.9 + rng()*0.3);
      const d = params.blockSize*(0.9 + rng()*0.3);
      const plaza = new THREE.Mesh(new THREE.BoxGeometry(w, 0.6, d), matRest);
      plaza.position.set(p.x, baseY+0.3, p.z);
      plaza.receiveShadow = true;
      cityGroup.add(plaza);

      const benchCount = 2 + Math.floor(rng()*4);
      for (let i=0;i<benchCount;i++){
        const bx = p.x + (rng()-0.5)*w*0.8;
        const bz = p.z + (rng()-0.5)*d*0.8;
        const by = sampleHeightAt(bx, bz) + 0.45;
        const bench = new THREE.Mesh(new THREE.BoxGeometry(4, 0.6, 1.2), matRail);
        bench.position.set(bx, by, bz);
        bench.castShadow = true;
        bench.rotation.y = rng()*Math.PI;
        cityGroup.add(bench);
        if (params.guidanceVisible){
          const halo = new THREE.Mesh(new THREE.CylinderGeometry(1.6,1.6,0.05, 24), matGuide);
          halo.position.set(bx, by+0.05, bz);
          guidanceGroup.add(halo);
        }
      }

    } else {
      // assemblage building
      const step = params.variableModulorSteps[Math.floor(rng()*params.variableModulorSteps.length)];
      const footprint = params.blockSize * (0.6 + rng()*0.35) * step;
      const heightLevels = 2 + Math.floor(rng()*6);
      const core = new THREE.Group();

      // uneven stilts
      const stiltCount = 3 + Math.floor(rng()*4);
      for (let i=0;i<stiltCount;i++){
        const sx = (rng()-0.5)*footprint*0.8;
        const sz = (rng()-0.5)*footprint*0.8;
        const groundY = sampleHeightAt(p.x+sx, p.z+sz);
        const topY = baseY + 2 + rng()*3;
        const h = Math.max(0.5, topY - groundY);
        const stilt = new THREE.Mesh(new THREE.CylinderGeometry(0.6,0.6,h,12), matRail);
        stilt.position.set(p.x+sx, groundY + h/2, p.z+sz);
        stilt.castShadow = true;
        cityGroup.add(stilt);
      }

      let levelY = baseY + 2.5 + rng()*1.5;
      let prevPlatform;
      for (let lv=0; lv<heightLevels; lv++){
        const w = footprint*(0.9 - lv*0.08)*(0.85 + rng()*0.25);
        const d = footprint*(0.9 - lv*0.07)*(0.85 + rng()*0.25);
        const h = 3 + rng()*2.5;

        const ox = (rng()-0.5)*w*params.assemblageJitter;
        const oz = (rng()-0.5)*d*params.assemblageJitter;
        const rot = (rng()-0.5)*0.2;

        const shell = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), (rng()<0.45? matPatch: matConcrete));
        shell.position.set(p.x+ox, levelY + h/2, p.z+oz);
        shell.rotation.y = rot;
        shell.castShadow = true;
        shell.receiveShadow = true;
        core.add(shell);

        if (rng() < 0.7){
          const cut = new THREE.Mesh(new THREE.BoxGeometry(w*0.45, h*0.6, d*0.3), matConcrete);
          cut.position.set(shell.position.x - w*0.275, shell.position.y + h*0.05, shell.position.z + (rng()<0.5? -d*0.3 : d*0.3));
          cut.scale.set(1, rng()*0.8+0.6, 1);
          cut.rotation.y = shell.rotation.y + (rng()-0.5)*0.2;
          core.add(cut);
        }

        if (rng() < 0.6){
          const bw = 2 + rng()*3, bd = 1 + rng()*2, bt = 0.25;
          const bal = new THREE.Mesh(new THREE.BoxGeometry(bw, bt, bd), matRail);
          const side = (rng()<0.5? -1:1);
          bal.position.set(shell.position.x + side*(w*0.5 + bw*0.5 - 0.4), shell.position.y + h*0.15*(rng()<0.5? -1:1), shell.position.z + (rng()-0.5)*d*0.6);
          bal.rotation.y = shell.rotation.y + (rng()-0.5)*0.5;
          bal.castShadow = true;
          core.add(bal);
        }

        if (prevPlatform){
          if (rng() < params.prostheticDensity){
            const start = prevPlatform.clone();
            const end = new THREE.Vector3(shell.position.x, shell.position.y - h*0.45, shell.position.z);
            rampsToBuild.push({ a:start, b:end, restEvery: params.rampRestEvery });
          }
        }
        prevPlatform = new THREE.Vector3(shell.position.x + (rng()-0.5)*w*0.2, shell.position.y + h*0.5, shell.position.z + (rng()-0.5)*d*0.2);
        levelY += h*0.78 + 0.3 + rng()*0.6;
      }

      core.position.y += (rng()-0.5)*0.3;
      cityGroup.add(core);

      const ent = new THREE.Vector3(p.x + (rng()-0.5)*footprint*0.4, baseY + 0.2 + rng()*0.4, p.z + (rng()-0.5)*footprint*0.4);
      entrances.push(ent);
      const toGround = new THREE.Vector3(p.x + (rng()-0.5)*params.blockSize*0.4, sampleHeightAt(p.x, p.z), p.z + (rng()-0.5)*params.blockSize*0.4);
      rampsToBuild.push({ a: ent, b: toGround, restEvery: params.rampRestEvery });
    }
  });

  // build ramps
  rampsToBuild.forEach(r=> buildCareRamp(r.a, r.b, r.restEvery, matRail, matGuide));

  // roof bridges
  for (let i=0;i<Math.floor(entrances.length*0.4);i++){
    const aIdx = Math.floor(rng()*entrances.length);
    const bIdx = Math.floor(rng()*entrances.length);
    if (aIdx===bIdx) continue;
    const a = entrances[aIdx].clone(); a.y += 8 + rng()*6;
    const b = entrances[bIdx].clone(); b.y += 6 + rng()*8;
    if (a.distanceTo(b) < params.blockSize*2.7 && rng()<0.7){
      buildCareRamp(a, b, params.rampRestEvery*0.7, matRail, matGuide, true);
    }
  }

  updateHUD();
}

function buildCareRamp(a,b,restEvery,mat,guideMat,isBridge=false){
  const dir = new THREE.Vector3().subVectors(b,a);
  const horiz = new THREE.Vector3(dir.x,0,dir.z);
  const run = Math.max(0.1, horiz.length());
  const rise = dir.y;
  const maxRiseForRun = run * params.rampMaxSlope;
  let neededSegments = 1;

  if (Math.abs(rise) > maxRiseForRun){
    neededSegments = Math.ceil(Math.abs(rise) / (params.rampMaxSlope * (restEvery*0.75)));
  } else {
    neededSegments = Math.max(neededSegments, Math.ceil(run / restEvery));
  }

  const points=[a.clone()];
  for (let i=1;i<=neededSegments;i++){
    const t=i/neededSegments;
    const p=new THREE.Vector3().lerpVectors(a,b,t);
    const prev=points[i-1];
    const targetRun = p.clone().setY(prev.y).distanceTo(prev.clone().setY(prev.y));
    const maxLocalRise = targetRun * params.rampMaxSlope;
    const desiredRise = p.y - prev.y;
    if (Math.abs(desiredRise)>maxLocalRise){
      p.y = prev.y + Math.sign(desiredRise)*maxLocalRise;
    }
    points.push(p);
  }

  let accumRun = 0;
  const restIndices = new Set();
  for (let i=1;i<points.length-1;i++) restIndices.add(i);

  for (let i=0;i<points.length-1;i++){
    const p0=points[i], p1=points[i+1];
    const seg = new THREE.Vector3().subVectors(p1,p0);
    const horizLen = new THREE.Vector3(seg.x,0,seg.z).length();
    const slope = Math.abs((p1.y-p0.y)/(horizLen||1e-6));
    accumRun += horizLen;
    const mid = new THREE.Vector3().addVectors(p0,p1).multiplyScalar(0.5);

    const thickness=0.15;
    const width=isBridge?1.8:2.4;
    const geom=new THREE.BoxGeometry(width, thickness, seg.length());
    const heat = slopeToColor(slope, params.rampMaxSlope);
    const matSeg = mat.clone(); matSeg.color.setHex(heat);
    const mesh=new THREE.Mesh(geom, matSeg);
    mesh.position.copy(mid);
    const yaw=Math.atan2(seg.x, seg.z);
    mesh.rotation.y=yaw;
    mesh.rotation.x=Math.atan2(p1.y-p0.y, horizLen);
    mesh.castShadow=true;
    mesh.userData={ type:'rampSeg', slope, run:horizLen, toNextRestRun:0 };
    cityGroup.add(mesh);

    // rails
    const railGeom=new THREE.BoxGeometry(0.08, 0.7, seg.length()*0.98);
    const left=new THREE.Mesh(railGeom, matSeg.clone()), right=new THREE.Mesh(railGeom, matSeg.clone());
    const offset=(width/2 - 0.15);
    left.position.copy(mid); right.position.copy(mid);
    left.rotation.y=right.rotation.y=mesh.rotation.y;
    left.rotation.x=right.rotation.x=mesh.rotation.x;
    const nx=Math.sin(yaw), nz=Math.cos(yaw);
    left.position.x += nx*offset; left.position.z += nz*offset; left.position.y += 0.45;
    right.position.x -= nx*offset; right.position.z -= nz*offset; right.position.y += 0.45;
    left.userData={type:'rampSeg', slope, run:horizLen, toNextRestRun:0};
    right.userData={type:'rampSeg', slope, run:horizLen, toNextRestRun:0};
    cityGroup.add(left, right);

    rampSegments.push({mesh, slope, run:horizLen, toNextRestRun:0});
    rampSegments.push({mesh:left, slope, run:horizLen, toNextRestRun:0});
    rampSegments.push({mesh:right, slope, run:horizLen, toNextRestRun:0});

    // landing at p1 (except last)
    if (i < points.length-2){
      const land=new THREE.Mesh(new THREE.BoxGeometry(width*1.25, thickness, width*1.6), mat.clone());
      land.material.color.copy(new THREE.Color(0x9fb6ff));
      land.position.copy(p1.clone()); land.position.y += 0.02;
      land.castShadow=true; land.userData={type:'landing'};
      cityGroup.add(land);

      if (restIndices.has(i+1)){
        landingSpacings.push(accumRun);
        // backfill toNextRestRun on recent segments
        let backrun = accumRun;
        for (let j = rampSegments.length-1; j>=0; j--){
          const rs = rampSegments[j];
          if (rs.mesh.userData.type !== 'rampSeg') continue;
          if (rs.toNextRestRun>0) break;
          rs.toNextRestRun = backrun;
          rs.mesh.userData.toNextRestRun = backrun;
          backrun -= rs.run;
          if (backrun <= 0) break;
        }
        accumRun = 0;
      }

      if (params.guidanceVisible){
        const halo=new THREE.Mesh(new THREE.CylinderGeometry(width*0.55, width*0.55, 0.05, 24), guideMat);
        halo.position.set(land.position.x, land.position.y+0.08, land.position.z);
        guidanceGroup.add(halo);
      }
    }
  }
}

/* ======================= HUD + hover ======================= */
function updateHUD(){
  const segs = rampSegments.filter(r=>r.mesh.userData.type==='rampSeg');
  const total = segs.length;
  const ok = segs.filter(s=> s.slope <= params.rampMaxSlope).length;
  const maxSlope = segs.reduce((m,s)=> Math.max(m,s.slope), 0);
  const avg = landingSpacings.length ? (landingSpacings.reduce((a,b)=>a+b,0)/landingSpacings.length) : 0;
  const std = landingSpacings.length ? Math.sqrt(landingSpacings.reduce((a,b)=>a+(b-avg)**2,0)/landingSpacings.length) : 0;

  function fmt(n){ return isFinite(n) ? n.toFixed(2) : '–'; }
  hudSegs.textContent = total.toString();
  hudOk.textContent   = total ? `${Math.round(ok/total*100)}%` : '–';
  hudMax.textContent  = `${fmt(maxSlope)} (limit ${params.rampMaxSlope.toFixed(3)})`;
  hudAvg.textContent  = `${fmt(avg)} units`;
  hudStd.textContent  = `${fmt(std)} units`;
}
function setHUDVisible(v){ params.hudVisible = v; hudBox.style.display = v ? 'block' : 'none'; }

const raycasterObjList = ()=> rampSegments.map(r=>r.mesh);
function onMouseMove(e){
  const rect = renderer.domElement.getBoundingClientRect();
  const cx = e.clientX - rect.left, cy = e.clientY - rect.top;
  const mx =  (cx / rect.width) * 2 - 1;
  const my = -(cy / rect.height) * 2 + 1;
  mouse.x = mx; mouse.y = my;
  raycaster.setFromCamera(mouse, camera);
  const hits = raycaster.intersectObjects(raycasterObjList(), false);
  if (hits.length){
    const ud = hits[0].object.userData;
    if (ud && ud.type==='rampSeg'){
      tooltip.style.display='block';
      tooltip.style.left = (e.clientX + 12) + 'px';
      tooltip.style.top  = (e.clientY + 12) + 'px';
      tooltip.innerHTML = `
        <div style="color:#c0eaff; font-weight:600; margin-bottom:2px">Ramp segment</div>
        <div>Slope: <b>${(ud.slope||0).toFixed(3)}</b> (limit ${params.rampMaxSlope.toFixed(3)})</div>
        <div>Horizontal run: <b>${(ud.run||0).toFixed(2)}</b></div>
        <div>To next rest: <b>${ud.toNextRestRun && isFinite(ud.toNextRestRun) ? ud.toNextRestRun.toFixed(2) : '–'}</b></div>
      `;
      return;
    }
  }
  tooltip.style.display='none';
}

/* ======================= animation & input ======================= */
const clock = new THREE.Clock();
function animate(){
  requestAnimationFrame(animate);
  const t = clock.getElapsedTime();
  controls.update();
  if (settleAnim){
    cityGroup?.traverse(o=>{
      if (o.isMesh && o.geometry && o.geometry.parameters && o.geometry.parameters.width){
        o.rotation.z = (Math.sin((o.id*13.37 + t*0.3)))*0.003;
      }
    });
  }
  renderer.render(scene, camera);
}
animate();

function regen(){
  const seed=document.getElementById('seedInput').value.trim()||`asym-${Math.floor(Math.random()*9999)}`;
  generate(seed);
}
document.getElementById('regenBtn').addEventListener('click', regen);
window.addEventListener('resize', ()=>{
  camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
window.addEventListener('keydown', (e)=>{
  if (e.key==='r'||e.key==='R') regen();
  if (e.key==='p'||e.key==='P') settleAnim=!settleAnim;
  if (e.key==='g'||e.key==='G'){ params.guidanceVisible=!params.guidanceVisible; guidanceGroup.visible=params.guidanceVisible; }
  if (e.key==='h'||e.key==='H'){ setHUDVisible(!params.hudVisible); }
});
window.addEventListener('mousemove', onMouseMove);

// initial
setHUDVisible(true);
generate('asym-001');
</script>
</body>
</html>

