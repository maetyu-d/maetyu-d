<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Asymmetric Modernism City — Non-module build</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { margin:0; height:100%; background:#0a0a0a; color:#eaeaea; font-family:system-ui, sans-serif; }
    #ui {
      position: fixed; top: 12px; left: 12px; z-index: 10;
      background: rgba(10,10,10,0.7); backdrop-filter: blur(6px);
      border: 1px solid #333; padding: 10px 12px; border-radius: 12px; max-width: 360px
    }
    #ui h1 { margin: 0 0 8px 0; font-size: 14px; letter-spacing: .06em; text-transform: uppercase; color:#b6f0ff }
    #ui .small { font-size: 12px; line-height: 1.4; color:#cbd5e1 }
    #ui kbd { background:#1c1c1c; border:1px solid #333; border-bottom-color:#222; padding:1px 6px; border-radius:6px; font-size:11px }
    #canvas { display:block; width:100%; height:100% }
    .chip { display:inline-block; padding:2px 8px; border:1px solid #3a3a3a; border-radius:999px; margin-right:6px; margin-bottom:4px; font-size:11px; color:#c3f6d4 }
  </style>
</head>
<body>
<div id="ui">
  <h1>Asymmetric Modernism — Generative City</h1>
  <div class="small">
    <div class="chip">Broken symmetry</div>
    <div class="chip">Circulation as care</div>
    <div class="chip">Variable modulor</div>
    <div class="chip">Assemblage over purity</div>
    <p><kbd>R</kbd> regenerate · <kbd>P</kbd> pause “settling” · <kbd>G</kbd> guidance overlays</p>
    <label style="display:block;margin-top:6px">Seed:
      <input id="seedInput" type="text" value="asym-001" style="width:160px;background:#0f0f0f;border:1px solid #333;color:#eaeaea;border-radius:6px;padding:4px 6px">
      <button id="regenBtn" style="margin-left:6px;background:#101010;color:#eaeaea;border:1px solid #333;border-radius:8px;padding:4px 8px;cursor:pointer">Regenerate</button>
    </label>
  </div>
</div>
<canvas id="canvas"></canvas>

<!-- Global (non-module) Three.js + OrbitControls -->
<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.160.0/examples/js/controls/OrbitControls.js"></script>

<script>
/* ----------------------- seeded randomness + tiny noise ----------------------- */
function mulberry32(a){return function(){let t=a+=0x6D2B79F5;t=Math.imul(t^(t>>>15),t|1);t^=t+Math.imul(t^(t>>>7),t|61);return((t^(t>>>14))>>>0)/4294967296;}}
function strToSeed(str){let h=2166136261>>>0;for(let i=0;i<str.length;i++){h^=str.charCodeAt(i);h=Math.imul(h,16777619);}return h>>>0;}
function valueNoise2D(x,y,rand2){const xi=Math.floor(x),yi=Math.floor(y);function h(sx,sy){const key=(xi+sx)*374761393+(yi+sy)*668265263;const r=mulberry32((key^rand2())>>>0)();return r;}const xf=x-xi,yf=y-yi;const v00=h(0,0),v10=h(1,0),v01=h(0,1),v11=h(1,1);const u=xf*xf*(3-2*xf),v=yf*yf*(3-2*yf);const a=v00*(1-u)+v10*u,b=v01*(1-u)+v11*u;return a*(1-v)+b*v;}

/* ----------------------- scene basics ----------------------- */
const canvas = document.getElementById('canvas');
const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:false });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.shadowMap.enabled = true;

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x07090a);
const camera = new THREE.PerspectiveCamera(55, window.innerWidth/window.innerHeight, 0.1, 2000);
camera.position.set(-120, 140, 180);
const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

const hemi = new THREE.HemisphereLight(0xbcdfff, 0x202020, 0.8);
scene.add(hemi);
const dir = new THREE.DirectionalLight(0xffffff, 0.9);
dir.position.set(120, 200, 80);
dir.castShadow = true;
scene.add(dir);

/* ----------------------- city params (manifesto encoded) ----------------------- */
let rng, rand2;
const params = {
  gridCount: 17,
  blockSize: 20,
  streetProb: 0.22,
  undulationAmp: 8,
  undulationScale: 0.08,
  assemblageJitter: 0.35,
  rampMaxSlope: 1/14,
  rampRestEvery: 18,
  variableModulorSteps: [0.9, 1.0, 1.2, 1.35],
  prostheticDensity: 0.55,
  guidanceVisible: true
};

/* groups */
let ground, cityGroup, guidanceGroup, settleAnim = true;

/* ----------------------- generation ----------------------- */
function clearScene(){
  [ground, cityGroup, guidanceGroup].forEach(g=>{
    if (!g) return;
    scene.remove(g);
    g.traverse?.(o=>{
      if (o.geometry) o.geometry.dispose();
      if (o.material){ if (Array.isArray(o.material)) o.material.forEach(m=>m.dispose()); else o.material.dispose(); }
    });
  });
  ground = new THREE.Group();
  cityGroup = new THREE.Group();
  guidanceGroup = new THREE.Group();
  scene.add(ground, cityGroup, guidanceGroup);
}

function generate(seedStr="asym-001"){
  clearScene();
  rng = mulberry32(strToSeed(seedStr));
  rand2 = mulberry32((strToSeed(seedStr)^0x9e3779b9)>>>0);

  // 1) Uneven ground
  const citySize = params.gridCount * params.blockSize;
  const res = params.gridCount * 3 + 1;
  const geo = new THREE.PlaneGeometry(citySize, citySize, res, res);
  geo.rotateX(-Math.PI/2);
  const pos = geo.attributes.position;
  for (let i=0;i<pos.count;i++){
    const x=pos.getX(i), z=pos.getZ(i);
    const nx = x*params.undulationScale*0.7+100;
    const nz = z*params.undulationScale*0.63+200;
    const h = (valueNoise2D(nx, nz, rand2)-0.5)*2*params.undulationAmp
            + (valueNoise2D(nx*0.4+42, nz*0.4+7, rand2)-0.5)*2*params.undulationAmp*0.5;
    pos.setY(i,h);
  }
  geo.computeVertexNormals();
  const groundMat = new THREE.MeshStandardMaterial({ color:0x0f1416, roughness:0.95, metalness:0.02 });
  const groundMesh = new THREE.Mesh(geo, groundMat);
  groundMesh.receiveShadow = true;
  ground.add(groundMesh);

  // 2) Parcels (warped grid)
  const half = citySize/2;
  const parcels=[];
  for (let gx=0; gx<params.gridCount; gx++){
    for (let gz=0; gz<params.gridCount; gz++){
      const cx = -half + (gx+0.5)*params.blockSize;
      const cz = -half + (gz+0.5)*params.blockSize;
      const jx = (rng()-0.5)*params.blockSize*0.7;
      const jz = (rng()-0.5)*params.blockSize*0.7;
      const x = cx + jx, z = cz + jz;
      const isVoid = rng() < params.streetProb;
      parcels.push({x,z,isVoid});
    }
  }

  function sampleHeightAt(x,z){
    const nx = x*params.undulationScale*0.7+100;
    const nz = z*params.undulationScale*0.63+200;
    const h = (valueNoise2D(nx, nz, rand2)-0.5)*2*params.undulationAmp
            + (valueNoise2D(nx*0.4+42, nz*0.4+7, rand2)-0.5)*2*params.undulationAmp*0.5;
    return h;
  }

  // materials
  const matConcrete = new THREE.MeshStandardMaterial({ color:0x2b353a, roughness:0.9, metalness:0.04 });
  const matPatch = new THREE.MeshStandardMaterial({ color:0x47565d, roughness:0.85, metalness:0.05 });
  const matRest = new THREE.MeshStandardMaterial({ color:0x6db691, roughness:0.7, metalness:0.1, emissive:0x183025, emissiveIntensity:0.2 });
  const matRail = new THREE.MeshStandardMaterial({ color:0xb3c7d6, roughness:0.6, metalness:0.7 });
  const matGuide = new THREE.MeshStandardMaterial({ color:0x9fe3ff, roughness:0.6, metalness:0.2, transparent:true, opacity: params.guidanceVisible ? 0.25 : 0.0 });

  const rampsToBuild=[]; const entrances=[];

  parcels.forEach(p=>{
    const baseY = sampleHeightAt(p.x, p.z);

    if (p.isVoid){
      // plazas / rest fields
      const w = params.blockSize*(0.9 + rng()*0.3);
      const d = params.blockSize*(0.9 + rng()*0.3);
      const plaza = new THREE.Mesh(new THREE.BoxGeometry(w, 0.6, d), matRest);
      plaza.position.set(p.x, baseY+0.3, p.z);
      plaza.receiveShadow = true;
      cityGroup.add(plaza);

      const benchCount = 2 + Math.floor(rng()*4);
      for (let i=0;i<benchCount;i++){
        const bx = p.x + (rng()-0.5)*w*0.8;
        const bz = p.z + (rng()-0.5)*d*0.8;
        const by = sampleHeightAt(bx, bz) + 0.45;
        const bench = new THREE.Mesh(new THREE.BoxGeometry(4, 0.6, 1.2), matRail);
        bench.position.set(bx, by, bz);
        bench.castShadow = true;
        bench.rotation.y = rng()*Math.PI;
        cityGroup.add(bench);
        if (params.guidanceVisible){
          const halo = new THREE.Mesh(new THREE.CylinderGeometry(1.6,1.6,0.05, 24), matGuide);
          halo.position.set(bx, by+0.05, bz);
          guidanceGroup.add(halo);
        }
      }

    } else {
      // assemblage building
      const step = params.variableModulorSteps[Math.floor(rng()*params.variableModulorSteps.length)];
      const footprint = params.blockSize * (0.6 + rng()*0.35) * step;
      const heightLevels = 2 + Math.floor(rng()*6);
      const core = new THREE.Group();

      // uneven stilts
      const stiltCount = 3 + Math.floor(rng()*4);
      for (let i=0;i<stiltCount;i++){
        const sx = (rng()-0.5)*footprint*0.8;
        const sz = (rng()-0.5)*footprint*0.8;
        const groundY = sampleHeightAt(p.x+sx, p.z+sz);
        const topY = baseY + 2 + rng()*3;
        const h = Math.max(0.5, topY - groundY);
        const stilt = new THREE.Mesh(new THREE.CylinderGeometry(0.6,0.6,h,12), matRail);
        stilt.position.set(p.x+sx, groundY + h/2, p.z+sz);
        stilt.castShadow = true;
        cityGroup.add(stilt);
      }

      let levelY = baseY + 2.5 + rng()*1.5;
      let prevPlatform;
      for (let lv=0; lv<heightLevels; lv++){
        const w = footprint*(0.9 - lv*0.08)*(0.85 + rng()*0.25);
        const d = footprint*(0.9 - lv*0.07)*(0.85 + rng()*0.25);
        const h = 3 + rng()*2.5;

        const ox = (rng()-0.5)*w*params.assemblageJitter;
        const oz = (rng()-0.5)*d*params.assemblageJitter;
        const rot = (rng()-0.5)*0.2;

        const shell = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), (rng()<0.45? matPatch: matConcrete));
        shell.position.set(p.x+ox, levelY + h/2, p.z+oz);
        shell.rotation.y = rot;
        shell.castShadow = true;
        shell.receiveShadow = true;
        core.add(shell);

        if (rng() < 0.7){
          const cut = new THREE.Mesh(new THREE.BoxGeometry(w*0.45, h*0.6, d*0.3), matConcrete);
          cut.position.set(shell.position.x - w*0.275, shell.position.y + h*0.05, shell.position.z + (rng()<0.5? -d*0.3 : d*0.3));
          cut.scale.set(1, rng()*0.8+0.6, 1);
          cut.rotation.y = shell.rotation.y + (rng()-0.5)*0.2;
          core.add(cut);
        }

        if (rng() < 0.6){
          const bw = 2 + rng()*3, bd = 1 + rng()*2, bt = 0.25;
          const bal = new THREE.Mesh(new THREE.BoxGeometry(bw, bt, bd), matRail);
          const side = (rng()<0.5? -1:1);
          bal.position.set(shell.position.x + side*(w*0.5 + bw*0.5 - 0.4), shell.position.y + h*0.15*(rng()<0.5? -1:1), shell.position.z + (rng()-0.5)*d*0.6);
          bal.rotation.y = shell.rotation.y + (rng()-0.5)*0.5;
          bal.castShadow = true;
          core.add(bal);
        }

        if (prevPlatform){
          if (rng() < params.prostheticDensity){
            const start = prevPlatform.clone();
            const end = new THREE.Vector3(shell.position.x, shell.position.y - h*0.45, shell.position.z);
            rampsToBuild.push({ a:start, b:end, restEvery: params.rampRestEvery });
          }
        }
        prevPlatform = new THREE.Vector3(shell.position.x + (rng()-0.5)*w*0.2, shell.position.y + h*0.5, shell.position.z + (rng()-0.5)*d*0.2);
        levelY += h*0.78 + 0.3 + rng()*0.6;
      }

      core.position.y += (rng()-0.5)*0.3;
      cityGroup.add(core);

      const ent = new THREE.Vector3(p.x + (rng()-0.5)*footprint*0.4, baseY + 0.2 + rng()*0.4, p.z + (rng()-0.5)*footprint*0.4);
      entrances.push(ent);
      const toGround = new THREE.Vector3(p.x + (rng()-0.5)*params.blockSize*0.4, sampleHeightAt(p.x, p.z), p.z + (rng()-0.5)*params.blockSize*0.4);
      rampsToBuild.push({ a: ent, b: toGround, restEvery: params.rampRestEvery });
    }
  });

  rampsToBuild.forEach(r=> buildCareRamp(r.a, r.b, r.restEvery, matRail, matGuide));

  for (let i=0;i<entrances.length*0.4;i++){
    const aIdx = Math.floor(rng()*entrances.length);
    const bIdx = Math.floor(rng()*entrances.length);
    if (aIdx===bIdx) continue;
    const a = entrances[aIdx].clone(); a.y += 8 + rng()*6;
    const b = entrances[bIdx].clone(); b.y += 6 + rng()*8;
    if (a.distanceTo(b) < params.blockSize*2.7 && rng()<0.7){
      buildCareRamp(a, b, params.rampRestEvery*0.7, matRail, matGuide, true);
    }
  }
}

function buildCareRamp(a,b,restEvery,mat,guideMat,isBridge=false){
  const dir = new THREE.Vector3().subVectors(b,a);
  const horiz = new THREE.Vector3(dir.x,0,dir.z);
  const run = Math.max(0.1, horiz.length());
  const rise = dir.y;
  const maxRiseForRun = run * params.rampMaxSlope;
  let neededSegments = 1;

  if (Math.abs(rise) > maxRiseForRun){
    neededSegments = Math.ceil(Math.abs(rise) / (params.rampMaxSlope * (restEvery*0.75)));
  } else {
    neededSegments = Math.max(neededSegments, Math.ceil(run / restEvery));
  }

  const points=[a.clone()];
  for (let i=1;i<=neededSegments;i++){
    const t=i/neededSegments;
    const p=new THREE.Vector3().lerpVectors(a,b,t);
    const prev=points[i-1];
    const targetRun = p.clone().setY(prev.y).distanceTo(prev.clone().setY(prev.y));
    const maxLocalRise = targetRun * params.rampMaxSlope;
    const desiredRise = p.y - prev.y;
    if (Math.abs(desiredRise)>maxLocalRise){
      p.y = prev.y + Math.sign(desiredRise)*maxLocalRise;
    }
    points.push(p);
  }

  for (let i=0;i<points.length-1;i++){
    const p0=points[i], p1=points[i+1];
    const seg = new THREE.Vector3().subVectors(p1,p0);
    const len = seg.length();
    const mid = new THREE.Vector3().addVectors(p0,p1).multiplyScalar(0.5);

    const thickness=0.15;
    const width=isBridge?1.8:2.4;
    const geom=new THREE.BoxGeometry(width, thickness, len);
    const mesh=new THREE.Mesh(geom, mat);
    mesh.position.copy(mid);
    const yaw=Math.atan2(seg.x, seg.z);
    mesh.rotation.y=yaw;
    mesh.rotation.x=Math.atan2(p1.y-p0.y, new THREE.Vector3(seg.x,0,seg.z).length());
    mesh.castShadow=true;
    cityGroup.add(mesh);

    const railGeom=new THREE.BoxGeometry(0.08, 0.7, len*0.98);
    const left=new THREE.Mesh(railGeom, mat), right=new THREE.Mesh(railGeom, mat);
    const offset=(width/2 - 0.15);
    left.position.copy(mid); right.position.copy(mid);
    left.rotation.y=right.rotation.y=mesh.rotation.y;
    left.rotation.x=right.rotation.x=mesh.rotation.x;
    const nx=Math.sin(yaw), nz=Math.cos(yaw);
    left.position.x += nx*offset; left.position.z += nz*offset; left.position.y += 0.45;
    right.position.x -= nx*offset; right.position.z -= nz*offset; right.position.y += 0.45;
    cityGroup.add(left, right);

    if (i < points.length-2){
      const land=new THREE.Mesh(new THREE.BoxGeometry(width*1.25, thickness, width*1.6), mat);
      land.position.copy(p1.clone());
      land.position.y += 0.02;
      land.castShadow=true;
      cityGroup.add(land);
      if (params.guidanceVisible){
        const halo=new THREE.Mesh(new THREE.CylinderGeometry(width*0.55, width*0.55, 0.05, 24), guideMat);
        halo.position.set(land.position.x, land.position.y+0.08, land.position.z);
        guidanceGroup.add(halo);
      }
    }
  }
}

/* ----------------------- animation loop ----------------------- */
const clock = new THREE.Clock();
function animate(){
  requestAnimationFrame(animate);
  const t = clock.getElapsedTime();
  controls.update();
  if (settleAnim){
    cityGroup.traverse(o=>{
      if (o.isMesh && o.geometry && o.geometry.parameters && o.geometry.parameters.width){
        o.rotation.z = (Math.sin((o.id*13.37 + t*0.3)))*0.003;
      }
    });
  }
  renderer.render(scene, camera);
}
animate();

/* ----------------------- interactions ----------------------- */
function regen(){
  const seed = document.getElementById('seedInput').value.trim() || `asym-${Math.floor(Math.random()*9999)}`;
  generate(seed);
}
document.getElementById('regenBtn').addEventListener('click', regen);
window.addEventListener('resize', ()=>{
  camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
window.addEventListener('keydown', (e)=>{
  if (e.key==='r'||e.key==='R') regen();
  if (e.key==='p'||e.key==='P') settleAnim = !settleAnim;
  if (e.key==='g'||e.key==='G'){
    params.guidanceVisible = !params.guidanceVisible;
    guidanceGroup.visible = params.guidanceVisible;
  }
});

// initial
generate(document.getElementById('seedInput').value);
</script>
</body>
</html>
