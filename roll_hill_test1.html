<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Asymmetric Toy Car â€” Vertical Slope (Gentle Descent)</title>
  <style>
    body { margin: 0; background: #fff; overflow: hidden; }
    canvas { display: block; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.0/lib/p5.min.js"></script>
</head>
<body>
<script>
// +Y is DOWNHILL.
// World-velocity model with *gentle* downhill drift.
// - Gravity: (0, g_soft)
// - Static rolling resistance when nearly stopped: opposes gravity up to mu_s*g
//   so the car only creeps a little at rest.
// - Kinetic rolling resistance + light viscous drag when moving.
// - Yaw only from forward rolling (no spin at rest). Subtle low-speed alignment.

let g = 260;         // softer gravity (px/s^2)
let mu_k = 0.06;     // kinetic rolling resistance coeff (moving)
let mu_s = 0.985;    // static rolling resistance fraction (near rest) => tiny creep
let gamma = 0.25;    // light viscous drag (1/s)
let v_eps = 6;       // near-rest speed threshold (px/s)

let car;

const presets = [
  {Rl: 24, Rr: 32, label: "Asymmetric (R > L)"}, // default: right wheel bigger
  {Rl: 30, Rr: 30, label: "Symmetric"},
  {Rl: 18, Rr: 36, label: "Strong asymmetry"},
];
let presetIdx = 0;

let trail = [];
let showTrail = true;

function setup() {
  createCanvas(windowWidth, windowHeight);
  textFont("monospace");
  resetSim();
}
function windowResized() { resizeCanvas(windowWidth, windowHeight); resetSim(); }

function resetSim() {
  car = {
    x: width/2,
    y: 60,              // top of slope
    theta: HALF_PI,     // nose down
    vx: 0, vy: 0,       // world velocities
    wbase: 70,
    Rl: presets[presetIdx].Rl,
    Rr: presets[presetIdx].Rr,
  };
  trail = [];
}

function draw() {
  background(255);
  const dt = Math.min(1/30, (deltaTime || 0) / 1000);
  updatePhysics(dt);
  if (showTrail) recordTrail();
  drawSlope();
  drawTrail();
  drawCar();
  drawHUD();
}

function drawSlope() {
  stroke(0); strokeWeight(2);
  line(width/2, 0, width/2, height);
  strokeWeight(1);
  for (let y = 40; y < height; y += 100) line(width/2 - 14, y, width/2 + 14, y);
}

function updatePhysics(dt) {
  // Keep radii sane
  car.Rl = constrain(car.Rl, 6, 100);
  car.Rr = constrain(car.Rr, 6, 100);

  // --- World acceleration ---
  let ax = 0;
  let ay = g; // gravity straight down the slope

  const speed = Math.hypot(car.vx, car.vy);

  if (speed > v_eps) {
    // Kinetic rolling resistance opposes motion
    const ux = car.vx / speed, uy = car.vy / speed;
    ax += -mu_k * g * ux;
    ay += -mu_k * g * uy;
  } else {
    // Near rest: static rolling resistance opposes gravity up to mu_s*g
    // => net gentle creep: ay = g * (1 - mu_s)
    ay = g * (1 - mu_s);
    ax += -gamma * car.vx * 0.5; // extra calm near rest
  }

  // Light viscous drag (damps oscillations)
  ax += -gamma * car.vx;
  ay += -gamma * car.vy;

  // Integrate world velocity & position
  car.vx += ax * dt;
  car.vy += ay * dt;
  car.x  += car.vx * dt;
  car.y  += car.vy * dt;

  // --- Heading / yaw from actual forward rolling only ---
  const exx = Math.cos(car.theta), exy = Math.sin(car.theta);
  const s = car.vx * exx + car.vy * exy; // signed forward speed along heading

  const Rref = 30;
  const uL = s * (Rref / car.Rl);
  const uR = s * (Rref / car.Rr);
  let yawRate = (uR - uL) / Math.max(1e-6, car.wbase);

  // Very subtle low-speed alignment toward downhill; fades with speed
  const alignGain = 0.2;
  const speed0 = 80;
  const alignWeight = Math.max(0, 1 - Math.min(1, speed / speed0));
  yawRate += alignGain * Math.sin(car.theta) * alignWeight;

  car.theta += yawRate * dt;

  // Reset if out of view
  if (car.y > height + 140 || car.x < -140 || car.x > width + 140) resetSim();
}

function drawCar() {
  const axle = car.wbase;
  const L = createVector(0,  0.5 * axle);
  const R = createVector(0, -0.5 * axle);
  const pC = createVector(car.x, car.y);
  const ex = createVector(Math.cos(car.theta), Math.sin(car.theta));
  const ey = createVector(-Math.sin(car.theta), Math.cos(car.theta));

  const pL = p5.Vector.add(pC, p5.Vector.add(p5.Vector.mult(ey, L.y), p5.Vector.mult(ex, L.x)));
  const pR = p5.Vector.add(pC, p5.Vector.add(p5.Vector.mult(ey, R.y), p5.Vector.mult(ex, R.x)));

  stroke(0); strokeWeight(2); noFill();
  line(pL.x, pL.y, pR.x, pR.y);
  circle(pL.x, pL.y, 2 * car.Rl);
  circle(pR.x, pR.y, 2 * car.Rr);
  const nose = p5.Vector.add(pC, p5.Vector.mult(ex, 28));
  line(pC.x, pC.y, nose.x, nose.y);
}

function recordTrail() {
  trail.push(createVector(car.x, car.y));
  if (trail.length > 900) trail.shift();
}
function drawTrail() {
  if (trail.length < 2) return;
  stroke(0, 80); strokeWeight(1); noFill();
  beginShape(); for (let v of trail) vertex(v.x, v.y); endShape();
}

function drawHUD() {
  noStroke(); fill(0); textSize(14);
  text(`Preset: ${presets[presetIdx].label}`, 12, 22);
  text(`Wheel radii L/R: ${car.Rl} / ${car.Rr}`, 12, 40);
  text("SPACE: change preset   R: reset   T: toggle trail", 12, 58);
}

function keyPressed() {
  if (key === ' ') {
    presetIdx = (presetIdx + 1) % presets.length;
    car.Rl = presets[presetIdx].Rl;
    car.Rr = presets[presetIdx].Rr;
  } else if (key === 'R' || key === 'r') {
    resetSim();
  } else if (key === 'T' || key === 't') {
    showTrail = !showTrail;
  }
}
</script>
</body>
</html>



