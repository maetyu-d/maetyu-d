<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Recursive City Layout Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Make canvas fill its relative container */
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 0.5rem;
        }
        /* Custom slider styles */
        input[type=range] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            background: #d1d5db;
            border-radius: 5px;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
        }
        input[type=range]:hover {
            opacity: 1;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #3b82f6;
            cursor: pointer;
            border-radius: 50%;
        }
        input[type=range]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #3b82f6;
            cursor: pointer;
            border-radius: 50%;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-5xl bg-gray-800 rounded-xl shadow-2xl p-6 md:p-8">
        <div class="text-center mb-6">
            <h1 class="text-3xl md:text-4xl font-bold text-white">Recursive City Layout Generator</h1>
            <p class="text-gray-400 mt-2">An interactive example of generating city-like grids using recursive subdivision.</p>
        </div>

        <!-- Controls -->
        <div class="flex flex-col md:flex-row items-center justify-center gap-6 mb-6 p-4 bg-gray-700/50 rounded-lg">
            <div class="flex items-center gap-3 w-full md:w-auto">
                <label for="depth-slider" class="font-medium text-white whitespace-nowrap">Depth: <span id="depth-value" class="font-bold text-blue-400">5</span></label>
                <input id="depth-slider" type="range" min="1" max="8" value="5" class="w-full">
            </div>
            <button id="generate-btn" class="w-full md:w-auto bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded-lg transition-transform duration-200 transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-blue-500/50">
                Generate New City
            </button>
        </div>

        <!-- Canvas for the city layout -->
        <!-- CORRECTED: Using modern `aspect-[16/9]` which is supported by the Tailwind CDN -->
        <div class="relative aspect-[16/9] w-full rounded-lg overflow-hidden border-2 border-gray-700">
            <canvas id="city-canvas"></canvas>
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const canvas = document.getElementById('city-canvas');
        const ctx = canvas.getContext('2d');
        const generateBtn = document.getElementById('generate-btn');
        const depthSlider = document.getElementById('depth-slider');
        const depthValueSpan = document.getElementById('depth-value');

        // --- Configuration ---
        const MIN_BLOCK_SIZE = 25; // Minimum size for a block before stopping recursion
        const STREET_WIDTH = 4;
        const ASPECT_RATIO_THRESHOLD = 1.25; // How much wider/taller a rect must be to force a split direction

        // --- Colors ---
        const BUILDING_COLORS = ['#4a5568', '#718096', '#a0aec0', '#2d3748'];
        const PARK_COLOR = '#38a169';
        const STREET_COLOR = '#1a202c';
        const PARK_CHANCE = 0.1; // 10% chance for a block to be a park

        // --- Main Logic ---

        /**
         * Resizes the canvas to fit its container.
         */
        function resizeCanvas() {
            const container = canvas.parentElement;
            const { width, height } = container.getBoundingClientRect();
            canvas.width = width;
            canvas.height = height;
        }

        /**
         * Draws a building block or a park.
         * @param {object} rect - The rectangle {x, y, width, height} to draw.
         */
        function drawBlock(rect) {
            if (rect.width <= 0 || rect.height <= 0) return;

            if (Math.random() < PARK_CHANCE) {
                ctx.fillStyle = PARK_COLOR;
                ctx.fillRect(rect.x, rect.y, rect.width, rect.height);
            } else {
                ctx.fillStyle = BUILDING_COLORS[Math.floor(Math.random() * BUILDING_COLORS.length)];
                ctx.fillRect(rect.x, rect.y, rect.width, rect.height);
                
                ctx.strokeStyle = 'rgba(0,0,0,0.2)';
                ctx.lineWidth = 1;
                ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);
            }
        }

        /**
         * How It Works:
         * Start with a Single Area: The algorithm begins with a single large rectangle, which is the entire canvas.
         * Decide How to Split: It randomly decides whether to split this rectangle vertically or horizontally. 
         * To create more natural-looking layouts, the code is biased to split wider rectangles vertically and 
         * taller ones horizontally.
         * Subdivide: The rectangle is split into two smaller sub-rectangles, leaving a small gap in between which 
         * becomes a "street".
         * Recurse: The same process is then applied to each of the two new, smaller rectangles. This continues until 
         * a certain "depth" is reached, or the rectangles become too small.
         * Base Case: When the recursion stops for a particular rectangle, that area is considered a "city block" 
         * and is filled in with a color representing a building or, occasionally, a park.
         */

        /**
         * The core recursive function to subdivide a rectangle.
         * @param {object} rect - The rectangle {x, y, width, height} to subdivide.
         * @param {number} depth - The current recursion depth.
         */
        function subdivide(rect, depth) {
            if (depth <= 0) {
                drawBlock(rect);
                return;
            }

            const canSplitVertical = rect.width > MIN_BLOCK_SIZE * 2 + STREET_WIDTH;
            const canSplitHorizontal = rect.height > MIN_BLOCK_SIZE * 2 + STREET_WIDTH;

            if (!canSplitVertical && !canSplitHorizontal) {
                drawBlock(rect);
                return;
            }

            let splitVertical;
            if (canSplitVertical && !canSplitHorizontal) {
                splitVertical = true;
            } else if (!canSplitVertical && canSplitHorizontal) {
                splitVertical = false;
            } else {
                if (rect.width / rect.height > ASPECT_RATIO_THRESHOLD) {
                    splitVertical = true;
                } else if (rect.height / rect.width > ASPECT_RATIO_THRESHOLD) {
                    splitVertical = false;
                } else {
                    splitVertical = Math.random() > 0.5;
                }
            }

            if (splitVertical) {
                const minSplit = rect.x + MIN_BLOCK_SIZE;
                const maxSplit = rect.x + rect.width - MIN_BLOCK_SIZE;
                if (maxSplit <= minSplit) { drawBlock(rect); return; }
                
                const splitX = Math.random() * (maxSplit - minSplit) + minSplit;

                const rect1 = { 
                    x: rect.x, 
                    y: rect.y, 
                    width: splitX - rect.x - STREET_WIDTH / 2, 
                    height: rect.height 
                };
                const rect2 = { 
                    x: splitX + STREET_WIDTH / 2, 
                    y: rect.y, 
                    width: (rect.x + rect.width) - (splitX + STREET_WIDTH / 2), 
                    height: rect.height 
                };

                subdivide(rect1, depth - 1);
                subdivide(rect2, depth - 1);

            } else { // Horizontal Split
                const minSplit = rect.y + MIN_BLOCK_SIZE;
                const maxSplit = rect.y + rect.height - MIN_BLOCK_SIZE;
                if (maxSplit <= minSplit) { drawBlock(rect); return; }

                const splitY = Math.random() * (maxSplit - minSplit) + minSplit;

                const rect1 = { 
                    x: rect.x, 
                    y: rect.y, 
                    width: rect.width, 
                    height: splitY - rect.y - STREET_WIDTH / 2 
                };
                const rect2 = { 
                    x: rect.x, 
                    y: splitY + STREET_WIDTH / 2, 
                    width: rect.width, 
                    height: (rect.y + rect.height) - (splitY + STREET_WIDTH / 2)
                };
                
                subdivide(rect1, depth - 1);
                subdivide(rect2, depth - 1);
            }
        }

        /**
         * Main function to generate the entire city layout.
         */
        function generateCity() {
            ctx.fillStyle = STREET_COLOR;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const maxDepth = parseInt(depthSlider.value, 10);
            const initialRect = { x: 0, y: 0, width: canvas.width, height: canvas.height };
            subdivide(initialRect, maxDepth);
        }

        // --- Event Listeners ---
        generateBtn.addEventListener('click', generateCity);

        depthSlider.addEventListener('input', (e) => {
            depthValueSpan.textContent = e.target.value;
        });
        depthSlider.addEventListener('change', generateCity);

        window.addEventListener('resize', () => {
            resizeCanvas();
            generateCity();
        });

        // --- Initial Setup ---
        resizeCanvas();
        generateCity();

    </script>
</body>
</html>
