<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic Granular Angels</title>
    <style>
        :root {
            --bg-color: #1a1a2e;
            --primary-color: #47e5bc;
            --secondary-color: #16213e;
            --text-color: #f0f0f0;
            --slider-track: #0f3460;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }
        .container {
            background-color: var(--secondary-color);
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
            text-align: center;
            max-width: 600px;
            width: 100%;
        }
        h1 {
            color: var(--primary-color);
            margin-bottom: 10px;
        }
        p {
            margin-bottom: 25px;
            line-height: 1.6;
        }
        button {
            background-color: var(--primary-color);
            color: var(--secondary-color);
            font-weight: bold;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            font-size: 1.1em;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 20px;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(71, 229, 188, 0.3);
        }
        button:disabled {
            background-color: #555;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        .controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px 30px;
            text-align: left;
            margin-bottom: 20px;
        }
        .control-group {
            display: flex;
            flex-direction: column;
        }
        .control-group.full-width {
            grid-column: 1 / -1;
        }
         .checkbox-group {
            grid-column: 1 / -1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 10px;
            background: var(--slider-track);
            border-radius: 8px;
         }
        label {
            margin-bottom: 10px;
            font-weight: bold;
        }
        input[type="range"] { -webkit-appearance: none; appearance: none; width: 100%; height: 8px; background: var(--slider-track); border-radius: 5px; outline: none; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 20px; height: 20px; background: var(--primary-color); cursor: pointer; border-radius: 50%; border: 2px solid var(--secondary-color); }
        input[type="range"]::-moz-range-thumb { width: 20px; height: 20px; background: var(--primary-color); cursor: pointer; border-radius: 50%; border: 2px solid var(--secondary-color); }
        .value-display { font-size: 0.9em; opacity: 0.8; margin-top: 5px; }
        canvas { width: 100%; height: 100px; background-color: var(--slider-track); border-radius: 5px; margin-top: 20px; }
    </style>
</head>
<body>

    <div class="container">
        <h1>Dynamic Granular Angels</h1>
        <p>Your playing dynamics now control the effect. Play louder for a denser cloud of sound. Use the "Dynamic Pitch" toggle to let your tone's brightness control the harmonies.</p>
        <button id="startButton">Start Audio Engine</button>
        
        <div class="controls">
            <div class="control-group full-width">
                <label for="wetDryMix">Wet/Dry Mix</label>
                <input type="range" id="wetDryMix" min="0" max="1" value="0.8" step="0.01">
                <span id="wetDryMixValue" class="value-display">80% Wet</span>
            </div>
            <div class="control-group">
                <label for="dynamicsSensitivity">Dynamics Sensitivity</label>
                <input type="range" id="dynamicsSensitivity" min="0.1" max="2.0" value="1.0" step="0.05">
                <span id="dynamicsSensitivityValue" class="value-display">1.0</span>
            </div>
            <div class="control-group">
                <label for="grainSize">Grain Size (ms)</label>
                <input type="range" id="grainSize" min="50" max="500" value="300" step="1">
                <span id="grainSizeValue" class="value-display">300 ms</span>
            </div>
             <div class="checkbox-group">
                <input type="checkbox" id="dynamicPitchToggle" checked>
                <label for="dynamicPitchToggle" style="margin: 0 0 0 10px; cursor: pointer;">Dynamic Pitch (Brightness â†’ Harmony)</label>
            </div>
            <div class="control-group full-width">
                <label for="pitchSpread">Base Pitch Spread</label>
                <input type="range" id="pitchSpread" min="0" max="1" value="0.5" step="0.01">
                 <span id="pitchSpreadValue" class="value-display">50% Octave / 50% Fifth</span>
            </div>
        </div>
        <canvas id="visualizer" width="600" height="100"></canvas>
    </div>

    <script>
        // --- Core Audio & Analysis Variables ---
        let audioContext, micSource, analyser, scriptNode, convolver, dryGain, wetGain;
        let isAudioRunning = false;
        let schedulerTimeout;
        let timeDomainData, freqDomainData;

        // --- Audio Buffers ---
        const BUFFER_SIZE_SECONDS = 2;
        let liveBuffer, bufferWritePosition = 0;

        // --- UI Elements ---
        const ui = {
            startBtn: document.getElementById('startButton'),
            wetDry: document.getElementById('wetDryMix'),
            sensitivity: document.getElementById('dynamicsSensitivity'),
            grainSize: document.getElementById('grainSize'),
            dynamicPitch: document.getElementById('dynamicPitchToggle'),
            pitchSpread: document.getElementById('pitchSpread'),
            wetDryVal: document.getElementById('wetDryMixValue'),
            sensitivityVal: document.getElementById('dynamicsSensitivityValue'),
            grainSizeVal: document.getElementById('grainSizeValue'),
            pitchSpreadVal: document.getElementById('pitchSpreadValue'),
            canvas: document.getElementById('visualizer'),
            canvasCtx: document.getElementById('visualizer').getContext('2d')
        };
        
        function createSyntheticImpulse(context) {
            const sampleRate = context.sampleRate;
            const duration = 2.5, decay = 4.0;
            const impulse = context.createBuffer(2, sampleRate * duration, sampleRate);
            for (let c = 0; c < 2; c++) {
                const channelData = impulse.getChannelData(c);
                for (let i = 0; i < channelData.length; i++) {
                    channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / channelData.length, decay);
                }
            }
            return impulse;
        }

        async function initAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                liveBuffer = new Float32Array(audioContext.sampleRate * BUFFER_SIZE_SECONDS);
                
                // --- Create Audio Graph ---
                dryGain = audioContext.createGain();
                wetGain = audioContext.createGain();
                convolver = audioContext.createConvolver();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 1024;
                analyser.smoothingTimeConstant = 0.6;
                timeDomainData = new Uint8Array(analyser.frequencyBinCount);
                freqDomainData = new Uint8Array(analyser.frequencyBinCount);
                
                convolver.buffer = createSyntheticImpulse(audioContext);
                
                const stream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false } });
                micSource = audioContext.createMediaStreamSource(stream);
                
                scriptNode = audioContext.createScriptProcessor(4096, 1, 1);
                scriptNode.onaudioprocess = (e) => {
                    const input = e.inputBuffer.getChannelData(0);
                    for (let i = 0; i < input.length; i++) {
                        liveBuffer[bufferWritePosition] = input[i];
                        bufferWritePosition = (bufferWritePosition + 1) % liveBuffer.length;
                    }
                };
                
                // --- Connect Audio Graph ---
                micSource.connect(scriptNode);
                scriptNode.connect(analyser);
                analyser.connect(dryGain).connect(audioContext.destination);
                analyser.connect(wetGain).connect(convolver).connect(audioContext.destination);

                updateUICallbacks();
                updateWetDryMix();
                
                isAudioRunning = true;
                ui.startBtn.textContent = 'Stop Audio Engine';
                ui.startBtn.disabled = false;
                
                scheduleNextGrain(); // Start the dynamic scheduler
                analysisLoop(); // Start the analysis loop

            } catch (err) {
                alert('Error initialising audio. Please grant microphone permissions.\n' + err);
                ui.startBtn.disabled = false;
            }
        }

        function stopAudio() {
            if (schedulerTimeout) clearTimeout(schedulerTimeout);
            if (isAudioRunning) {
                micSource.mediaStream.getTracks().forEach(track => track.stop());
                audioContext.close().then(() => {
                    isAudioRunning = false;
                    ui.startBtn.textContent = 'Start Audio Engine';
                    ui.startBtn.disabled = false;
                    ui.canvasCtx.fillStyle = 'var(--slider-track)';
                    ui.canvasCtx.fillRect(0, 0, ui.canvas.width, ui.canvas.height);
                });
            }
        }
        
        function scheduleNextGrain() {
            // --- Dynamic Scheduling based on Amplitude ---
            const sensitivity = parseFloat(ui.sensitivity.value);
            analyser.getByteTimeDomainData(timeDomainData);
            let sumSquares = 0.0;
            for (const amplitude of timeDomainData) {
                const val = (amplitude / 128.0) - 1.0; // convert to -1 to 1 range
                sumSquares += val * val;
            }
            const rms = Math.sqrt(sumSquares / timeDomainData.length);
            
            // Map RMS to grain interval. Louder -> shorter interval -> higher density.
            const minInterval = 10; // Corresponds to max density (100 grains/sec)
            const maxInterval = 200; // Corresponds to min density (5 grains/sec)
            const interval = maxInterval - (rms * sensitivity * (maxInterval - minInterval));
            const clampedInterval = Math.max(minInterval, Math.min(maxInterval, interval));

            playGrain();
            schedulerTimeout = setTimeout(scheduleNextGrain, clampedInterval);
        }

        function playGrain() {
            if (!audioContext || audioContext.state !== 'running') return;

            const grainSizeMs = parseFloat(ui.grainSize.value);
            const grainSizeFrames = Math.floor(audioContext.sampleRate * (grainSizeMs / 1000));
            const startFrame = Math.floor(Math.random() * (liveBuffer.length - grainSizeFrames));
            
            const grainBuffer = audioContext.createBuffer(1, grainSizeFrames, audioContext.sampleRate);
            const grainData = grainBuffer.getChannelData(0);

            // Copy audio data from live buffer to grain buffer
            for (let i = 0; i < grainSizeFrames; i++) {
                grainData[i] = liveBuffer[(startFrame + i) % liveBuffer.length];
            }

            // Apply fade in/out envelope to the grain to prevent clicks
            const envelopeAttack = grainSizeFrames * 0.1;
            const envelopeRelease = grainSizeFrames * 0.9;
            for(let i = 0; i < grainSizeFrames; i++) {
                if(i < envelopeAttack) grainData[i] *= i / envelopeAttack;
                else if (i > envelopeRelease) grainData[i] *= (grainSizeFrames - i) / (grainSizeFrames - envelopeRelease);
            }

            const grainSource = audioContext.createBufferSource();
            grainSource.buffer = grainBuffer;
            
            // --- Pitch Shifting ---
            const baseSpread = parseFloat(ui.pitchSpread.value);
            const highPitch = 2.0; // Octave
            const midPitch = 1.5;  // Perfect Fifth
            const playbackRate = highPitch * baseSpread + midPitch * (1 - baseSpread);
            grainSource.playbackRate.value = playbackRate + (Math.random() * 0.02 - 0.01); // Detune

            // --- Panning ---
            const panner = audioContext.createStereoPanner();
            panner.pan.value = Math.random() * 2 - 1;
            
            // Connect and play
            grainSource.connect(panner).connect(wetGain);
            grainSource.start(audioContext.currentTime);
        }

        function analysisLoop() {
            if (!isAudioRunning) return;
            requestAnimationFrame(analysisLoop);
            
            // --- Dynamic Pitch based on Brightness ---
            if (ui.dynamicPitch.checked) {
                analyser.getByteFrequencyData(freqDomainData);
                const midPoint = Math.floor(freqDomainData.length / 3);
                let lowSum = 0, highSum = 0;
                for (let i = 0; i < midPoint; i++) lowSum += freqDomainData[i];
                for (let i = midPoint; i < freqDomainData.length; i++) highSum += freqDomainData[i];
                
                const brightness = highSum / (lowSum + highSum + 1); // Ratio of high to total energy
                const clampedBrightness = Math.min(1, Math.max(0, brightness * 2.5)); // Scale and clamp
                
                ui.pitchSpread.value = clampedBrightness;
                updatePitchSpreadDisplay();
            }

            // --- Visualizer Drawing ---
            analyser.getByteTimeDomainData(timeDomainData);
            ui.canvasCtx.fillStyle = 'var(--slider-track)';
            ui.canvasCtx.fillRect(0, 0, ui.canvas.width, ui.canvas.height);
            ui.canvasCtx.lineWidth = 2;
            ui.canvasCtx.strokeStyle = 'var(--primary-color)';
            ui.canvasCtx.beginPath();
            const sliceWidth = ui.canvas.width * 1.0 / timeDomainData.length;
            let x = 0;
            for (let i = 0; i < timeDomainData.length; i++) {
                const v = timeDomainData[i] / 128.0;
                const y = v * ui.canvas.height / 2;
                if (i === 0) ui.canvasCtx.moveTo(x, y);
                else ui.canvasCtx.lineTo(x, y);
                x += sliceWidth;
            }
            ui.canvasCtx.lineTo(ui.canvas.width, ui.canvas.height / 2);
            ui.canvasCtx.stroke();
        }

        function updateWetDryMix() {
            const mix = parseFloat(ui.wetDry.value);
            dryGain.gain.value = Math.cos(mix * 0.5 * Math.PI);
            wetGain.gain.value = Math.cos((1.0 - mix) * 0.5 * Math.PI);
            ui.wetDryVal.textContent = `${Math.round(mix * 100)}% Wet`;
        }
        
        function updatePitchSpreadDisplay() {
            const spread = Math.round(ui.pitchSpread.value * 100);
            ui.pitchSpreadVal.textContent = `${spread}% Octave / ${100 - spread}% Fifth`;
        }

        function updateUICallbacks() {
            ui.startBtn.addEventListener('click', () => {
                ui.startBtn.disabled = true;
                if (isAudioRunning) stopAudio();
                else initAudio();
            });
            ui.wetDry.addEventListener('input', updateWetDryMix);
            ui.grainSize.addEventListener('input', () => { ui.grainSizeVal.textContent = `${ui.grainSize.value} ms`; });
            ui.sensitivity.addEventListener('input', () => { ui.sensitivityVal.textContent = parseFloat(ui.sensitivity.value).toFixed(2); });
            ui.pitchSpread.addEventListener('input', updatePitchSpreadDisplay);
            ui.dynamicPitch.addEventListener('change', () => {
                ui.pitchSpread.disabled = ui.dynamicPitch.checked;
            });
            // Initial state
            ui.pitchSpread.disabled = ui.dynamicPitch.checked;
            updatePitchSpreadDisplay();
        }

        // Initial setup
        updateUICallbacks();

    </script>

</body>
</html>
