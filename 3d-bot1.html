<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Procedural Brutalist City Generator â€” 16Ã—16Ã—16</title>
  <style>
    html, body { height: 100%; margin: 0; background: #0c0c0c; color: #e6e6e6; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    #ui { position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.6); padding: 10px 12px; border-radius: 12px; border: 1px solid #2a2a2a; backdrop-filter: blur(4px); z-index: 10; }
    #ui h1 { margin: 0 0 6px 0; font-size: 14px; letter-spacing: 0.06em; opacity: 0.9; }
    #ui .row { display: flex; gap: 10px; align-items: center; margin: 6px 0; flex-wrap: wrap; }
    #ui label { font-size: 12px; opacity: 0.9; }
    #ui input[type="range"] { width: 140px; }
    #legend { font-size: 11px; opacity: 0.85; margin-top: 6px; line-height: 1.3; }
    #tests { font-size: 11px; opacity: 0.9; margin-top: 6px; line-height: 1.3; white-space: pre-line; }
    a, a:visited { color: #b6f; }
    canvas { outline: none; display: block; }
    #splitLabels { position: absolute; top: 10px; right: 10px; font-size: 11px; opacity: 0.9; background: rgba(0,0,0,0.4); padding: 6px 8px; border-radius: 10px; border: 1px solid #2a2a2a; z-index: 10; }
    #score { display:inline-block; margin-left:8px; padding:2px 6px; background: rgba(255,255,255,0.06); border-radius:8px; border:1px solid #2a2a2a; }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.2/p5.min.js"></script>
</head>
<body>
  <div id="ui">
    <h1>Brutalist City â€” 16Ã—16Ã—16</h1>
    <div class="row">
      <label>Seed</label>
      <input id="seedInput" type="number" step="1" />
      <button id="reseat">Reseed</button>
      <button id="regen">Regenerate</button>
      <button id="exportTrails">Export Trails x10 (Left)</button>
    </div>
    <div class="row">
      <label>Density</label>
      <input id="density" type="range" min="0" max="1" step="0.01" />
      <label>Height</label>
      <input id="height" type="range" min="4" max="16" step="1" />
    </div>
    <div class="row">
      <label><input id="toggleStairs" type="checkbox" checked /> Stair Shafts</label>
      <label><input id="toggleBridges" type="checkbox" checked /> Sky Bridges</label>
      <label><input id="toggleGrid" type="checkbox" /> Grid</label>
      <label><input id="wireLeft" type="checkbox" /> Wireframe (Left)</label>
      <label><input id="wireRight" type="checkbox" /> Wireframe (Right)</label>
    </div>
    <div class="row">
      <label>Sim speed</label>
      <select id="simSpeed">
        <option value="0.1">0.1Ã—</option>
        <option value="1" selected>1Ã—</option>
        <option value="10">10Ã—</option>
      </select>
    </div>
    <div class="row">
      <label>Left view</label>
      <select id="leftView">
        <option value="side">Side-on</option>
        <option value="top">Top-down</option>
      </select>
      <label>Right view</label>
      <select id="rightView">
        <option value="free">Free orbit</option>
        <option value="iso">Isometric</option>
      </select>
    </div>
    <div id="legend">
      Drag on the <b>right pane</b> to orbit (when set to Free) â€¢ Mouse wheel zooms the pane under the cursor (independent per pane)
      â€¢ R = regenerate â€¢ S = save PNG (stitched) â€¢ T = run tests
    </div>
    <div id="tests"></div>
  </div>
  <div id="splitLabels">
    Left: <span id="leftLabel">Side-on</span> | Right: <span id="rightLabel">Free orbit</span>
    <span id="score">ðŸŸ© 0 : 0 ðŸŸ§</span><span id="simLabel"> â€¢ speed: 1Ã—</span>
  </div>

  <script>
    // --- Parameters ---
    const GRID = 16;            // 16Ã—16 footprint
    const LEVELS = 16;          // max vertical levels
    const CELL = 40;            // world units per cell
    const BRIDGE_THICK = 8;     // bridge thickness

    const PALETTE = {
      concrete: [128, 128, 128],
      darker:   [98, 98, 98],
      accent:   [150, 150, 155],
      sky:      [20, 20, 24]
    };

    // State
    let seed = Math.floor(Math.random() * 1e9);
    let towers = [];
    let bridges = [];

    // Graph for navigation
    let navNodes = [];          // {ti, level, x, y, z}
    let navAdj   = [];          // adjacency list
    let baseIndexByTower = [];  // for (ti, level) -> node index

    // Bots & goal
    let bots = [];
    let goal = null;            // { node:index }
    let scores = { green: 0, orange: 0 };

    // Viewports / cameras
    let leftPG, rightPG;        // WEBGL buffers
    let zoomLeft = 1.0, zoomRight = 1.0;
    let freeRotX = -35.264 * Math.PI/180;
    let freeRotY = 45 * Math.PI/180;

    // Wireframe toggles
    let wireLeft = false, wireRight = false;

    // Sim speed
    let simSpeed = 1.0;

    // Tests
    let SHOW_TESTS = false;

    // UI helper
    const testPanel = () => document.getElementById('tests');

    // -------- Utilities / UI ----------
    function reseed(val) {
      seed = (val !== undefined) ? val : Math.floor(Math.random() * 1e9);
      randomSeed(seed);
      noiseSeed(seed);
      document.getElementById('seedInput').value = seed;
    }

    function params() {
      return {
        density: parseFloat(document.getElementById('density').value),
        maxHeight: parseInt(document.getElementById('height').value, 10),
        stairsOn: document.getElementById('toggleStairs').checked,
        bridgesOn: document.getElementById('toggleBridges').checked,
        gridOn: document.getElementById('toggleGrid').checked,
        leftView: document.getElementById('leftView').value,
        rightView: document.getElementById('rightView').value,
        wireLeft: document.getElementById('wireLeft').checked,
        wireRight: document.getElementById('wireRight').checked,
      };
    }

    function setup() {
      // Main canvas is 2D; we composite two WEBGL buffers onto it
      createCanvas(windowWidth, windowHeight);
      noStroke();

      resizePanes();

      // init UI defaults & handlers
      document.getElementById('density').value = 0.55;
      document.getElementById('height').value = 12;
      reseed(seed);

      document.getElementById('reseat').onclick = () => { reseed(); generateCity(); };
      document.getElementById('regen').onclick  = () => { generateCity(); };
      document.getElementById('seedInput').onchange = (e) => { reseed(parseInt(e.target.value||0,10)); generateCity(); };
      document.getElementById('exportTrails').onclick = () => { exportTrailsLeftHiRes(); };
      document.getElementById('simSpeed').onchange = (e) => { simSpeed = parseFloat(e.target.value); updateSimLabel(); };

      ['density','height','toggleStairs','toggleBridges','toggleGrid','leftView','rightView','wireLeft','wireRight']
        .forEach(id => document.getElementById(id).oninput = () => {
          document.getElementById('leftLabel').textContent = params().leftView === 'side' ? 'Side-on' : 'Top-down';
          document.getElementById('rightLabel').textContent = params().rightView === 'free' ? 'Free orbit' : 'Isometric';
          wireLeft = params().wireLeft;
          wireRight = params().wireRight;
          generateCity();
        });

      // Mouse wheel zoom into pane under cursor
      window.addEventListener('wheel', (e) => {
        const delta = -Math.sign(e.deltaY) * 0.05;
        if (mouseX <= width/2) zoomLeft  = constrain(zoomLeft  + delta, 0.4, 3.0);
        else                   zoomRight = constrain(zoomRight + delta, 0.4, 3.0);
      }, { passive: true });

      updateSimLabel();
      generateCity();
    }

    function resizePanes() {
      leftPG  = createGraphics(Math.floor(width/2), height, WEBGL);
      rightPG = createGraphics(Math.floor(width/2), height, WEBGL);
    }

    function windowResized() {
      resizeCanvas(windowWidth, windowHeight);
      resizePanes();
      redraw();
    }

    function keyPressed() {
      if (key === 'R' || key === 'r') generateCity();
      if (key === 'S' || key === 's') {
        // Save a stitched image of both panes
        const pg = createGraphics(width, height);
        pg.image(leftPG, 0, 0, width/2, height);
        pg.image(rightPG, width/2, 0, width/2, height);
        pg.save('brutalist_city_'+seed+'.png');
      }
      if (key === 'T' || key === 't') { SHOW_TESTS = !SHOW_TESTS; runTests(); }
      if (key === '[') {
        if (simSpeed === 10) simSpeed = 1;
        else if (simSpeed === 1) simSpeed = 0.1;
        document.getElementById('simSpeed').value = simSpeed.toString();
        updateSimLabel();
      }
      if (key === ']') {
        if (simSpeed === 0.1) simSpeed = 1;
        else if (simSpeed === 1) simSpeed = 10;
        document.getElementById('simSpeed').value = simSpeed.toString();
        updateSimLabel();
      }
    }

    function mouseDragged() {
      const P = params();
      // Orbit only when the cursor is in the right pane and right view is Free
      if (mouseX > width/2 && P.rightView === 'free') {
        freeRotY += movedX * 0.01; // yaw
        freeRotX += movedY * 0.01; // pitch
        freeRotX = constrain(freeRotX, -Math.PI/2, Math.PI/2 * 0.99);
      }
    }

    // -------- City generation ----------
    function generateCity() {
      const P = params();
      randomSeed(seed);
      noiseSeed(seed);
      towers = [];
      bridges = [];
      navNodes = [];
      navAdj = [];
      baseIndexByTower = [];
      bots = [];
      goal = null;
      scores = { green: 0, orange: 0 };

      // Layout noise fields
      const freq = 0.08; // spatial frequency for clustering
      for (let gx = 0; gx < GRID; gx++) {
        for (let gz = 0; gz < GRID; gz++) {
          const n = noise(gx * freq, gz * freq);
          const place = n * 0.9 + random(0.1);
          if (place < (1.0 - P.density)) continue;

          // Base footprint (1â€“3)
          const footprint = random() < 0.2 ? 3 : (random() < 0.5 ? 2 : 1);
          const hNoise = noise(gx * freq * 1.7 + 100, gz * freq * 1.7 + 100);
          const maxH = constrain(Math.floor(map(hNoise, 0, 1, 4, P.maxHeight)), 4, LEVELS);

          // Modular chunking: stack modules of 2â€“4 levels
          const modules = [];
          let y = 0;
          while (y < maxH) {
            const mh = Math.min(maxH - y, Math.floor(random(2, 5)));
            const offset = (random() < 0.25) ? (random([-1, 0, 1])) : 0; // brutalist overhangs
            const extrude = (random() < 0.25) ? (random([0,1])) : 0;     // slight extrusion
            modules.push({ y, h: mh, offset, extrude });
            y += mh;
          }

          // Logical stairs always present; visual toggle controls rendering only
          const stairSide = 1;
          const stairPos = { sx: 0, sz: 0 };

          towers.push({ gx, gz, footprint, maxH, modules, hasStairs: true, renderStairs: P.stairsOn, stairSide, stairPos });
        }
      }

      // Sky bridges â€” ensure at least one per tower by linking to nearest neighbor
      if (P.bridgesOn) {
        for (let i = 0; i < towers.length; i++) {
          const a = towers[i];
          let best = null, bestd = 1e9;
          for (let j = 0; j < towers.length; j++) if (i !== j) {
            const b = towers[j];
            const dx = b.gx - a.gx; const dz = b.gz - a.gz;
            const d2 = dx*dx + dz*dz;
            if (d2 < bestd && d2 > 0) { bestd = d2; best = b; }
          }
          if (best) {
            const y = Math.floor(random(3, Math.min(a.maxH, best.maxH)));
            bridges.push({ a, b: best, y });
          }
          // occasional extra bridge
          if (random() < 0.3 && towers.length > 3) {
            const b = random(towers);
            if (b && b !== a) {
              const y = Math.floor(random(3, Math.min(a.maxH, b.maxH)));
              bridges.push({ a, b, y });
            }
          }
        }
      }

      // Ensure full connectivity across towers
      ensureConnectivity();

      // Build navigation graph and deploy bots + goal
      buildNavGraph();
      createBotsAndGoal();

      if (SHOW_TESTS) runTests();
    }

    function towerCenter(ti) {
      const t = towers[ti];
      return { x: (t.gx - GRID/2) * CELL, z: (t.gz - GRID/2) * CELL };
    }

    function ensureConnectivity() {
      if (towers.length === 0) return;
      const n = towers.length;
      const adj = Array.from({length:n}, () => []);
      for (const br of bridges) {
        const ai = towers.indexOf(br.a);
        const bi = towers.indexOf(br.b);
        if (ai>=0 && bi>=0) { adj[ai].push(bi); adj[bi].push(ai); }
      }
      const comp = Array(n).fill(-1); let c = 0;
      for (let i=0;i<n;i++) if (comp[i]===-1){
        const stack=[i]; comp[i]=c;
        while(stack.length){
          const u=stack.pop();
          for(const v of adj[u]) if(comp[v]===-1){comp[v]=c; stack.push(v);}
        }
        c++;
      }
      if (c<=1) return;
      // Connect each nonzero component to component 0 via nearest pair
      for (let k=1;k<c;k++){
        let bestA=-1,bestB=-1,bestD=1e9;
        for (let i=0;i<n;i++) if (comp[i]===0)
          for (let j=0;j<n;j++) if (comp[j]===k){
            const ci=towerCenter(i), cj=towerCenter(j);
            const d=(ci.x-cj.x)**2+(ci.z-cj.z)**2;
            if (d<bestD){bestD=d; bestA=i; bestB=j;}
          }
        if (bestA>=0){
          const a=towers[bestA], b=towers[bestB];
          const y = Math.floor(Math.min(a.maxH, b.maxH)/2);
          bridges.push({a,b,y});
          for (let i=0;i<n;i++) if (comp[i]===k) comp[i]=0;
        }
      }
    }

    function buildNavGraph(){
      navNodes=[]; navAdj=[]; baseIndexByTower=[];
      let base = 0;
      for (let ti=0; ti<towers.length; ti++){
        baseIndexByTower[ti] = base;
        const t = towers[ti];
        const c = towerCenter(ti);
        for (let lvl=0; lvl<t.maxH; lvl++){
          navNodes.push({ti, level:lvl, x:c.x, y:-lvl*CELL, z:c.z});
          navAdj.push([]);
        }
        // vertical edges within tower
        for (let lvl=0; lvl<t.maxH-1; lvl++){
          const a = base + lvl, b = base + lvl + 1;
          navAdj[a].push(b); navAdj[b].push(a);
        }
        base += t.maxH;
      }
      // bridge edges at their level
      function nodeIndex(ti,lvl){ return baseIndexByTower[ti] + lvl; }
      for (const br of bridges){
        const ai = towers.indexOf(br.a), bi = towers.indexOf(br.b);
        if (ai<0 || bi<0) continue;
        const lvl = Math.min(br.y, towers[ai].maxH-1, towers[bi].maxH-1);
        const aIdx = nodeIndex(ai,lvl), bIdx = nodeIndex(bi,lvl);
        navAdj[aIdx].push(bIdx); navAdj[bIdx].push(aIdx);
      }
    }

    function pickRandomNode(exclude=-1){
      if (navNodes.length===0) return -1;
      let idx; do { idx = Math.floor(random(navNodes.length)); } while (idx===exclude && navNodes.length>1);
      return idx;
    }

    function createBotsAndGoal(){
      if (navNodes.length===0) return;
      const gIdx = pickRandomNode();
      const oIdx = pickRandomNode(gIdx);
      bots = [
        { name:'green',  color:[60,200,100],  node:gIdx, pos:{...navNodes[gIdx]}, path:[], segI:0, t:0, speed:2.0, trail: [{...navNodes[gIdx]}] },
        { name:'orange', color:[240,150,60], node:oIdx, pos:{...navNodes[oIdx]}, path:[], segI:0, t:0, speed:2.2, trail: [{...navNodes[oIdx]}] }
      ];
      goal = { node: pickRandomNode() };
      for (const b of bots) planPath(b, goal.node);
      updateScoreLabel();
    }

    // -------- Pathfinding ----------
    function heuristic(a,b){
      const pa = navNodes[a], pb = navNodes[b];
      const dx=pa.x-pb.x, dy=pa.y-pb.y, dz=pa.z-pb.z;
      return Math.sqrt(dx*dx+dy*dy+dz*dz);
    }

    function planPath(bot, targetIdx){
      const N = navNodes.length;
      const open = new Set([bot.node]);
      const came = new Map();
      const g = Array(N).fill(Infinity); g[bot.node]=0;
      const f = Array(N).fill(Infinity); f[bot.node]=heuristic(bot.node, targetIdx);

      while (open.size){
        let current=-1, best=Infinity;
        for(const n of open){ if(f[n]<best){best=f[n]; current=n;} }
        if (current===targetIdx) break;
        open.delete(current);
        for (const nb of navAdj[current]){
          const tentative = g[current] + heuristic(current, nb);
          if (tentative < g[nb]){
            came.set(nb, current);
            g[nb]=tentative;
            f[nb]=tentative + heuristic(nb, targetIdx);
            open.add(nb);
          }
        }
      }
      // reconstruct
      if (!isFinite(g[targetIdx])){ bot.path=[]; bot.segI=0; bot.t=0; return; }
      const nodes=[]; let u=targetIdx; nodes.unshift(u);
      while (u!==bot.node){ u=came.get(u); if (u===undefined) break; nodes.unshift(u); }
      const segs=[];
      for (let i=0;i<nodes.length-1;i++){
        const a=navNodes[nodes[i]], b=navNodes[nodes[i+1]];
        const len=Math.hypot(a.x-b.x,a.y-b.y,a.z-b.z);
        segs.push({a,b,len});
      }
      bot.path=segs; bot.segI=0; bot.t=0; bot.node=nodes[0];
    }

    function stepBots(){
      if (!goal || navNodes.length===0) return;
      for (const b of bots){
        const speedScale = simSpeed;
        if (!b.path || b.path.length===0){ planPath(b, goal.node); continue; }
        const seg = b.path[b.segI]; if (!seg) continue;
        const dt = b.speed * speedScale; // distance step per frame
        const ax=seg.a.x, ay=seg.a.y, az=seg.a.z; const bx=seg.b.x, by=seg.b.y, bz=seg.b.z;
        const vx = (bx-ax)/seg.len, vy=(by-ay)/seg.len, vz=(bz-az)/seg.len;
        b.t += dt;
        if (b.t >= seg.len){
          b.pos = {x:bx,y:by,z:bz};
          b.trail.push({x:b.pos.x, y:b.pos.y, z:b.pos.z});
          b.segI++; b.t=0;
          if (b.segI >= b.path.length){
            const gp = navNodes[goal.node];
            const d = Math.hypot(b.pos.x-gp.x, b.pos.y-gp.y, b.pos.z-gp.z);
            if (d < 1e-3){
              scores[b.name] = (scores[b.name]||0)+1;
              goal.node = pickRandomNode();
              for (const bb of bots) planPath(bb, goal.node);
              updateScoreLabel();
            }
          }
        } else {
          b.pos.x = ax + vx*b.t;
          b.pos.y = ay + vy*b.t;
          b.pos.z = az + vz*b.t;
          b.trail.push({x:b.pos.x, y:b.pos.y, z:b.pos.z});
        }
      }
    }

    // -------- UI overlays ----------
    function updateScoreLabel(){
      const el = document.getElementById('score');
      el.textContent = `ðŸŸ© ${scores.green||0} : ${scores.orange||0} ðŸŸ§`;
    }

    function updateSimLabel(){
      const el = document.getElementById('simLabel');
      if (!el) return;
      el.textContent = ` â€¢ speed: ${simSpeed}Ã—`;
    }

    // -------- Rendering ----------
    function drawGoal(g){
      if (!goal || !navNodes[goal.node]) return;
      const p = navNodes[goal.node];
      g.push();
      g.translate(p.x, p.y - CELL*0.25, p.z);
      g.ambientMaterial(200, 220, 255);
      g.box(CELL*0.4, CELL*0.5, CELL*0.4);
      g.pop();
    }

    function drawBots(g, wire){
      for (const b of bots){
        // trail
        if (b.trail && b.trail.length>1){
          g.push();
          g.noFill();
          g.stroke(b.color[0], b.color[1], b.color[2], 150);
          for (let i=1;i<b.trail.length;i++){
            const p0=b.trail[i-1], p1=b.trail[i];
            g.line(p0.x, p0.y - CELL*0.3, p0.z, p1.x, p1.y - CELL*0.3, p1.z);
          }
          g.noStroke();
          g.pop();
        }
        // bot body
        g.push();
        g.translate(b.pos.x, b.pos.y - CELL*0.3, b.pos.z);
        if (wire){
          g.noFill(); g.stroke(b.color[0], b.color[1], b.color[2]);
          g.box(CELL*0.6, CELL*0.6, CELL*0.6);
          g.noStroke();
        } else {
          g.ambientMaterial(b.color[0], b.color[1], b.color[2]);
          g.box(CELL*0.6, CELL*0.6, CELL*0.6);
        }
        g.pop();
      }
    }

    function drawGround(g, wire = false) {
      g.push();
      g.translate(0, 2, 0);
      if (wire) {
        g.noFill();
        g.stroke(60);
        g.box(GRID*CELL*1.6, 4, GRID*CELL*1.6);
        g.noStroke();
      } else {
        g.ambientMaterial(PALETTE.sky[0], PALETTE.sky[1], PALETTE.sky[2]);
        g.box(GRID*CELL*1.6, 4, GRID*CELL*1.6);
      }
      g.pop();
    }

    function drawGrid(g) {
      const P = params();
      if (!P.gridOn) return;
      g.push();
      g.stroke(40);
      g.noFill();
      const half = GRID * CELL / 2;
      for (let i = -half; i <= half; i += CELL) {
        g.line(-half, 0, i, half, 0, i);
        g.line(i, 0, -half, i, 0, half);
      }
      g.noStroke();
      g.pop();
    }

    function drawModule(g, t, mod, wire = false) {
      const {gx, gz, footprint} = t;
      g.push();
      const baseX = (gx - GRID/2) * CELL;
      const baseZ = (gz - GRID/2) * CELL;
      const y = -mod.y * CELL; // WEBGL up is -Y
      g.translate(baseX + mod.offset * 4, y - (mod.h*CELL)/2, baseZ);

      const w = footprint * CELL + mod.extrude * 10;
      const d = footprint * CELL + mod.extrude * 10;
      const h = mod.h * CELL;

      if (wire) {
        g.noFill();
        g.stroke(200);
        g.box(w, h, d);
        g.noStroke();
      } else {
        const tone = (mod.y / 2 | 0) % 2 === 0 ? PALETTE.concrete : PALETTE.darker;
        g.ambientMaterial(tone[0], tone[1], tone[2]);
        g.box(w, h, d);
      }
      g.pop();

      if (t.renderStairs) {
        g.push();
        const coreW = Math.max(CELL * 0.6, (t.stairSide * CELL) * 0.8);
        const coreD = coreW;
        const baseX2 = (t.gx - GRID/2) * CELL;
        const baseZ2 = (t.gz - GRID/2) * CELL;
        const y2 = -((mod.y) * CELL);
        g.translate(baseX2, y2 - (mod.h*CELL)/2, baseZ2);
        if (wire) {
          g.noFill();
          g.stroke(180);
          g.box(coreW, mod.h*CELL*0.95, coreD);
          g.noStroke();
        } else {
          g.ambientMaterial(PALETTE.accent[0], PALETTE.accent[1], PALETTE.accent[2]);
          g.specularMaterial(180);
          g.box(coreW, mod.h*CELL*0.95, coreD);
        }
        g.pop();
      }
    }

    function drawBridge(g, bridge, wire = false) {
      const { a, b, y } = bridge;
      const x1 = (a.gx - GRID/2) * CELL;
      const z1 = (a.gz - GRID/2) * CELL;
      const x2 = (b.gx - GRID/2) * CELL;
      const z2 = (b.gz - GRID/2) * CELL;
      const midx = (x1 + x2) / 2;
      const midz = (z1 + z2) / 2;
      const len = dist(x1, z1, x2, z2);

      g.push();
      g.translate(midx, -y * CELL, midz);
      const ang = Math.atan2(x2 - x1, z2 - z1);
      g.rotateY(ang);
      if (wire) {
        g.noFill();
        g.stroke(200);
        g.box(len, BRIDGE_THICK, BRIDGE_THICK * 1.4);
        g.noStroke();
      } else {
        g.ambientMaterial(120, 120, 120);
        g.box(len, BRIDGE_THICK, BRIDGE_THICK * 1.4);
      }
      g.pop();
    }

    function applyViewTransform(g, which, zoomVal) {
      // Common centering and zoom
      g.translate(0, 200, -200);
      g.scale(zoomVal);
      if (which === 'iso') {
        g.rotateX(-35.264 * Math.PI/180);
        g.rotateY(45 * Math.PI/180);
      } else if (which === 'free') {
        g.rotateX(freeRotX);
        g.rotateY(freeRotY);
      } else if (which === 'side') {
        g.rotateY(Math.PI/2);
      } else if (which === 'top') {
        g.rotateX(Math.PI/2);
      }
    }

    function renderPane(g, whichView, wire, zoomVal) {
      g.push();
      g.background(PALETTE.sky[0], PALETTE.sky[1], PALETTE.sky[2]);
      g.ambientLight(120);
      g.directionalLight(200, 200, 200, 0.3, -0.6, -0.2);

      applyViewTransform(g, whichView, zoomVal);
      drawGround(g, wire);
      drawGrid(g);

      for (const t of towers) for (const m of t.modules) drawModule(g, t, m, wire);
      for (const br of bridges) drawBridge(g, br, wire);

      drawGoal(g);
      drawBots(g, wire);

      g.pop();
    }

    function draw() {
      const P = params();
      wireLeft = P.wireLeft; wireRight = P.wireRight;

      // Simulate
      stepBots();

      // Render both panes
      renderPane(leftPG,  P.leftView,  wireLeft,  zoomLeft);
      renderPane(rightPG, P.rightView, wireRight, zoomRight);

      // Composite to main canvas
      background(12);
      image(leftPG,  0,        0, width/2, height);
      image(rightPG, width/2,  0, width/2, height);

      // Divider
      stroke(32);
      line(width/2, 0, width/2, height);
      noStroke();
    }

    // -------- Export (fix projection so it's not tiny) ----------
    function setExportProjection(g, refW, refH){
      // Keep perceived scale matching the left pane when canvas is 10Ã— larger
      const W = g.width, H = g.height;
      const fov0 = Math.PI/3;              // p5 default
      const tan0 = Math.tan(fov0/2);
      const tanPrime = (H / refH) * tan0;  // scale with height ratio
      const fovPrime = 2 * Math.atan(tanPrime);
      g.perspective(fovPrime, W / H, 0.1, 10000);
    }

    function exportTrailsLeftHiRes(){
      const P = params();
      const SCALE = 10;
      const W = Math.floor(width/2) * SCALE;
      const H = height * SCALE;
      const g = createGraphics(W, H, WEBGL);
      g.clear();               // transparent PNG
      g.pixelDensity(1);       // avoid device pixel ratio surprises

      // Match projection and model-view to left pane
      setExportProjection(g, leftPG.width, leftPG.height);
      if (g.resetMatrix) g.resetMatrix();
      applyViewTransform(g, P.leftView, zoomLeft);

      // Draw only trails
      g.push();
      g.noFill();
      if (g.strokeWeight) g.strokeWeight(1 * SCALE); // preserve apparent thickness
      for (const b of bots){
        if (!b.trail || b.trail.length < 2) continue;
        g.stroke(b.color[0], b.color[1], b.color[2], 255);
        for (let i=1;i<b.trail.length;i++){
          const p0=b.trail[i-1], p1=b.trail[i];
          g.line(p0.x, p0.y - CELL*0.3, p0.z, p1.x, p1.y - CELL*0.3, p1.z);
        }
      }
      g.pop();

      g.save('trails_left_x10_'+seed+'.png');
    }

    // -------- Tests ----------
    function runTests() {
      const P = params();
      const lines = [];

      // Every tower should have â‰¥1 incident bridge when bridges are enabled
      let okB = true;
      if (P.bridgesOn) {
        for (const t of towers) {
          const incident = bridges.some(br => br.a === t || br.b === t);
          if (!incident) okB = false;
        }
      }
      lines.push(`A/bridges: ${P.bridgesOn ? (okB ? 'âœ“ all towers connected' : 'âœ— some towers unconnected') : 'â€” (disabled)'}`);

      // Grid bounds
      let okC = true;
      for (const t of towers) {
        if (t.gx < 0 || t.gx >= GRID || t.gz < 0 || t.gz >= GRID || t.maxH > LEVELS) okC = false;
      }
      lines.push(`B/grid-bounds: ${okC ? 'âœ“' : 'âœ— out-of-bounds tower found'}`);

      // Random reachability test
      if (navNodes.length>1){
        const a = pickRandomNode(); const b = pickRandomNode(a);
        const reachable = bfsReachable(a,b);
        lines.push(`C/path(${a}->${b}): ${reachable ? 'âœ“ reachable' : 'âœ— no path'}`);
      }

      const summary = `Tests ${ ((okB || !params().bridgesOn) && okC) ? 'PASSED' : 'HAS ISSUES' }`;
      testPanel().textContent = (SHOW_TESTS ? (summary + '\n' + lines.join('\n')) : '');
      if (SHOW_TESTS) {
        console.clear();
        console.group('Brutalist City â€” Tests');
        console.log(summary);
        for (const ln of lines) console.log(ln);
        console.groupEnd();
      }
    }

    function bfsReachable(src,dst){
      const seen=new Set([src]); const q=[src];
      while(q.length){
        const u=q.shift(); if(u===dst) return true;
        for(const v of navAdj[u]) if(!seen.has(v)){ seen.add(v); q.push(v); }
      }
      return false;
    }
  </script>
</body>
</html>
