<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Brutalist Tower Generator</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #333; /* Dark grey background */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Courier New', Courier, monospace;
            color: #ccc;
        }
        canvas {
            background-color: #D3D3D3; /* Light grey concrete canvas */
            cursor: pointer;
        }
        .info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            font-size: 14px;
            opacity: 0.7;
        }
    </style>
</head>
<body>
    <canvas id="brutalistCanvas"></canvas>
    <div class="info">Click canvas to regenerate</div>

    <script>
        const canvas = document.getElementById('brutalistCanvas');
        const ctx = canvas.getContext('2d');

        // --- CONFIGURATION ---
        const TOWER_WIDTH = 120;
        const MODULE_HEIGHT = 20;
        const PALETTE = {
            structure: '#5A5A5A',
            detail: '#444444',
            window: '#222222',
            bridge: '#686868',
            sky: '#B0B0B0'
        };

        // Resize canvas to fit window
        function resizeCanvas() {
            canvas.width = window.innerWidth * 0.9;
            canvas.height = window.innerHeight * 0.9;
            drawScene();
        }

        // --- MODULAR PREFABS ---
        // These are the prefabricated modules that will be combined.
        const modules = [
            // Module 1: Solid Concrete Slab
            (x, y) => {
                ctx.fillStyle = PALETTE.structure;
                ctx.fillRect(x, y, TOWER_WIDTH, MODULE_HEIGHT);
                ctx.strokeStyle = PALETTE.detail;
                ctx.strokeRect(x, y, TOWER_WIDTH, MODULE_HEIGHT);
            },
            // Module 2: Single Center Window
            (x, y) => {
                modules[0](x, y); // Draw base slab first
                ctx.fillStyle = PALETTE.window;
                ctx.fillRect(x + TOWER_WIDTH / 2 - 10, y + 5, 20, MODULE_HEIGHT - 10);
            },
            // Module 3: Row of Slit Windows
            (x, y) => {
                modules[0](x, y);
                ctx.fillStyle = PALETTE.window;
                const windowWidth = 8;
                const gap = 12;
                for (let i = 0; i < 5; i++) {
                    ctx.fillRect(x + gap + i * (windowWidth + gap) - 5, y + 6, windowWidth, MODULE_HEIGHT - 12);
                }
            },
            // Module 4: Overhang / Cantilevered Section
            (x, y) => {
                const overhang = 20;
                ctx.fillStyle = PALETTE.structure;
                ctx.fillRect(x - overhang, y, TOWER_WIDTH + overhang * 2, MODULE_HEIGHT);
                ctx.strokeStyle = PALETTE.detail;
                ctx.strokeRect(x - overhang, y, TOWER_WIDTH + overhang * 2, MODULE_HEIGHT);
            },
            // Module 5: Open Structural Floor
            (x, y) => {
                ctx.fillStyle = PALETTE.sky; // See through
                ctx.fillRect(x, y, TOWER_WIDTH, MODULE_HEIGHT);

                ctx.fillStyle = PALETTE.structure;
                // Pillars
                ctx.fillRect(x, y, TOWER_WIDTH * 0.2, MODULE_HEIGHT);
                ctx.fillRect(x + TOWER_WIDTH * 0.8, y, TOWER_WIDTH * 0.2, MODULE_HEIGHT);
                // Top beam
                ctx.fillRect(x, y, TOWER_WIDTH, MODULE_HEIGHT * 0.25);
            }
        ];

        // --- COMBINATORIAL ASSEMBLY ---

        /**
         * Builds a tower at a given x position with a specified number of floors.
         * @param {number} x - The x-coordinate for the tower's left edge.
         * @param {number} floorCount - The number of modules to stack.
         * @returns {Array} An array of y-coordinates for each floor level.
         */
        function buildTower(x, floorCount) {
            const floorLevels = [];
            for (let i = 0; i < floorCount; i++) {
                const y = canvas.height - (i + 1) * MODULE_HEIGHT;
                const randomModule = modules[Math.floor(Math.random() * modules.length)];
                randomModule(x, y);
                floorLevels.push(y);
            }
            return floorLevels;
        }

        /**
         * Draws a bridge between two tower locations at a specific height.
         * @param {number} x1 - Start x-coordinate.
         * @param {number} x2 - End x-coordinate.
         * @param {number} y - The y-coordinate (height) of the bridge.
         */
        function drawBridge(x1, x2, y) {
            const bridgeHeight = 8;
            ctx.fillStyle = PALETTE.bridge;
            ctx.strokeStyle = PALETTE.detail;
            
            const startX = Math.min(x1, x2) + TOWER_WIDTH;
            const endX = Math.max(x1, x2);
            
            ctx.fillRect(startX, y + MODULE_HEIGHT / 2 - bridgeHeight / 2, endX - startX, bridgeHeight);
            ctx.strokeRect(startX, y + MODULE_HEIGHT / 2 - bridgeHeight / 2, endX - startX, bridgeHeight);

            // Simple support detail
            ctx.beginPath();
            ctx.moveTo(startX, y + MODULE_HEIGHT / 2 + bridgeHeight / 2);
            ctx.lineTo(startX + 10, y + MODULE_HEIGHT / 2 + bridgeHeight / 2 + 5);
            ctx.moveTo(endX, y + MODULE_HEIGHT / 2 + bridgeHeight / 2);
            ctx.lineTo(endX - 10, y + MODULE_HEIGHT / 2 + bridgeHeight / 2 + 5);
            ctx.stroke();
        }

        // --- SCENE DRAWING ---
        function drawScene() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = PALETTE.sky;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const towerData = [];

            // Generate several towers
            const numTowers = 5;
            for (let i = 0; i < numTowers; i++) {
                const x = (canvas.width / (numTowers + 1)) * (i + 1) - TOWER_WIDTH / 2 + (Math.random() - 0.5) * 50;
                const floorCount = Math.floor(10 + Math.random() * (canvas.height / MODULE_HEIGHT - 15));
                const floorLevels = buildTower(x, floorCount);
                towerData.push({ x, floorLevels });
            }

            // Draw bridges between towers
            for (let i = 0; i < towerData.length - 1; i++) {
                // Draw 1 or 2 bridges to the next tower
                const numBridges = Math.random() > 0.6 ? 2 : 1;
                for (let j = 0; j < numBridges; j++) {
                    const towerA = towerData[i];
                    const towerB = towerData[i + 1];

                    // Find a common floor level to connect
                    const commonLevels = towerA.floorLevels.filter(y => towerB.floorLevels.includes(y));
                    if (commonLevels.length > 0) {
                        const bridgeY = commonLevels[Math.floor(Math.random() * commonLevels.length)];
                        drawBridge(towerA.x, towerB.x, bridgeY);
                    }
                }
            }
        }

        // --- INITIALIZATION and EVENT LISTENERS ---
        window.addEventListener('resize', resizeCanvas);
        canvas.addEventListener('click', drawScene);
        
        resizeCanvas(); // Initial draw
    </script>
</body>
</html>
