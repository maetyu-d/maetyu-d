<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<title>Heston's Head (Roguelike Prototype)</title>
<style>
  :root{
    --neon-1:#ff00e6; --neon-2:#00ffe1; --neon-3:#ffd400; --neon-4:#7aff00; --neon-5:#4f61ff;
  }
  @keyframes bgshift{
    0%{ background-position:0% 50%; filter:hue-rotate(0deg) saturate(135%); }
    50%{ background-position:100% 50%; filter:hue-rotate(180deg) saturate(160%); }
    100%{ background-position:0% 50%; filter:hue-rotate(360deg) saturate(135%); }
  }
  html, body { height:100%; margin:0; color:#e6e6e6; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
  body{ background:linear-gradient(120deg, rgba(255,0,230,.16), rgba(0,255,225,.16), rgba(255,212,0,.16)) no-repeat fixed; background-size:400% 400%; animation:bgshift 18s linear infinite; }
  #ui { position: fixed; inset: 0; display: grid; grid-template-columns: 440px 1fr; }
  #sidebar { padding: 12px 14px; border-right: 1px solid #1b1f24; background:rgba(10,14,18,.75); backdrop-filter: blur(6px); overflow:auto; box-shadow: inset 0 0 0 1px rgba(140,255,200,.06); }
  #sidebar h1 { margin: 0 0 8px; font-size: 16px; letter-spacing: .5px; color:#b8ffdc; text-shadow:0 0 6px rgba(184,255,220,.35); }
  #sidebar .card { background:rgba(8,12,15,.75); border:1px solid rgba(18,22,26,.9); border-radius: 12px; padding: 10px 12px; margin-bottom: 10px; box-shadow: 0 0 0 1px rgba(10,13,16,.8) inset, 0 10px 30px rgba(0,0,0,.25); }
  .k { display:inline-block; padding:2px 6px; border:1px solid #2a3138; border-radius:6px; background:#0d1216; color:#d0e2ff; font-size:12px; margin-right:6px }
  .pill { display:inline-block; font-size:11px; padding:2px 6px; border-radius:999px; border:1px solid #2a3138; margin:2px 4px 0 0 }
  .pill.gift { color:#c8ffd6; border-color:#294236; background:#0e1811 }
  .pill.curse{ color:#ffd0d0; border-color:#442828; background:#1a0f0f }
  .btn { border:1px solid #26323c; background:#0f151a; color:#cfe7ff; border-radius:8px; padding:6px 10px; cursor:pointer; }

  #canvasWrap { position: relative; filter:saturate(1.4) contrast(1.15) drop-shadow(0 0 20px rgba(255,255,255,.04)); }
  #c { display:block; width:100%; height:100%; image-rendering: pixelated; }
  #overlay { position:absolute; left:16px; bottom:16px; background:rgba(0,0,0,0.5); border:1px solid #1a2128; padding:8px 10px; border-radius:8px; font-size:12px; box-shadow:0 0 10px rgba(0,0,0,.4), 0 0 16px rgba(0,255,255,.15) inset }
  #toast { position: absolute; top: 16px; left: 50%; transform: translateX(-50%); background: linear-gradient(135deg, rgba(0,0,0,.75), rgba(20,20,30,.75)); color: #d6ffe9; border: 1px solid #22303a; padding: 10px 14px; border-radius: 10px; opacity: 0; transition: opacity .25s ease; pointer-events:none; text-shadow:0 0 6px rgba(184,255,220,.35) }

  /* Minimap */
  #mini { position:absolute; right:16px; top:16px; width:192px; height:120px; image-rendering: pixelated; border:1px solid #1a2128; background:#07090b; border-radius:8px; box-shadow: 0 6px 18px rgba(0,0,0,.45), 0 0 20px rgba(255,0,230,.18) inset; }

  /* Interlude modal */
  #interlude { position:absolute; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,0.55); backdrop-filter: blur(2px); }
  #interlude .panel { width: min(780px, 92%); background:#0b0f12; border:1px solid #232a31; border-radius:16px; box-shadow: 0 20px 60px rgba(0,0,0,.45); padding:16px; }
  #interlude h2 { margin: 0 0 6px; font-size: 16px; color:#ffe58f; text-shadow:0 0 8px rgba(255, 229, 143, .35); }
  #interlude .sub { color:#9fb0be; font-size:12px; margin-bottom:10px }
  #interlude .opts { display:grid; grid-template-columns: 1fr; gap:8px; }
  #interlude .opt { border:1px solid #1f262d; background:#0e1317; border-radius:12px; padding:10px; cursor:pointer; }
  #interlude .opt:hover { border-color:#2b3844; background:#10171c; }
  #interlude .opt .name { font-weight:600; }
  #interlude .opt .who { font-size:12px; color:#9fb0be; margin-top:2px }
  #interlude .opt .flavor { font-size:12px; color:#c7c7c7; margin-top:6px }
  #interlude .hint { font-size:11px; color:#8aa0b0; margin-top:10px }

  /* Assembly Zach-like */
  #assembly { position:absolute; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,0.6); backdrop-filter: blur(3px); }
  #assembly .panel { width:min(1040px,96%); background:#0b0f12; border:1px solid #232a31; border-radius:16px; box-shadow:0 20px 60px rgba(0,0,0,.5); padding:16px; }
  #assembly h3 { margin:0 0 6px; font-size:15px; color:#cfe7ff; text-shadow:0 0 8px rgba(207,231,255,.35); }
  #asmToolbar { display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin:8px 0; }
  .tool { display:flex; align-items:center; gap:6px; border:1px solid #1e262e; background:#0e1317; border-radius:10px; padding:6px 8px; cursor:pointer; user-select:none; box-shadow:0 0 0 1px rgba(0,0,0,.35) inset; }
  .tool.sel { outline:1px solid #cfe7ff; box-shadow:0 0 12px rgba(143,255,200,.25); }
  .badge { font-size:11px; color:#9fb0be; padding:2px 6px; border:1px solid #28313a; border-radius:999px; }
  #asmCanvas { display:block; width:100%; height:auto; background:radial-gradient(80% 80% at 50% 50%, rgba(12,16,20,1), rgba(6,8,10,1)); border:1px solid #1f2931; border-radius:12px; image-rendering: pixelated; box-shadow: inset 0 0 30px rgba(0,0,0,.55), 0 0 24px rgba(255,0,230,.15); }
  #assembly .hint { font-size:11px; color:#8aa0b0; margin-top:10px }

  /* Origami plating */
  #origami { position:absolute; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,.55); backdrop-filter: blur(2px); }
  #origami .panel { width:min(760px,95%); background:#0b0f12; border:1px solid #232a31; border-radius:16px; box-shadow:0 20px 60px rgba(0,0,0,.45); padding:16px; }
  #origami h3 { margin:0 0 6px; font-size:15px; color:#ffe58f; }
  #origami .sub { color:#9fb0be; font-size:12px; margin-bottom:8px }
  #origami .bar { display:flex; gap:8px; margin-top:8px }
  #origami canvas { display:block; width:100%; height:auto; border:1px solid #1f2931; border-radius:12px; background:radial-gradient(90% 90% at 50% 50%, #0f1418, #090c0f); box-shadow: inset 0 0 30px rgba(0,0,0,.55), 0 0 24px rgba(255,0,230,.12); }

  /* Extra Psychedelic mode */
  body.melt { filter: saturate(2.3) contrast(1.45); }
  body.melt #canvasWrap { filter: saturate(2.0) hue-rotate(75deg) contrast(1.2) drop-shadow(0 0 30px rgba(255,0,230,.25)); }
  body.melt #mini { box-shadow: 0 6px 18px rgba(0,0,0,.45), 0 0 30px rgba(255,0,230,.35) inset; }

  /* Buff HUD */
  #buffHUD { position:absolute; right:16px; bottom:16px; width:230px; background:rgba(8,12,15,.72); border:1px solid #1a2128; border-radius:10px; padding:8px 10px; box-shadow:0 10px 30px rgba(0,0,0,.35), inset 0 0 20px rgba(0,255,225,.08); }
  #buffHUD .row { display:flex; align-items:center; gap:8px; margin:3px 0; }
  #buffHUD .lbl { width:70px; font-size:12px; color:#cfe7ff; }
  #buffHUD .bar { position:relative; flex:1; height:6px; background:#0a0f12; border:1px solid #1b2229; border-radius:999px; overflow:hidden; }
  #buffHUD .fill { height:100%; width:0%; background:linear-gradient(90deg, #b8ffdc, rgba(255,255,255,.25)); }
  #buffHUD .t { width:38px; text-align:right; font-size:11px; color:#9fb0be; }
</style>
</head>
<body>
  <div id="ui">
    <aside id="sidebar">
      <h1>Heston's Head (Roguelike Prototype)</h1>

      <div class="card">
        <div style="font-weight:600; margin-bottom:6px; color:#cfe7ff">Controls</div>
        <div><span class="k">WASD</span>Move <span class="k">Mouse</span> Use tool  <span class="k">Q/E</span> Brush −/+</div>
        <div style="margin-top:6px"><span class="k">1</span>Foam  <span class="k">2</span>Gel Precursor  <span class="k">3</span>Spheres</div>
        <div style="margin-top:6px"><span class="k">T</span>Heat  <span class="k">Y</span>Cool  <span class="k">U</span>Stir/Shear  <span class="k">I</span>pH Drop  <span class="k">Z</span>Activate Colony  <span class="k">X</span>Interact</div>
        <div style="margin-top:6px"><span class="k">F</span>Serve at Station  <span class="k">R</span>New Run  <span class="k">4/5/6</span>Choose Gift/Curse  <span class="k">M</span>Psychedelia++  <span class="k">N</span>Minimap  <span class="k">G</span>Grid</div>
      </div>

      <div class="card">
        <div style="font-weight:600; margin-bottom:6px; color:#cfe7ff">Goals</div>
        <div id="goals"></div>
      </div>

      <div class="card">
        <div style="font-weight:600; margin-bottom:6px; color:#cfe7ff">Hazards</div>
        <div id="hazards"></div>
      </div>

      <div class="card">
        <div style="font-weight:600; margin-bottom:6px; color:#cfe7ff">Hidden Depths</div>
        <div id="depthList" style="font-size:12px; color:#9fb0be"></div>
      </div>

      <div class="card">
        <div style="font-weight:600; margin-bottom:6px; color:#cfe7ff">Serving</div>
        <div id="serving"></div>
        <div id="lastDish" style="margin-top:8px; font-size:12px; color:#cfe7ff"></div>
      </div>

      <div class="card">
        <div style="font-weight:600; margin-bottom:6px; color:#cfe7ff">Service — In His Head</div>
        <div id="narrCourse" style="margin-bottom:6px"></div>
        <div id="narrMood" style="margin-bottom:6px"></div>
        <div style="font-weight:600; margin-top:6px; color:#cfe7ff">Gifts & Curses</div>
        <div id="mutations"></div>
      </div>

      <div class="card">
        <div style="font-weight:600; margin-bottom:6px; color:#cfe7ff">Colonies (hidden)</div>
        <div id="colonies"></div>
      </div>

      <div class="card">
        <div style="font-weight:600; margin-bottom:6px; color:#cfe7ff">Diagnostics (self-tests)</div>
        <div id="tests" style="font-size:12px; line-height:1.4; color:#9fb0be"></div>
        <div style="margin-top:8px"><button id="runTestsBtn">Run self-tests</button></div>
      </div>
    </aside>

    <main id="canvasWrap">
      <canvas id="c"></canvas>
      <canvas id="mini"></canvas>
      <div id="overlay">Tool: <span id="toolName">Heat</span> • Brush: <span id="brush">3</span></div>
      <div id="toast"></div>

      <!-- Interlude -->
      <div id="interlude">
        <div class="panel">
          <h2 id="interTitle">Course Interlude</h2>
          <div class="sub" id="interSub">Alien reviewers murmur across the synapses. A choice arrives.</div>
          <div class="opts" id="interOpts"></div>
          <div class="hint">Choose with <span class="k">4</span>/<span class="k">5</span>/<span class="k">6</span> or click</div>
        </div>
      </div>

      <!-- Assembly (Zach-like) -->
      <div id="assembly">
        <div class="panel">
          <h3 id="asmTitle">Assemble Equipment</h3>
          <div class="sub" id="asmSub" style="color:#9fb0be; font-size:12px">
            Route the flow: Feed + Brine + Aroma → Chill → Vacuum → Condense → Outlet (Pressure≥30).
            Fans boost pressure & drafts; Dampers reduce. Valves are one-way. Heaters inject warmth flag.
          </div>
          <div id="asmToolbar">
            <div class="tool" data-type="pipe"><span>Pipe</span><span class="badge" id="inv_pipe">24</span></div>
            <div class="tool" data-type="elbow"><span>Elbow</span><span class="badge" id="inv_elbow">14</span></div>
            <div class="tool" data-type="tee"><span>T-Junction</span><span class="badge" id="inv_tee">8</span></div>
            <div class="tool" data-type="cross"><span>Crossover</span><span class="badge" id="inv_cross">4</span></div>
            <div class="tool" data-type="fan"><span>Fan</span><span class="badge" id="inv_fan">2</span></div>
            <div class="tool" data-type="damper"><span>Damper</span><span class="badge" id="inv_damper">2</span></div>
            <div class="tool" data-type="heater"><span>Heater</span><span class="badge" id="inv_heater">1</span></div>
            <div class="tool" data-type="valve"><span>Check Valve</span><span class="badge" id="inv_valve">4</span></div>
            <div class="tool" data-type="chill"><span>Chiller</span><span class="badge" id="inv_chill">1</span></div>
            <div class="tool" data-type="vacuum"><span>Vacuum</span><span class="badge" id="inv_vacuum">1</span></div>
            <div class="tool" data-type="condense"><span>Condenser</span><span class="badge" id="inv_condense">1</span></div>
            <div class="tool" data-type="eraser"><span>Erase</span></div>
            <span style="flex:1"></span>
            <button class="btn" id="asmRotate">Rotate ↻ <span class="badge" id="asmOri">→</span></button>
            <button class="btn" id="asmRun">Run</button>
            <button class="btn" id="asmClear">Clear</button>
            <button class="btn" id="asmClose">Exit (X)</button>
          </div>
          <canvas id="asmCanvas" width="960" height="560"></canvas>
          <div class="hint">Left-click: place • Right-click: rotate cell • <span class="k">Del</span>: erase cell • All feeds must merge <u>before</u> Condense • Outlet needs enough pressure.</div>
        </div>
      </div>

      <!-- Origami plating -->
      <div id="origami">
        <div class="panel">
          <h3>Plating — Origami Fold</h3>
          <div class="sub">Rotate wedges to form symmetry. Higher symmetry → bigger plating bonus. Your pickups add motifs.</div>
          <canvas id="origamiCanvas" width="720" height="420"></canvas>
          <div class="bar">
            <button class="btn" id="origamiRotate">Rotate Random Wedge</button>
            <button class="btn" id="origamiAuto">Auto-fold (safe)</button>
            <button class="btn" id="origamiPlate">Plate Dish</button>
            <div id="origamiScore" style="margin-left:auto; color:#cfe7ff">Score: 0%</div>
          </div>
        </div>
      </div>

      <!-- Visual toggles -->
      <div class="card" style="position:absolute; left:16px; top:16px; background:rgba(8,12,15,.7); padding:6px 8px; border-radius:10px; border:1px solid rgba(18,22,26,.9); display:flex; gap:8px; align-items:center;">
        <span style="font-size:12px; color:#cfe7ff">Visuals</span>
        <button class="btn" id="meltBtn">Psychedelia++: OFF</button>
        <button class="btn" id="gridToggle">Grid: ON</button>
        <button class="btn" id="miniToggle">Minimap: ON</button>
      </div>

      <!-- Buff HUD -->
      <div id="buffHUD" aria-label="Ingredient Buffs HUD" style="display:none">
        <div class="row"><span class="lbl">Agar</span><div class="bar"><div class="fill" id="hud_agar"></div></div><span class="t" id="hud_agar_t"></span></div>
        <div class="row"><span class="lbl">Lecithin</span><div class="bar"><div class="fill" id="hud_lecithin"></div></div><span class="t" id="hud_lecithin_t"></span></div>
        <div class="row"><span class="lbl">CaCl₂</span><div class="bar"><div class="fill" id="hud_cacl2"></div></div><span class="t" id="hud_cacl2_t"></span></div>
      </div>
    </main>
  </div>

<script>
(() => {
  // ---------- World & Rendering ----------
  const W = 96, H = 60, SCALE = 12;
  const canvas = document.getElementById('c');
  canvas.width = W * SCALE; canvas.height = H * SCALE;
  const ctx = canvas.getContext('2d');

  const mini = document.getElementById('mini');
  mini.width = W; mini.height = H; // 1:1 grid → CSS scales
  const mctx = mini.getContext('2d');

  let gridVisible = true; // toggle with G or button
  function drawGrid(){
    ctx.save();
    ctx.globalAlpha = 0.18;
    ctx.strokeStyle = 'rgba(200,220,255,0.12)';
    ctx.lineWidth = 1;
    for(let x=0;x<=W;x++){
      ctx.beginPath();
      ctx.moveTo(x*SCALE,0);
      ctx.lineTo(x*SCALE,H*SCALE);
      ctx.stroke();
    }
    for(let y=0;y<=H;y++){
      ctx.beginPath();
      ctx.moveTo(0,y*SCALE);
      ctx.lineTo(W*SCALE,y*SCALE);
      ctx.stroke();
    }
    ctx.restore();
  }

  // ---------- Fog of War ----------
  const VISION_BASE = 12; // cells
  function VR(){ return VISION_BASE + mods.visionBonus; }
  let seen = new Uint8Array(W*H); // 0 unseen, 1 seen
  function idx(x,y){ return x + y*W; }
  function inb(x,y){ return x>=0 && y>=0 && x<W && y<H; }
  function revealAt(x0,y0,r){
    const r2=r*r;
    for(let y=-r;y<=r;y++) for(let x=-r;x<=r;x++){
      if(x*x+y*y<=r2){
        const xx=(x0|0)+x, yy=(y0|0)+y;
        if(inb(xx,yy)) seen[idx(xx,yy)]=1;
      }
    }
  }

  // ---------- Materials ----------
  // 0..1 fields
  const foam = new Float32Array(W*H);        // insulates both hazards, medium decay
  const precursor = new Float32Array(W*H);   // paintable, converts → gel
  const gel = new Float32Array(W*H);         // formed gradually, slows motion

  // ---------- Player ----------
  let player = {x: Math.round(W/2), y: Math.round(H/2), fx: W/2, fy: H/2, health: 100, alive:true};
  const keys = new Set();
  const mouse = {x:0, y:0, down:false};
  let currentTool='heat';
  const toolNames = {heat:'Heat', cool:'Cool', shear:'Stir/Shear', ph:'pH Drop', foam:'Foam', gel:'Gel Precursor', spheres:'Spheres'};
  let brush=3; // cells
  function updateOverlay(){
    document.getElementById('toolName').textContent = toolNames[currentTool] || currentTool;
    document.getElementById('brush').textContent = brush;
  }

  // ---------- Hazards & Systems ----------
  let goals=[];          // visit points
  let hazards=[];        // heat / acid / collapse
  let colonies=[];       // hidden meta nodes
  let spheres=[];        // neutralising beads

  // Ingredient pickups
  let ingredients=[]; // {x,y,type:'agar'|'lecithin'|'cacl2', picked:false}
  const buffs={ agar:0, lecithin:0, cacl2:0 };
  const BUFF_MAXS={ agar:60, lecithin:60, cacl2:60 };
  let pendingTraits=[]; // for plating motifs

  // Hidden Depths
  let secrets=[]; // {type:'crystal'|'modifier'|'equipment', x,y, revealed:false, state:{...}, id?:string}
  const scoreMods = { warmthShift:0, brightnessShift:0, textureShift:0, aerationShift:0, widen:1.0 };

  // Serving
  let servingStation = null; // {x,y,r}
  let dishes = []; let lastDish=null; let pendingDishEval=null;

  // Story / Narrative
  const COURSE_TITLES = [
    'Nitro-Poached Aperitif','Snail Porridge','Sound of the Sea','Hot & Iced Tea','Mock Turtle Consommé','Bacon & Egg Ice Cream','Counting Sheep'
  ];
  let story = { course:1, mood:0.5, title: COURSE_TITLES[0] };

  // Gifts/Curses (mutations)
  const mods = { acidDrift:1, heatJitter:1, foamMitigation:1, sphereRate:1, visionBonus:0, gelSlow:1, collapseRate:1, coolVsHeat:1 };
  let activeMutations = [];
  const MUTATIONS = {
    gift_rotavap: { name:'Rotavap Whisper', type:'gift', who:'The Sommelier From Beyond', flavor:'Glass coil condenses regrets into clarity. Acidity flows softer.', apply(){ mods.acidDrift *= 0.85; } },
    gift_nitro_poacher: { name:'Nitro Poacher', type:'gift', who:'The Nitrogen Jester', flavor:'Frost blooms in your palm. Cooling tool bites deeper.', apply(){ mods.coolVsHeat *= 1.35; } },
    gift_pacojet_pulse: { name:'Pacojet Pulse', type:'gift', who:'The Chorus of Oysters', flavor:'Microblades sing. Your spheres persist and work harder.', apply(){ mods.sphereRate *= 1.4; } },
    gift_isi_siphon: { name:'ISI Siphon Hymn', type:'gift', who:'Childhood Memory of Bacon & Egg Ice Cream', flavor:'A siphon coughs out impossible air. Foam shelters more.', apply(){ mods.foamMitigation *= 1.25; } },
    gift_white_rabbit: { name:'White Rabbit Watch', type:'gift', who:'The Mad Hatter', flavor:'Time bends; vision widens at the edges of thought.', apply(){ mods.visionBonus += 3; } },
    curse_doom_bell: { name:'Front-of-House Doom Bell', type:'curse', who:'Clockwork Waiter', flavor:'The bell tolls too often. Collapses ripple through service.', apply(){ mods.collapseRate *= 1.8; } },
    curse_reviewer_breath: { name:"Reviewer's Breath", type:'curse', who:'The Reviewers', flavor:'They lean in, their breath ionised. Acids grow restless.', apply(){ mods.acidDrift *= 1.25; } },
    curse_quantum_oven: { name:'Quantum Oven', type:'curse', who:'The Snail Oracle', flavor:'Heat exists in two places at once and neither is kind.', apply(){ mods.heatJitter *= 1.35; } },
    curse_gel_failure: { name:'Set Too Soon', type:'curse', who:'Unseen Commis', flavor:'Gel clutches greedily; slowing is fickle unless thick.', apply(){ mods.gelSlow *= 0.8; } }
  };
  function mutationPill(id){ const m=MUTATIONS[id]; const cls='pill '+(m.type==='gift'?'gift':'curse'); return `<span class="${cls}">${m.name}</span>`; }

  // Reviewer Gaze Cones
  const gazes=[
    {x: W*0.25, y:H*0.35, ang: Math.random()*Math.PI*2, speed:0.5,  arc:0.75, len:18},
    {x: W*0.70, y:H*0.55, ang: Math.random()*Math.PI*2, speed:-0.35, arc:0.6,  len:22},
    {x: W*0.50, y:H*0.25, ang: Math.random()*Math.PI*2, speed:0.42, arc:0.5,  len:16},
  ];

  // Aroma Drafts (vector field) + arrows
  let time = 0;
  let assemblyFlow = { fanVec:{x:0,y:0}, damper:0, heater:0, pressureBonus:0 };
  function draftAt(x,y){
    const s1 = Math.sin((y*0.12)+time*0.6)*0.4;
    const s2 = Math.cos((x*0.08)-time*0.45)*0.25;
    let vx = s2 + assemblyFlow.fanVec.x*0.8;
    let vy = s1 + assemblyFlow.fanVec.y*0.8;
    const damp = 1/(1+0.4*assemblyFlow.damper);
    return [vx*damp, vy*damp];
  }

  // ---------- UI panels ----------
  function renderGoalsList(){
    const box=document.getElementById('goals'); box.innerHTML='';
    goals.forEach((g,i)=>{ const div=document.createElement('div'); div.textContent=`Goal ${i+1}: visit (${g.x},${g.y}) ${g.done?'✓':''}`; div.style.color=g.done?'#9f9':'#fff'; box.appendChild(div); });
  }
  function renderHazardsList(){
    const box=document.getElementById('hazards'); box.innerHTML='';
    hazards.forEach((h)=>{ if(h.dead) return; const div=document.createElement('div');
      div.textContent=`${h.type}${h.ttl?'/collapse':''} @ (${Math.round(h.x)},${Math.round(h.y)}) s:${h.strength.toFixed(1)} r:${h.radius.toFixed(1)}`;
      div.style.color=h.type==='heat'?'#f66':(h.type==='acid'?'#6cf':'#e6b3ff');
      box.appendChild(div);
    });
  }
  function renderColoniesList(){
    const box=document.getElementById('colonies'); box.innerHTML='';
    colonies.forEach((c,i)=>{ const div=document.createElement('div'); div.textContent=`Colony ${i+1}: ${c.activated?'activated':(c.revealed?'revealed':'hidden')}`; div.style.color=c.activated?'#b8ffdc':(c.revealed?'#cfe7ff':'#7a8694'); box.appendChild(div); });
  }
  function updateNarrativePanel(){
    const c = document.getElementById('narrCourse');
    c.innerHTML = `Course <b>${story.course}</b>: ${story.title}`;
    const moodTxt = story.mood<0.3? 'hostile' : story.mood<0.5? 'skeptical' : story.mood<0.7? 'intrigued' : 'rapt';
    const moodBar = `<div style="height:6px; background:#0a0f12; border:1px solid #1b2229; border-radius:6px; overflow:hidden;"><div style="height:100%; width:${Math.round(story.mood*100)}%; background:linear-gradient(90deg,#9fe7b9,#b8ffdc)"></div></div>`;
    document.getElementById('narrMood').innerHTML = `Reviewers: <b>${moodTxt}</b><br/>${moodBar}`;
    document.getElementById('mutations').innerHTML = activeMutations.map(mutationPill).join('');
  }
  function updateDepthsPanel(){
    const box=document.getElementById('depthList');
    box.innerHTML = secrets.filter(s=>s.revealed).map(s=>{
      const n = s.type==='crystal'? 'Unstable Crystal' : s.type==='modifier'? 'Palate Thread' : s.type==='equipment'? (s.id==='rotavap'?'Rotavap Coil':'Chef Gadget') : '???';
      const st = s.type==='crystal' ? (s.state?.stabilised? 'stabilised' : 'unstable') : s.type==='modifier' ? (s.state?.claimed? 'attuned' : 'latent') : s.type==='equipment' ? (s.state?.built? 'built' : 'broken') : '';
      return `<div>• ${n} @ (${s.x},${s.y}) — <span style="color:#cfe7ff">${st}</span></div>`;
    }).join('') || '<div>Explore to discover hidden sites…</div>';
  }
  function renderServingPanel(){
    const box=document.getElementById('serving'); if(!box) return;
    const traits = pendingTraits.length? ` — motifs: <span style="color:#b8ffdc">${pendingTraits.join(', ')}</span>` : '';
    if(!servingStation){
      box.innerHTML = allGoalsComplete() ? 'Station: <span style="color:#b8ffdc">preparing…</span>' : 'Station: <span style="color:#9fb0be">Locked — complete all goals</span>';
    } else {
      box.innerHTML = `Station at (<b>${servingStation.x}</b>,<b>${servingStation.y}</b>) — enter ring & press <span class="k">F</span>${traits}`;
    }
    const last = document.getElementById('lastDish');
    if(lastDish){
      last.innerHTML = `Last Dish → Score: <b>${(lastDish.score*100|0)}%</b><br/>Warmth ${pct(lastDish.warmth)} • Brightness ${pct(lastDish.brightness)}<br/>Texture ${pct(lastDish.texture)} • Aeration ${pct(lastDish.aeration)}<br/>Plating bonus: ${(Math.round(((lastDish.platingBonus||1)-1)*100))}%`;
    } else last.textContent = 'No dish served yet.';
  }

  // ---------- Toast ----------
  function showToast(msg, duration=1200){
    const t = document.getElementById('toast'); if(!t){ console.log('[toast]', msg); return; }
    t.textContent = String(msg); t.style.opacity = 1;
    clearTimeout(t._to); t._to = setTimeout(()=>{ t.style.opacity = 0; }, duration);
  }

  // ---------- Helpers ----------
  function pct(v){ return Math.round(v*100)+'%'; }
  function clamp01(v){ return Math.max(0, Math.min(1, v)); }
  function paintCircle(field, x0, y0, r, amount){
    const r2=r*r, xi=Math.floor(x0), yi=Math.floor(y0);
    for(let y=-r;y<=r;y++) for(let x=-r;x<=r;x++){
      if(x*x+y*y<=r2){ const xx=xi+x, yy=yi+y; if(inb(xx,yy)){ const i=idx(xx,yy); field[i]=Math.min(1, field[i]+amount); } }
    }
  }
  function averageField(field, x0, y0, r=3){
    const r2=r*r; let acc=0, n=0; const xi=Math.floor(x0), yi=Math.floor(y0);
    for(let y=-r;y<=r;y++) for(let x=-r;x<=r;x++){
      if(x*x+y*y<=r2){ const xx=xi+x, yy=yi+y; if(inb(xx,yy)){ acc += field[idx(xx,yy)]; n++; } }
    }
    return n? acc/n : 0;
  }
  function sampleField(field, x, y){
    const xi=Math.max(0,Math.min(W-1, Math.floor(x)));
    const yi=Math.max(0,Math.min(H-1, Math.floor(y)));
    return field[idx(xi,yi)];
  }

  // ---------- Goals / Serving ----------
  function allGoalsComplete(){ return goals.length>0 && goals.every(g=>g.done); }
  function maybeSpawnServingStation(){
    if(servingStation || !allGoalsComplete()) return;
    servingStation = { x: Math.floor(W/2 + (Math.random()-0.5)*10), y: Math.floor(H/2 + (Math.random()-0.5)*8), r: 5 };
    showToast('Serving station is open — press F inside the ring!');
    renderServingPanel();
  }

  function fieldContributionAt(type, x0, y0){
    let s=0; hazards.forEach(h=>{ if(!h.dead && h.type===type){ const dx=x0-h.x, dy=y0-h.y; s += h.strength/(1+dx*dx+dy*dy); }});
    return s;
  }
  const TARGETS = { warmth: [0.4, 0.7], brightness: [0.2, 0.5], texture: [0.3, 0.8], aeration: [0.1, 0.6] };
  function evaluateDishAt(x0,y0){
    const heat = fieldContributionAt('heat', x0, y0);
    const acid = fieldContributionAt('acid', x0, y0);
    const warmth = clamp01(0.5*heat + scoreMods.warmthShift);
    const brightness = clamp01(0.5*acid + scoreMods.brightnessShift);
    const texture = clamp01(averageField(gel, x0, y0, 4) + scoreMods.textureShift);
    const aeration = clamp01(averageField(foam, x0, y0, 4) + scoreMods.aerationShift);
    const widen = scoreMods.widen || 1;
    const cs = (v,[lo,hi])=>{ lo=clamp01(lo); hi=clamp01(hi); if(v>=lo&&v<=hi) return 1; const d=v<lo?lo-v:v-hi; return clamp01(1 - d/(0.3*widen)); };
    const sw=cs(warmth,TARGETS.warmth), sb=cs(brightness,TARGETS.brightness), st=cs(texture,TARGETS.texture), sa=cs(aeration,TARGETS.aeration);
    const score=(sw+sb+st+sa)/4;
    return { warmth, brightness, texture, aeration, score };
  }
  function updateMood(score){ story.mood = clamp01(story.mood + (score-0.5)*0.35); updateNarrativePanel(); }

  function attemptServe(){
    if(!servingStation){ showToast('Station not ready'); return false; }
    const dx=player.x-servingStation.x, dy=player.y-servingStation.y;
    if(dx*dx+dy*dy > servingStation.r*servingStation.r){ showToast('Step into the ring to serve'); return false; }
    const m = evaluateDishAt(servingStation.x, servingStation.y);
    pendingDishEval = m;
    openOrigami();
    return true;
  }

  // ---------- Damage ----------
  function hazardDPSAt(x,y){
    let dps=0;
    hazards.forEach(h=>{
      if(h.dead) return;
      const r=(h.radius*h.strength) + Math.sin(h.phase)*2;
      const dx=x-h.x, dy=y-h.y;
      if(dx*dx+dy*dy<r*r){
        if(h.type==='heat') dps += 10*h.strength;
        else if(h.type==='acid') dps += 15*h.strength;
        else if(h.type==='collapse') dps += 25;
      }
    });
    return dps;
  }
  function inGazeFactor(x,y){
    let f=0;
    gazes.forEach(g=>{
      const dx=x-g.x, dy=y-g.y; const d=Math.hypot(dx,dy); if(d>g.len) return;
      const ang=Math.atan2(dy,dx); let a=(ang-g.ang+Math.PI*2)%(Math.PI*2); if(a>Math.PI) a-=Math.PI*2;
      if(Math.abs(a) <= g.arc*0.5){ f = Math.max(f, 1 - d/g.len); }
    });
    return f;
  }
  function effectiveDPSAt(x,y){
    const base = hazardDPSAt(x,y);
    const f = sampleField(foam,x,y); // foam mitigates both
    let mult = 1 + 0.35*inGazeFactor(x,y); // reviewer gaze amplifies
    const g = sampleField(gel,x,y); // gel dulls a bit
    const dull = Math.max(0, 1 - (0.5*f + 0.25*g));
    mult = 1 + (mult-1)*dull;
    return base * (1 - 0.6*mods.foamMitigation*f) * mult;
  }
  let damageFlash = 0;
  function takeDamage(amount){
    player.health -= amount;
    if(player.health<0) player.health=0;
    damageFlash = Math.min(1, damageFlash + amount*0.02);
    if(player.health<=0 && player.alive){ player.alive=false; showToast('You perished in the dish!'); reset(); }
  }

  // ---------- Swirl ----------
  let swirlPhase = 0; function swirlCenter(){ swirlPhase += 0.2/60; const cx = W/2 + Math.cos(swirlPhase)*6; const cy = H/2 + Math.sin(swirlPhase)*4; return {cx, cy}; }

  // ---------- Hazard update ----------
  function updateGazes(dt){ gazes.forEach(g=>{ g.ang += g.speed*dt; }); }

  function updateHazards(dt){
    const {cx, cy} = swirlCenter();
    hazards.forEach(h=>{
      if(h.dead) return; h.phase += dt; if(h.splitCd>0) h.splitCd = Math.max(0, h.splitCd - dt);
      const [dvx,dvy] = draftAt(h.x,h.y);

      if(h.type==='acid'){
        // swirl around center & drift with drafts, slow if gel present
        const rx = h.x - cx, ry = h.y - cy; const dist = Math.hypot(rx, ry) + 1e-6;
        const tx = -ry/dist, ty = rx/dist;
        const g = sampleField(gel, h.x, h.y);
        const slowA = 1 - (0.3*mods.gelSlow)*g;
        const slowV = 1 - (0.5*mods.gelSlow)*g;
        let swirlAccel = (1.2 * slowA) / (1 + 0.05*dist);
        swirlAccel *= mods.acidDrift;
        h.vx = (h.vx||0) + tx * swirlAccel * dt + dvx*0.8*dt;
        h.vy = (h.vy||0) + ty * swirlAccel * dt + dvy*0.8*dt;
        h.vx = h.vx*0.985*slowV + (Math.random()-0.5)*0.02;
        h.vy = h.vy*0.985*slowV + (Math.random()-0.5)*0.02;
        h.x += h.vx * dt * 12; h.y += h.vy * dt * 12;
      }
      else if(h.type==='heat'){
        // jitter (convective “jitter”), lightly bent by drafts
        h.vx = (h.vx||0) + (Math.random()-0.5) * (1.2*mods.heatJitter) * dt + dvx*0.5*dt;
        h.vy = (h.vy||0) + (Math.random()-0.5) * (1.2*mods.heatJitter) * dt + dvy*0.5*dt;
        const vmax = 1.5; const sp = Math.hypot(h.vx,h.vy); if(sp>vmax){ h.vx*=vmax/sp; h.vy*=vmax/sp; }
        h.vx *= 0.9; h.vy *= 0.9;
        h.x += h.vx * dt * 6; h.y += h.vy * dt * 6;
      }
      else if(h.type==='collapse'){
        h.ttl -= dt; h.radius = Math.max(1.5, h.radius - 6*dt); if(h.ttl<=0) h.dead=true;
      }

      // bounds
      if(h.x<0){ h.x=0; h.vx*=-0.6; } if(h.x>W-1){ h.x=W-1; h.vx*=-0.6; }
      if(h.y<0){ h.y=0; h.vy*=-0.6; } if(h.y>H-1){ h.y=H-1; h.vy*=-0.6; }

      if(h.strength<=0.01) h.dead=true;
    });

    // Unstable crystals emit collapses
    secrets.forEach(s=>{
      if(s.type==='crystal' && s.revealed && !s.state.stabilised){
        if(Math.random() < dt*0.25){
          hazards.push({ x: s.x + (Math.random()-0.5)*3, y: s.y + (Math.random()-0.5)*3, type:'collapse', radius:6, phase:0, strength:1, splitCd:0, vx:0, vy:0, ttl:1.6, dead:false });
        }
      }
    });

    // Coalescence (merge acid pools)
    const merged = coalesceHazards();

    // Random collapses as pressure builds
    if(Math.random() < dt * 0.02 * mods.collapseRate){
      const base = hazards.find(z=>!z.dead) || {x:W/2,y:H/2};
      hazards.push({ x: Math.max(2,Math.min(W-3, base.x + (Math.random()-0.5)*10)), y: Math.max(2,Math.min(H-3, base.y + (Math.random()-0.5)*8)), type:'collapse', radius:8, phase:0, strength:1, splitCd:0, vx:0, vy:0, ttl:2.0, dead:false });
    }

    if(merged || (hazards.length>0 && Math.random()<0.05)){ hazards = hazards.filter(h=>!h.dead); renderHazardsList(); }
  }

  function coalesceHazards(){
    let changed=false;
    for(let i=0;i<hazards.length;i++){
      const a=hazards[i]; if(!a||a.dead||a.type!=='acid') continue;
      for(let j=i+1;j<hazards.length;j++){
        const b=hazards[j]; if(!b||b.dead||b.type!=='acid') continue;
        const dx=b.x-a.x, dy=b.y-a.y; const dist2=dx*dx+dy*dy;
        const ra=(a.radius*a.strength), rb=(b.radius*b.strength);
        const thresh=Math.min(ra,rb)*0.9;
        if(dist2 <= thresh*thresh){
          const areaA=a.radius*a.radius, areaB=b.radius*b.radius;
          const mA=areaA*a.strength, mB=areaB*b.strength, mT=mA+mB+1e-6;
          const nx=(a.x*mA+b.x*mB)/mT, ny=(a.y*mA+b.y*mB)/mT;
          const nvx=((a.vx||0)*mA + (b.vx||0)*mB)/mT, nvy=((a.vy||0)*mA + (b.vy||0)*mB)/mT;
          const nradius=Math.min(12, Math.sqrt(areaA+areaB));
          const nstrength=Math.max(0.2, Math.min(2.0, (mT/(areaA+areaB+1e-6))));
          a.x=nx; a.y=ny; a.vx=nvx; a.vy=nvy; a.radius=nradius; a.strength=nstrength; a.splitCd=Math.max(a.splitCd||0,0.3);
          b.dead=true; changed=true;
        }
      }
    }
    return changed;
  }

  function splitHazard(h){
    const parts = 2 + Math.floor(Math.random()*2);
    const baseR = Math.max(2, h.radius * 0.6);
    const baseS = Math.max(0.4, h.strength * 0.6);
    for(let i=0;i<parts;i++){
      const ang = Math.random()*Math.PI*2;
      const off = baseR * (0.7 + Math.random()*0.6);
      let nx = h.x + Math.cos(ang)*off;
      let ny = h.y + Math.sin(ang)*off;
      nx = Math.max(0, Math.min(W-1, nx));
      ny = Math.max(0, Math.min(H-1, ny));
      const pvx = h.vx||0, pvy = h.vy||0;
      const theta = (Math.random()-0.5) * (Math.PI/6);
      const cosT = Math.cos(theta), sinT = Math.sin(theta);
      const ivx = pvx*cosT - pvy*sinT, ivy = pvx*sinT + pvy*cosT;
      const speedScale = 0.8 + Math.random()*0.4;
      hazards.push({ x:nx, y:ny, type:h.type, radius: baseR * (0.9 + Math.random()*0.3), phase: Math.random()*Math.PI*2, strength: baseS * (0.8 + Math.random()*0.4), splitCd: 0.6 + Math.random()*0.4, vx: ivx*speedScale + (Math.random()-0.5)*0.05, vy: ivy*speedScale + (Math.random()-0.5)*0.05, ttl:null, dead:false });
    }
    h.dead = true;
  }

  // ---------- Materials update ----------
  function updateMaterials(dt){
    // Foam decay (medium), boosted by lecithin buff
    const decay = 0.03 * dt * (1-0.15*buffs.lecithin);
    for(let i=0;i<foam.length;i++){ foam[i]=Math.max(0, foam[i]-decay); }

    // Gel formation: precursor → gel gradually, catalysed by acid/heat
    for(let y=0;y<H;y++) for(let x=0;x<W;x++){
      const i=idx(x,y);
      let acidField=0, heatField=0;
      hazards.forEach(h=>{
        if(h.dead) return;
        const dx=x-h.x, dy=y-h.y; const d2=dx*dx+dy*dy;
        const w= h.strength/(1+d2);
        if(h.type==='acid') acidField += w;
        else if(h.type==='heat') heatField += w;
      });
      if(precursor[i]>0){
        const rate = (0.5*acidField + 0.2*heatField) * dt * (1+0.3*buffs.agar);
        const d = Math.min(precursor[i], rate);
        precursor[i] -= d; gel[i] = Math.min(1, gel[i] + d);
      }
    }
  }

  // ---------- Spheres ----------
  function spawnSpheres(x0,y0){
    const n = Math.max(1, Math.floor(brush/3));
    for(let i=0;i<n;i++){
      const jitter=(Math.random()-0.5)*(brush*0.6);
      spheres.push({ x:x0+jitter, y:y0+jitter, vx:0, vy:0, life:8.0, r:2.2 });
    }
  }
  function updateSpheres(dt){
    const {cx, cy} = swirlCenter();
    spheres.forEach(s=>{
      const [dvx,dvy] = draftAt(s.x,s.y);
      const rx=s.x-cx, ry=s.y-cy; const dist=Math.hypot(rx,ry)+1e-6;
      const tx=-ry/dist, ty=rx/dist; const accel=1.0/(1+0.05*dist);
      s.vx += (tx*accel + dvx*0.6) * dt;
      s.vy += (ty*accel + dvy*0.6) * dt;
      s.vx *= 0.985; s.vy *= 0.985;
      s.x += s.vx * dt * 12; s.y += s.vy * dt * 12;

      if(s.x<0){s.x=0; s.vx*=-0.4;} if(s.x>W-1){s.x=W-1; s.vx*=-0.4;}
      if(s.y<0){s.y=0; s.vy*=-0.4;} if(s.y>H-1){s.y=H-1; s.vy*=-0.4;}

      let interacting=false;
      hazards.forEach(h=>{
        if(h.dead || h.type!=='acid') return;
        const dx=s.x-h.x, dy=s.y-h.y;
        const r=h.radius*h.strength + Math.sin(h.phase)*2;
        if(dx*dx+dy*dy < (r+2)*(r+2)){
          h.strength = Math.max(0, h.strength - (0.15*mods.sphereRate*(1+0.2*buffs.cacl2))*dt);
          interacting=true;
        }
      });
      s.life -= (0.15 + (interacting?0.35:0))*dt; // keeps neutralising until dissolve
    });
    spheres = spheres.filter(s=>s.life>0);
  }

  // ---------- Spawn world ----------
  function spawnIngredients(){
    for(let i=0;i<4;i++){
      const t = (['agar','lecithin','cacl2'])[i%3];
      ingredients.push({ x:Math.floor(Math.random()*W), y:Math.floor(Math.random()*H), type:t, picked:false });
    }
  }
  function applyIngredient(type){
    buffs[type] = Math.min(BUFF_MAXS[type], buffs[type] + 25);
    pendingTraits.push(type==='agar'?'lattice':type==='lecithin'?'foam motif':'pearls');
    showToast(`Picked ${type}!`);
    renderBuffHUD();
  }
  function spawnSecrets(){
    // A crystal
    secrets.push({ type:'crystal', x:Math.floor(Math.random()*W), y:Math.floor(Math.random()*H), revealed:false, state:{stabilised:false} });
    // A palate modifier
    secrets.push({ type:'modifier', x:Math.floor(Math.random()*W), y:Math.floor(Math.random()*H), revealed:false, state:{claimed:false} });
    // Equipment site
    secrets.push({ type:'equipment', id:'rotavap', x:Math.floor(Math.random()*W), y:Math.floor(Math.random()*H), revealed:false, state:{built:false} });
  }

  // ---------- Reset / New run ----------
  function resetFieldsAndWorld(){
    seen.fill(0); foam.fill(0); precursor.fill(0); gel.fill(0); spheres.length=0; secrets.length=0; ingredients.length=0; pendingTraits.length=0; pendingDishEval=null;
    goals=[]; hazards=[]; colonies=[]; servingStation=null; lastDish=null;

    for(let i=0;i<3;i++) goals.push({x:Math.floor(Math.random()*W), y:Math.floor(Math.random()*H), done:false});

    for(let i=0;i<6;i++){
      const type = Math.random()<0.5?'heat':'acid';
      hazards.push({ x:Math.floor(Math.random()*W), y:Math.floor(Math.random()*H), type, radius: 4 + Math.random()*4, phase: Math.random()*Math.PI*2, strength: 1.0, splitCd: 0, vx: type==='acid' ? (Math.random()-0.5)*0.6 : 0, vy: type==='acid' ? (Math.random()-0.5)*0.6 : 0, ttl: null, dead:false });
    }
    for(let i=0;i<4;i++) colonies.push({ x:Math.floor(Math.random()*W), y:Math.floor(Math.random()*H), revealed:false, activated:false });

    spawnIngredients();
    spawnSecrets();

    renderGoalsList(); renderHazardsList(); renderColoniesList(); renderServingPanel(); updateOverlay(); updateNarrativePanel(); updateDepthsPanel();
  }
  function reset(){
    player = {x: Math.round(W/2), y: Math.round(H/2), fx: W/2, fy: H/2, health: 100, alive:true};
    story = {course:1, mood:0.5, title: COURSE_TITLES[0]};
    activeMutations = [];
    Object.assign(mods,{ acidDrift:1, heatJitter:1, foamMitigation:1, sphereRate:1, visionBonus:0, gelSlow:1, collapseRate:1, coolVsHeat:1 });
    Object.assign(scoreMods,{ warmthShift:0, brightnessShift:0, textureShift:0, aerationShift:0, widen:1.0 });
    Object.assign(buffs,{agar:0,lecithin:0,cacl2:0});
    assemblyFlow={fanVec:{x:0,y:0}, damper:0, heater:0, pressureBonus:0};
    resetFieldsAndWorld();
    renderBuffHUD();
    openInterlude(true); // gift/curse at start
  }
  function nextCourse(){
    story.course++; story.title = COURSE_TITLES[(story.course-1) % COURSE_TITLES.length];
    player.health = Math.min(100, player.health + 20);
    resetFieldsAndWorld(); showToast(`Course ${story.course}: ${story.title}`);
    openInterlude(true);
  }

  // ---------- Tools ----------
  function applyToolAt(x0,y0){
    x0=Math.round(x0); y0=Math.round(y0);
    if(inInterlude||inAssembly) return;
    const R = brush;

    if(currentTool==='foam'){ paintCircle(foam, x0, y0, R, 0.35*(1+0.25*buffs.lecithin)); return; }
    if(currentTool==='gel'){ paintCircle(precursor, x0, y0, R, 0.35*(1+0.3*buffs.agar)); return; }
    if(currentTool==='spheres'){ spawnSpheres(x0,y0); return; }

    // Interact with hazards
    hazards.forEach(h=>{
      if(h.dead) return;
      const dx=h.x-x0, dy=h.y-y0; const dist=Math.hypot(dx,dy);
      if(dist <= R + h.radius){
        if(currentTool==='cool' && h.type==='heat'){
          h.strength = Math.max(0, h.strength - 0.25*mods.coolVsHeat);
          h.radius = Math.max(2, h.radius - 0.2*mods.coolVsHeat);
        } else if(currentTool==='heat' && h.type==='heat'){
          h.strength = Math.min(2.0, h.strength + 0.2);
          h.radius = Math.min(12, h.radius + 0.15);
        } else if(currentTool==='ph' && h.type==='acid'){
          const mult = (1+0.3*buffs.cacl2);
          h.strength = Math.max(0, h.strength - 0.35*mult);
          h.radius = Math.max(2, h.radius - 0.25*mult);
        } else if(currentTool==='shear' && h.type==='acid'){
          const bigEnough = (h.radius*h.strength) > 6 && (h.splitCd||0)<=0;
          if(bigEnough){ splitHazard(h); }
        }
      }
    });
  }

  // ---------- Input ----------
  let miniVisible = true;
  function updateGridButton(){ const b=document.getElementById('gridToggle'); if(b) b.textContent = `Grid: ${gridVisible?'ON':'OFF'}`; }
  function toggleGrid(){ gridVisible = !gridVisible; updateGridButton(); showToast(`Grid: ${gridVisible?'ON':'OFF'}`); }

  document.addEventListener('keydown', (e)=>{
    if(e.repeat) return;
    const k=e.key.toLowerCase();
    if(inAssembly){
      if(k==='x'){ closeAssembly(); }
      return;
    }
    if(inInterlude){
      if(k==='4'||k==='5'||k==='6'){ chooseInterludeByKey(k); }
      return;
    }

    if(k==='w'||k==='a'||k==='s'||k==='d') keys.add(k);
    if(k==='q'){ brush=Math.max(1, brush-1); updateOverlay(); }
    if(k==='e'){ brush=Math.min(12, brush+1); updateOverlay(); }

    if(k==='1') { currentTool='foam'; updateOverlay(); }
    if(k==='2') { currentTool='gel'; updateOverlay(); }
    if(k==='3') { currentTool='spheres'; updateOverlay(); }
    if(k==='t') { currentTool='heat'; updateOverlay(); }
    if(k==='y') { currentTool='cool'; updateOverlay(); }
    if(k==='u') { currentTool='shear'; updateOverlay(); }
    if(k==='i') { currentTool='ph'; updateOverlay(); }

    if(k==='m'){ document.body.classList.toggle('melt'); showToast(`Psychedelia++: ${document.body.classList.contains('melt')?'ON':'OFF'}`); }
    if(k==='n'){ miniVisible = !miniVisible; mini.style.display = miniVisible?'block':'none'; showToast(`Minimap: ${miniVisible?'ON':'OFF'}`); }
    if(k==='g'){ toggleGrid(); }
    if(k==='f'){ attemptServe(); }
    if(k==='r'){ reset(); }
    if(k==='z'){ activateNearestColony(); }
    if(k==='x'){ interactAtPlayer(); }
  });
  document.addEventListener('keyup', (e)=>{ const k=e.key.toLowerCase(); keys.delete(k); });

  canvas.addEventListener('mousemove', (e)=>{
    const rect=canvas.getBoundingClientRect();
    mouse.x = Math.max(0, Math.min(W-1, (e.clientX-rect.left)/SCALE));
    mouse.y = Math.max(0, Math.min(H-1, (e.clientY-rect.top)/SCALE));
    if(mouse.down) applyToolAt(mouse.x, mouse.y);
  });
  canvas.addEventListener('mousedown', ()=>{ mouse.down=true; applyToolAt(mouse.x, mouse.y); });
  window.addEventListener('mouseup', ()=>{ mouse.down=false; });

  document.getElementById('meltBtn').addEventListener('click', ()=>{ document.body.classList.toggle('melt'); showToast(`Psychedelia++: ${document.body.classList.contains('melt')?'ON':'OFF'}`); });
  document.getElementById('miniToggle').addEventListener('click', ()=>{ miniVisible=!miniVisible; mini.style.display=miniVisible?'block':'none'; showToast(`Minimap: ${miniVisible?'ON':'OFF'}`); });
  document.getElementById('gridToggle').addEventListener('click', toggleGrid); updateGridButton();

  // ---------- Movement (grid-snapped) ----------
  function movePlayer(dt){
    if(inInterlude||inAssembly) return;
    const sp=10*dt;
    let dx=0,dy=0; if(keys.has('w')) dy-=sp; if(keys.has('s')) dy+=sp; if(keys.has('a')) dx-=sp; if(keys.has('d')) dx+=sp;

    player.fx = Math.max(0, Math.min(W-1, (player.fx ?? player.x) + dx));
    player.fy = Math.max(0, Math.min(H-1, (player.fy ?? player.y) + dy));
    player.x  = Math.max(0, Math.min(W-1, Math.round(player.fx)));
    player.y  = Math.max(0, Math.min(H-1, Math.round(player.fy)));

    revealAt(player.x, player.y, VR());

    colonies.forEach(c=>{
      if(!c.revealed){
        const ddx=c.x-player.x, ddy=c.y-player.y;
        if(ddx*ddx+ddy*ddy <= VR()*VR()) { c.revealed=true; renderColoniesList(); showToast('You discovered a colony'); }
      }
    });
    secrets.forEach(s=>{
      if(!s.revealed){
        const dx=s.x-player.x, dy=s.y-player.y;
        if(dx*dx+dy*dy <= (VR()*VR())){ s.revealed=true; updateDepthsPanel(); showToast('You uncovered something…'); }
      }
    });
    ingredients.forEach(it=>{
      if(it.picked) return;
      const dx=it.x-player.x, dy=it.y-player.y;
      if(dx*dx+dy*dy <= 4 && seen[idx(it.x,it.y)]){ it.picked=true; applyIngredient(it.type); }
    });
    goals.forEach(g=>{ if(!g.done && Math.abs(player.x-g.x)<1 && Math.abs(player.y-g.y)<1){ g.done=true; showToast('Goal reached!'); renderGoalsList(); }});
    if(allGoalsComplete()) maybeSpawnServingStation();

    const dps = effectiveDPSAt(player.x, player.y); if(dps>0) takeDamage(dps*dt);
  }

  function activateNearestColony(){
    const c = colonies.find(c=>c.revealed && !c.activated && Math.hypot(c.x-player.x, c.y-player.y)<=2.5);
    if(!c){ showToast('No colony nearby'); return; }
    c.activated=true; renderColoniesList(); showToast('Colony activated');
    // reward: small buff or reveal
    if(Math.random()<0.5){ mods.visionBonus += 1; } else { buffs.lecithin = Math.min(BUFF_MAXS.lecithin, buffs.lecithin+15); renderBuffHUD(); }
  }

  function interactAtPlayer(){
    // interact with secrets
    const s = secrets.find(s=>s.revealed && Math.hypot(s.x-player.x, s.y-player.y)<=2.5);
    if(s){
      if(s.type==='crystal' && !s.state.stabilised){ s.state.stabilised=true; updateDepthsPanel(); showToast('Crystal stabilised'); }
      else if(s.type==='modifier' && !s.state.claimed){ s.state.claimed=true; scoreMods.widen *= 1.12; updateDepthsPanel(); showToast('Palate thread attuned'); }
      else if(s.type==='equipment' && !s.state.built){ openAssembly(s); }
      return;
    }
    showToast('Nothing to interact with');
  }

  // ---------- Visual helpers ----------
  function drawBrushRing(){
    const gx=Math.round(mouse.x), gy=Math.round(mouse.y);
    const color = currentTool==='heat'  ? 'hsl(20,100%,60%)'
               : currentTool==='cool'  ? 'hsl(195,100%,65%)'
               : currentTool==='shear' ? 'hsl(55,100%,70%)'
               : currentTool==='ph'    ? 'hsl(300,100%,65%)'
               : currentTool==='foam'  ? 'hsl(190,100%,70%)'
               : currentTool==='gel'   ? 'hsl(140,100%,60%)'
               : currentTool==='spheres' ? 'hsl(0,0%,100%)'
               : 'rgba(184,255,220,0.9)';
    ctx.save(); ctx.strokeStyle=color; ctx.globalAlpha=0.95; ctx.lineWidth=2;
    ctx.beginPath(); ctx.arc((gx+0.5)*SCALE,(gy+0.5)*SCALE,(brush*SCALE)+2,0,Math.PI*2); ctx.stroke();
    ctx.restore();
  }

  function drawDraftArrows(step=8){
    ctx.save();
    ctx.globalAlpha = 0.45;
    for(let y=step/2; y<H; y+=step){
      for(let x=step/2; x<W; x+=step){
        const [vx,vy] = draftAt(x,y);
        const len = Math.min(6, Math.hypot(vx,vy)*10 + 2);
        const ang = Math.atan2(vy,vx);
        const cx = (x+0.5)*SCALE, cy=(y+0.5)*SCALE;
        ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(cx+Math.cos(ang)*len, cy+Math.sin(ang)*len); ctx.strokeStyle='rgba(184,255,220,0.5)'; ctx.stroke();
        // arrowhead
        const a1=ang+2.5, a2=ang-2.5;
        ctx.beginPath(); ctx.moveTo(cx+Math.cos(ang)*len, cy+Math.sin(ang)*len);
        ctx.lineTo(cx+Math.cos(a1)*3, cy+Math.sin(a1)*3);
        ctx.lineTo(cx+Math.cos(a2)*3, cy+Math.sin(a2)*3);
        ctx.closePath(); ctx.fillStyle='rgba(184,255,220,0.5)'; ctx.fill();
      }
    }
    ctx.restore();
  }
  function drawMiniDraftArrows(step=8){
    mctx.save();
    mctx.globalAlpha=0.6;
    for(let y=step/2; y<H; y+=step){
      for(let x=step/2; x<W; x+=step){
        const [vx,vy]=draftAt(x,y);
        const len=Math.min(2, Math.hypot(vx,vy)*3 + 0.6);
        const ang=Math.atan2(vy,vx);
        const cx=x+0.5, cy=y+0.5;
        mctx.beginPath(); mctx.moveTo(cx,cy); mctx.lineTo(cx+Math.cos(ang)*len, cy+Math.sin(ang)*len); mctx.strokeStyle='rgba(184,255,220,0.7)'; mctx.stroke();
      }
    }
    mctx.restore();
  }

  // ---------- Buff HUD ----------
  function renderBuffHUD(){
    const hud=document.getElementById('buffHUD');
    const any = buffs.agar>0 || buffs.lecithin>0 || buffs.cacl2>0;
    hud.style.display = any?'block':'none';
    const set=(k,v)=>{ const pct=Math.round((v/BUFF_MAXS[k])*100); document.getElementById('hud_'+k).style.width = pct+'%'; document.getElementById('hud_'+k+'_t').textContent = v.toFixed(0)+'s'; };
    set('agar',buffs.agar); set('lecithin',buffs.lecithin); set('cacl2',buffs.cacl2);
  }

  // ---------- Interlude (mutations) ----------
  let inInterlude=false; let interOptions=[];
  function openInterlude(initial=false){
    inInterlude=true;
    const el=document.getElementById('interlude'); el.style.display='flex';
    interOptions=[];
    // pick 3 options, mix gifts/curses
    const keys=Object.keys(MUTATIONS); while(interOptions.length<3){
      const k=keys[Math.floor(Math.random()*keys.length)];
      if(!interOptions.includes(k)) interOptions.push(k);
    }
    const box=document.getElementById('interOpts'); box.innerHTML='';
    interOptions.forEach((id,ix)=>{
      const m=MUTATIONS[id];
      const div=document.createElement('div'); div.className='opt'; div.innerHTML=`<div class="name">${m.name}</div><div class="who">${m.who}</div><div class="flavor">${m.flavor}</div>`;
      div.addEventListener('click',()=>chooseInterlude(ix));
      box.appendChild(div);
    });
    document.getElementById('interTitle').textContent = initial ? 'Welcome to Service' : 'Between Courses';
    document.getElementById('interSub').textContent = initial ? 'The pass steams; voices multiply. Choose your edge.' : 'Gifts and curses knock on copper.'
  }
  function chooseInterlude(ix){
    const id=interOptions[ix]; if(!id) return;
    activeMutations.push(id); MUTATIONS[id].apply(); updateNarrativePanel();
    closeInterlude(); showToast(`${MUTATIONS[id].name} applied`);
  }
  function chooseInterludeByKey(k){ const map={'4':0,'5':1,'6':2}; chooseInterlude(map[k]); }
  function closeInterlude(){ inInterlude=false; document.getElementById('interlude').style.display='none'; }

  // ---------- Assembly (Zach-like) ----------
  let inAssembly=false, asmInit=false, assemblyFor=null;
  const asm = { W:14, H:7, CELL:64, tiles:[], inv:null, sel:'pipe', hover:{x:-1,y:-1}, placeRot:0 };
  const asmCanvas = document.getElementById('asmCanvas'), actx = asmCanvas.getContext('2d');

  function openAssembly(s){
    inAssembly=true; document.getElementById('assembly').style.display='flex'; assemblyFor=s;
    if(!asmInit){ initAsm(); asmInit=true; }
    showToast('Assemble the rig. Merge feeds before Condense.');
  }
  function closeAssembly(){ inAssembly=false; document.getElementById('assembly').style.display='none'; }
  function initAsm(){
    asm.tiles = Array.from({length:asm.W*asm.H},()=>({t:'', r:0}));
    asm.inv = { pipe:24, elbow:14, tee:8, cross:4, fan:2, damper:2, heater:1, valve:4, chill:1, vacuum:1, condense:1 };
    // Sources & outlet pinned (not counted)
    asm.sources = [{x:0,y:1,t:'feed'},{x:0,y:3,t:'brine'},{x:0,y:5,t:'aroma'}];
    asm.outlet = {x:asm.W-1, y:Math.floor(asm.H/2)};
    wireAsmUI();
    drawAsm();
  }
  function wireAsmUI(){
    document.querySelectorAll('#asmToolbar .tool').forEach(el=>{
      el.addEventListener('click', ()=>{
        document.querySelectorAll('#asmToolbar .tool').forEach(x=>x.classList.remove('sel'));
        el.classList.add('sel'); asm.sel=el.dataset.type;
      });
    });
    document.getElementById('asmRotate').addEventListener('click', ()=>{ asm.placeRot=(asm.placeRot+1)%4; document.getElementById('asmOri').textContent = ['→','↓','←','↑'][asm.placeRot]; });
    document.getElementById('asmRun').addEventListener('click', runAsm);
    document.getElementById('asmClear').addEventListener('click', ()=>{ initAsm(); });
    document.getElementById('asmClose').addEventListener('click', closeAssembly);
    asmCanvas.addEventListener('contextmenu', e=>e.preventDefault());
    asmCanvas.addEventListener('mousemove', e=>{
      const r=asmCanvas.getBoundingClientRect(); const x=Math.floor((e.clientX-r.left)/asm.CELL); const y=Math.floor((e.clientY-r.top)/asm.CELL);
      asm.hover={x,y}; drawAsm();
    });
    asmCanvas.addEventListener('mousedown', e=>{
      const r=asmCanvas.getBoundingClientRect(); const x=Math.floor((e.clientX-r.left)/asm.CELL); const y=Math.floor((e.clientY-r.top)/asm.CELL);
      if(e.button===2){ rotateAsm(x,y); return; }
      placeAsm(x,y);
    });
    document.addEventListener('keydown', (e)=>{ if(!inAssembly) return; if(e.key==='Delete'){ eraseAsm(asm.hover.x, asm.hover.y); } });
  }
  function aidx(x,y){ return x+y*asm.W; }
  function placeAsm(x,y){
    if(x<=0 || x>=asm.W-1 || y<0 || y>=asm.H) return; // keep edges free for IO
    const cell=asm.tiles[aidx(x,y)];
    if(asm.sel==='eraser'){ cell.t=''; cell.r=0; drawAsm(); return; }
    if(asm.inv[asm.sel]<=0){ showToast('No inventory'); return; }
    cell.t=asm.sel; cell.r=asm.placeRot; asm.inv[asm.sel]--; updateAsmInv(); drawAsm();
  }
  function rotateAsm(x,y){ if(x<0||y<0||x>=asm.W||y>=asm.H) return; const cell=asm.tiles[aidx(x,y)]; if(!cell.t) return; cell.r=(cell.r+1)%4; drawAsm(); }
  function eraseAsm(x,y){ if(x<0||y<0||x>=asm.W||y>=asm.H) return; const cell=asm.tiles[aidx(x,y)]; if(!cell.t) return; asm.inv[cell.t] = (asm.inv[cell.t]||0)+1; cell.t=''; cell.r=0; updateAsmInv(); drawAsm(); }
  function updateAsmInv(){ Object.keys(asm.inv).forEach(k=>{ const el=document.getElementById('inv_'+k); if(el) el.textContent = asm.inv[k]; }); }

  function drawAsm(){
    actx.clearRect(0,0,asmCanvas.width,asmCanvas.height);
    actx.fillStyle='#0e1317'; actx.fillRect(0,0,asmCanvas.width,asmCanvas.height);

    // grid
    actx.strokeStyle='rgba(200,220,255,0.08)';
    for(let x=0;x<=asm.W;x++){ actx.beginPath(); actx.moveTo(x*asm.CELL,0); actx.lineTo(x*asm.CELL,asm.H*asm.CELL); actx.stroke(); }
    for(let y=0;y<=asm.H;y++){ actx.beginPath(); actx.moveTo(0,y*asm.CELL); actx.lineTo(asm.W*asm.CELL,y*asm.CELL); actx.stroke(); }

    // sources & outlet
    asm.sources.forEach(s=>{
      drawAsmCell(s.x,s.y,'source',0,s.t);
    });
    drawAsmCell(asm.outlet.x, asm.outlet.y, 'outlet', 0, 'OUT');

    // tiles
    for(let y=0;y<asm.H;y++) for(let x=0;x<asm.W;x++){
      const c=asm.tiles[aidx(x,y)]; if(!c.t) continue;
      drawAsmCell(x,y,c.t,c.r);
    }

    // hover
    const h=asm.hover; if(h.x>=0 && h.y>=0 && h.x<asm.W && h.y<asm.H){
      actx.strokeStyle='rgba(184,255,220,0.6)'; actx.lineWidth=2;
      actx.strokeRect(h.x*asm.CELL+1, h.y*asm.CELL+1, asm.CELL-2, asm.CELL-2);
    }
  }
  function drawAsmCell(x,y,t,r,label){
    const gx=x*asm.CELL, gy=y*asm.CELL;
    actx.save();
    actx.translate(gx+asm.CELL/2, gy+asm.CELL/2);
    actx.rotate(r*(Math.PI/2));
    actx.translate(-asm.CELL/2, -asm.CELL/2);
    actx.fillStyle='#11171c'; actx.strokeStyle='#21303b';
    actx.fillRect(4,4,asm.CELL-8,asm.CELL-8); actx.strokeRect(4,4,asm.CELL-8,asm.CELL-8);

    actx.lineWidth=6; actx.lineCap='round'; actx.strokeStyle='#78c2ff';

    const drawPipe = (dirs)=>{ // dirs: array of 0:→,1:↓,2:←,3:↑
      dirs.forEach(d=>{
        actx.beginPath();
        const cx=asm.CELL/2, cy=asm.CELL/2;
        const dx = d===0?1:d===2?-1:0; const dy = d===1?1:d===3?-1:0;
        actx.moveTo(cx,cy); actx.lineTo(cx+dx*(asm.CELL/2-10), cy+dy*(asm.CELL/2-10));
        actx.stroke();
      });
    };

    if(t==='source'){
      actx.fillStyle='#21303b'; actx.fillRect(10,10,asm.CELL-20,asm.CELL-20);
      actx.fillStyle='#9fe7b9'; actx.font='12px monospace'; actx.textAlign='center'; actx.fillText(label.toUpperCase(), asm.CELL/2, asm.CELL/2+4);
      drawPipe([0]); // to right
    } else if(t==='outlet'){
      actx.fillStyle='#2f243b'; actx.fillRect(10,10,asm.CELL-20,asm.CELL-20);
      actx.fillStyle='#ffe58f'; actx.font='12px monospace'; actx.textAlign='center'; actx.fillText('OUT', asm.CELL/2, asm.CELL/2+4);
      drawPipe([2]); // from left
    } else if(t==='pipe'){ drawPipe([0,2]); }
    else if(t==='elbow'){ drawPipe([0,3]); }
    else if(t==='tee'){ drawPipe([0,2,3]); }
    else if(t==='cross'){ drawPipe([0,1,2,3]); }
    else if(t==='fan'){ drawPipe([0,2]); actx.fillStyle='#b8ffdc'; actx.beginPath(); actx.arc(asm.CELL/2,asm.CELL/2,8,0,Math.PI*2); actx.fill(); }
    else if(t==='damper'){ drawPipe([0,2]); actx.fillStyle='#9fb0be'; actx.fillRect(asm.CELL/2-8, asm.CELL/2-3, 16,6); }
    else if(t==='heater'){ drawPipe([0,2]); actx.fillStyle='#ff9f7a'; actx.fillRect(asm.CELL/2-7, asm.CELL/2-7, 14,14); }
    else if(t==='valve'){ drawPipe([0,2]); actx.fillStyle='#cfe7ff'; actx.beginPath(); actx.moveTo(asm.CELL/2-6, asm.CELL/2); actx.lineTo(asm.CELL/2+6, asm.CELL/2-6); actx.lineTo(asm.CELL/2+6, asm.CELL/2+6); actx.closePath(); actx.fill(); }
    else if(t==='chill'){ drawPipe([0,2]); actx.fillStyle='#78c2ff'; actx.fillRect(asm.CELL/2-7, asm.CELL/2-7, 14,14); }
    else if(t==='vacuum'){ drawPipe([0,2]); actx.strokeStyle='#ffe58f'; actx.strokeRect(asm.CELL/2-7, asm.CELL/2-7, 14,14); }
    else if(t==='condense'){ drawPipe([0,2]); actx.fillStyle='#ffe58f'; actx.beginPath(); actx.arc(asm.CELL/2,asm.CELL/2,10,0,Math.PI*2); actx.fill(); }
    actx.restore();
  }

  function runAsm(){
    // Simple flow sim: we only verify that paths from FEED, BRINE, AROMA merge before a CONDENSE
    // and reach OUTLET with enough pressure; side effects adjust assemblyFlow.
    const grid = Array.from({length:asm.H},(_,y)=>Array.from({length:asm.W},(_,x)=>({t:'',r:0})));
    for(let y=0;y<asm.H;y++) for(let x=0;x<asm.W;x++){
      const c=asm.tiles[aidx(x,y)]; if(c.t){ grid[y][x]={t:c.t,r:c.r}; }
    }
    asm.sources.forEach(s=>grid[s.y][s.x]={t:s.t,r:0});
    grid[asm.outlet.y][asm.outlet.x]={t:'out',r:0};

    // BFS from sources following pipes; collect flags
    function dirsFor(t,r){
      const rot = (d)=> (d+r)%4;
      if(t==='pipe') return [rot(0),rot(2)];
      if(t==='elbow') return [rot(0),rot(3)];
      if(t==='tee') return [rot(0),rot(2),rot(3)];
      if(t==='cross') return [0,1,2,3].map(rot);
      if(t==='fan') return [rot(0),rot(2)];
      if(t==='damper') return [rot(0),rot(2)];
      if(t==='heater') return [rot(0),rot(2)];
      if(t==='valve') return [rot(0)]; // one-way →
      if(t==='chill') return [rot(0),rot(2)];
      if(t==='vacuum') return [rot(0),rot(2)];
      if(t==='condense') return [rot(0),rot(2)];
      if(t==='source') return [0]; // →
      if(t==='out') return [2]; // ←
      return [];
    }
    const dx=[1,0,-1,0], dy=[0,1,0,-1], opp=[2,3,0,1];

    const visited = Array.from({length:asm.H},()=>Array(asm.W).fill(null));
    let q=[];
    asm.sources.forEach(s=> q.push({x:s.x,y:s.y, feed:s.t==='feed', brine:s.t==='brine', aroma:s.t==='aroma', warm:false, pressure:10}) );

    let passedCondense=false, mergedBeforeCondense=false, reachedOut=false;
    let fanCount=0, damperCount=0, heaterCount=0, vacuumCount=0, chillCount=0;

    while(q.length){
      const cur=q.shift(); const cell=grid[cur.y][cur.x]; if(!cell) continue;
      if(visited[cur.y][cur.x]){
        // merge feeds state
        const v=visited[cur.y][cur.x];
        v.feed = v.feed||cur.feed; v.brine = v.brine||cur.brine; v.aroma=v.aroma||cur.aroma;
        v.warm = v.warm||cur.warm; v.pressure = Math.max(v.pressure, cur.pressure);
      } else visited[cur.y][cur.x] = {...cur};

      if(cell.t==='fan'){ fanCount++; cur.pressure+=8; }
      if(cell.t==='damper'){ damperCount++; cur.pressure=Math.max(0, cur.pressure-5); }
      if(cell.t==='heater'){ heaterCount++; cur.warm=true; }
      if(cell.t==='vacuum'){ vacuumCount++; cur.pressure+=6; }
      if(cell.t==='chill'){ chillCount++; cur.warm=false; }
      if(cell.t==='condense'){
        // check merged inputs
        const v=visited[cur.y][cur.x];
        if(v.feed && v.brine && v.aroma) { passedCondense=true; mergedBeforeCondense=true; }
      }
      if(cell.t==='out'){
        reachedOut=true;
        // need pressure ≥ 30 and passed condense with merged streams
        break;
      }

      const outs = dirsFor(cell.t, cell.r);
      outs.forEach(d=>{
        const nx=cur.x+dx[d], ny=cur.y+dy[d];
        if(nx<0||ny<0||nx>=asm.W||ny>=asm.H) return;
        const nxt=grid[ny][nx];
        if(!nxt || !nxt.t) return;
        const ins = dirsFor(nxt.t, nxt.r);
        if(!ins.includes(opp[d])) return; // must connect
        const state={...cur};
        q.push({x:nx,y:ny, ...state});
      });
    }

    const finalPressure = 10 + fanCount*8 + vacuumCount*6 - damperCount*5 + assemblyFlow.pressureBonus;
    const ok = reachedOut && passedCondense && mergedBeforeCondense && finalPressure>=30;
    if(ok){
      assemblyFlow.fanVec = { x: Math.min(1.5, fanCount*0.15), y: Math.min(1.5, (fanCount-damperCount)*0.1) };
      assemblyFlow.damper = damperCount;
      assemblyFlow.heater = heaterCount;
      assemblyFlow.pressureBonus = finalPressure-10;
      if(assemblyFor){ assemblyFor.state.built=true; updateDepthsPanel(); }
      showToast('Rig online ✓ Drafts boosted');
      closeAssembly();
    } else {
      showToast('Rig invalid — merge feeds before Condense and reach Outlet with ≥30 pressure');
    }
  }

  // ---------- Origami plating ----------
  const origami = { wedges:10, rots:[], motifs:[] };
  const ocan = document.getElementById('origamiCanvas'), octx = ocan.getContext('2d');
  function openOrigami(){
    document.getElementById('origami').style.display='flex';
    origami.rots = Array.from({length:origami.wedges},()=>Math.floor(Math.random()*4));
    origami.motifs = pendingTraits.slice(); // carry motifs
    drawOrigami(); updateOrigamiScore();
  }
  function closeOrigami(){ document.getElementById('origami').style.display='none'; }
  function drawOrigami(){
    const w=ocan.width, h=ocan.height; octx.clearRect(0,0,w,h);
    octx.fillStyle='#0f1418'; octx.fillRect(0,0,w,h);
    const cx=w/2, cy=h/2, R=Math.min(w,h)*0.38;
    for(let i=0;i<origami.wedges;i++){
      const a0=(i/origami.wedges)*Math.PI*2, a1=((i+1)/origami.wedges)*Math.PI*2;
      octx.beginPath(); octx.moveTo(cx,cy); octx.arc(cx,cy,R,a0,a1); octx.closePath();
      const hue=(i*36 + origami.rots[i]*45)%360;
      octx.fillStyle=`hsl(${hue},75%,${55+origami.rots[i]*6}%)`; octx.fill();
      // motif tick
      if(origami.motifs[i%origami.motifs.length]){
        octx.strokeStyle='rgba(255,255,255,.5)'; octx.setLineDash([4,4]); octx.beginPath(); octx.arc(cx,cy,R-10,a0,a1); octx.stroke(); octx.setLineDash([]);
      }
    }
  }
  function symmetryScore(){
    // score by how many opposite wedges match rotation
    let score=0, pairs=0;
    for(let i=0;i<origami.wedges/2;i++){
      const a=origami.rots[i], b=origami.rots[(i+origami.wedges/2)%origami.wedges];
      pairs++; if(a===b) score++;
    }
    return score/pairs;
  }
  function updateOrigamiScore(){
    const s = symmetryScore();
    document.getElementById('origamiScore').textContent = 'Score: ' + Math.round(s*100)+'%';
    return s;
  }
  document.getElementById('origamiRotate').addEventListener('click', ()=>{
    const i=Math.floor(Math.random()*origami.wedges); origami.rots[i]=(origami.rots[i]+1)%4; drawOrigami(); updateOrigamiScore();
  });
  document.getElementById('origamiAuto').addEventListener('click', ()=>{
    // safe: align opposites
    for(let i=0;i<origami.wedges/2;i++){ origami.rots[(i+origami.wedges/2)%origami.wedges]=origami.rots[i]; }
    drawOrigami(); updateOrigamiScore();
  });
  document.getElementById('origamiPlate').addEventListener('click', ()=>{
    const plating = 1 + 0.25*updateOrigamiScore() + 0.05*(pendingTraits.length||0);
    const m = pendingDishEval || evaluateDishAt(servingStation?.x||player.x, servingStation?.y||player.y);
    const finalScore = clamp01(m.score*plating);
    lastDish = {...m, platingBonus:plating, score:finalScore};
    dishes.push(lastDish); updateMood(finalScore); renderServingPanel();
    pendingDishEval=null; pendingTraits.length=0;
    closeOrigami(); nextCourse();
  });

  // ---------- Rendering ----------
  function drawFields(){
    // draw foam and gel as subtle overlays
    for(let y=0;y<H;y++){
      for(let x=0;x<W;x++){
        const i=idx(x,y);
        const f=foam[i], g=gel[i];
        if(f>0){
          ctx.fillStyle=`rgba(180,255,235,${Math.min(0.28, f*0.28)})`;
          ctx.fillRect(x*SCALE,y*SCALE,SCALE,SCALE);
        }
        if(g>0){
          ctx.fillStyle=`rgba(140,255,160,${Math.min(0.25, g*0.25)})`;
          ctx.fillRect(x*SCALE,y*SCALE,SCALE,SCALE);
        }
        if(precursor[i]>0){
          ctx.fillStyle=`rgba(100,160,120,${Math.min(0.15, precursor[i]*0.2)})`;
          ctx.fillRect(x*SCALE,y*SCALE,SCALE,SCALE);
        }
      }
    }
  }
  function drawHazards(){
    hazards.forEach(h=>{
      if(h.dead) return;
      ctx.save();
      let color = h.type==='acid' ? 'rgba(120,200,255,.55)' : h.type==='heat' ? 'rgba(255,120,100,.55)' : 'rgba(220,200,255,.55)';
      ctx.fillStyle=color;
      ctx.beginPath(); ctx.arc((h.x+0.5)*SCALE,(h.y+0.5)*SCALE,(h.radius*SCALE),0,Math.PI*2); ctx.fill();
      ctx.restore();
    });
  }
  function drawPlayer(){
    ctx.save();
    ctx.fillStyle='#fff';
    ctx.fillRect(player.x*SCALE+SCALE*0.25, player.y*SCALE+SCALE*0.25, SCALE*0.5, SCALE*0.5);
    ctx.restore();
  }
  function drawServing(){
    if(!servingStation) return;
    ctx.save();
    ctx.strokeStyle='rgba(255,230,150,0.9)'; ctx.lineWidth=2;
    ctx.beginPath(); ctx.arc((servingStation.x+0.5)*SCALE,(servingStation.y+0.5)*SCALE, servingStation.r*SCALE, 0, Math.PI*2); ctx.stroke();
    ctx.restore();
  }
  function drawSeenFog(){
    ctx.save();
    ctx.fillStyle='rgba(0,0,0,0.72)';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.globalCompositeOperation='destination-out';
    ctx.beginPath();
    for(let y=0;y<H;y++) for(let x=0;x<W;x++){
      if(seen[idx(x,y)]) ctx.fillRect(x*SCALE,y*SCALE,SCALE,SCALE);
    }
    ctx.fill();
    ctx.restore();
  }
  function drawDamageFlash(){
    if(damageFlash<=0) return;
    ctx.save();
    ctx.fillStyle=`rgba(255,60,60,${Math.min(0.35, damageFlash*0.35)})`;
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.restore();
  }
  function drawMini(){
    if(!miniVisible) return;
    // background
    mctx.fillStyle='#050708'; mctx.fillRect(0,0,W,H);
    // seen
    mctx.fillStyle='#0f151a';
    for(let y=0;y<H;y++) for(let x=0;x<W;x++){ if(seen[idx(x,y)]) mctx.fillRect(x,y,1,1); }
    // hazards points
    hazards.forEach(h=>{
      if(h.dead) return;
      mctx.fillStyle = h.type==='acid' ? '#7ec5ff' : h.type==='heat' ? '#ff8f7a' : '#dccbff';
      mctx.fillRect(Math.floor(h.x), Math.floor(h.y), 2, 2);
    });
    // tiny draft arrows
    drawMiniDraftArrows(8);
    // player
    mctx.fillStyle='#fff'; mctx.fillRect(player.x, player.y, 1,1);
  }

  // ---------- Main Loop ----------
  let lastTs=performance.now();
  function tick(now){
    const dt=Math.min(0.05, (now-lastTs)/1000); lastTs=now; time+=dt;

    movePlayer(dt);
    updateGazes(dt);
    updateHazards(dt);
    updateMaterials(dt);
    updateSpheres(dt);

    // decay buffs
    ['agar','lecithin','cacl2'].forEach(k=>{ if(buffs[k]>0){ buffs[k]=Math.max(0, buffs[k]-dt); }});
    renderBuffHUD();

    // render
    ctx.fillStyle='#0a0f12'; ctx.fillRect(0,0,canvas.width,canvas.height);
    if(gridVisible) drawGrid();
    drawFields();
    drawHazards();
    drawDraftArrows(8);
    drawServing();
    drawPlayer();
    drawBrushRing();
    drawSeenFog();
    drawDamageFlash(); damageFlash=Math.max(0, damageFlash - dt*0.8);

    drawMini();

    requestAnimationFrame(tick);
  }

  // ---------- Self-tests ----------
  function appendTestResult(name, ok, extra){
    const t=document.getElementById('tests'); const div=document.createElement('div');
    div.style.color=ok?'#b8ffdc':'#ffb8b8'; div.textContent = (ok?'✓ ':'✗ ')+name + (ok?'':(' — '+(extra||''))); t.appendChild(div);
  }
  function runTests(){
    const t=document.getElementById('tests'); t.innerHTML='';
    try{ appendTestResult('showToast exists', typeof showToast==='function'); }catch(e){ appendTestResult('showToast exists', false, e.message); }
    try{ const was=gridVisible; toggleGrid(); const t1=(gridVisible!==was); toggleGrid(); const t2=(gridVisible===was); appendTestResult('grid toggle flips state', t1 && t2); }catch(e){ appendTestResult('grid toggle flips state', false, e.message); }
    try{ player.fx=10.3; player.fy=20.7; movePlayer(0); appendTestResult('player snaps to grid', Number.isInteger(player.x) && Number.isInteger(player.y)); }catch(e){ appendTestResult('player snaps to grid', false, e.message); }
    try{ const s0=spheres.length; spawnSpheres(20,20); appendTestResult('spawn spheres', spheres.length>s0); }catch(e){ appendTestResult('spawn spheres', false, e.message); }
  }
  document.getElementById('runTestsBtn').addEventListener('click', runTests);

  // ---------- Init ----------
  reset();
  requestAnimationFrame(tick);

})();
</script>
</body>
</html>
