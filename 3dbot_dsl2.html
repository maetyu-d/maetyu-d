<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Procedural Brutalist City Generator â€” 16Ã—16Ã—16</title>
  <style>
    :root{
      --bg:#0c0c0c; --panel:#00000099; --panel-border:#2a2a2a; --text:#e6e6e6; --muted:#a7a7a7;
      --chip:#1a1a1a; --chip-border:#303030; --accent:#8aa6ff;
    }
    html, body { height: 100%; margin: 0; background: var(--bg); color: var(--text); font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    canvas { outline: none; display: block; }

    /* HUD / UI */
    #ui { position: absolute; top: 10px; left: 10px; background: var(--panel); padding: 10px 12px; border-radius: 12px; border: 1px solid var(--panel-border); backdrop-filter: blur(4px); z-index: 10; min-width: 320px; }
    #ui h1 { margin: 0 0 8px 0; font-size: 13px; letter-spacing: 0.06em; opacity: 0.95; }

    .section { margin-top: 6px; border-top: 1px dashed var(--panel-border); padding-top: 8px; }
    .section:first-of-type{ margin-top: 0; border-top: none; padding-top: 0; }
    .grid { display: grid; grid-template-columns: auto 1fr; gap: 6px 8px; align-items: center; }
    .row { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    .chips { display:flex; gap:6px; flex-wrap:wrap; }
    .chip { background: var(--chip); border:1px solid var(--chip-border); padding:4px 8px; border-radius:8px; font-size:12px; cursor:pointer; user-select:none; }
    .chip input{ margin-right:6px; }

    label { font-size: 12px; opacity: 0.9; }
    input[type="range"] { width: 140px; }
    select, input[type="number"], button { background: var(--chip); color: var(--text); border:1px solid var(--chip-border); border-radius:8px; padding:4px 8px; font-size:12px; }
    button { cursor:pointer; }

    #legend { font-size: 11px; opacity: 0.8; margin-top: 8px; line-height: 1.35; }
    #tests  { font-size: 11px; opacity: 0.9; margin-top: 6px; line-height: 1.3; white-space: pre-line; }

    /* Split labels HUD (tiny, always available even when H hides HUD) */
    #splitLabels { position: absolute; top: 10px; right: 10px; font-size: 11px; opacity: 0.9; background: rgba(0,0,0,0.4); padding: 6px 8px; border-radius: 10px; border: 1px solid var(--panel-border); z-index: 10; }
    #score { display:inline-block; margin-left:8px; padding:2px 6px; background: rgba(255,255,255,0.06); border-radius:8px; border: 1px solid var(--panel-border); }

    /* HUD hide */
    #hudHideRow{ display:flex; align-items:center; justify-content:space-between; gap:8px; margin-bottom:6px; }
    #hideHUDBtn{ background: var(--chip); border:1px solid var(--chip-border); border-radius:8px; padding:4px 8px; font-size:12px; cursor:pointer; }

    /* Pane panning/zoom mini overlays (not exported) */
    .paneControls { position:absolute; bottom:10px; width:calc(50% - 20px); background: rgba(0,0,0,0.35); border:1px solid var(--panel-border); border-radius:10px; padding:6px 8px; z-index:9; backdrop-filter: blur(4px); }
    #paneControlsLeft{ left:10px; }
    #paneControlsRight{ right:10px; }
    .paneControls .row{ gap:6px; }
    .paneControls label{ font-size:11px; opacity:0.9; min-width:60px; }
    .paneControls input[type="range"]{ width: 140px; }
    .paneControls button{ background: var(--chip); border:1px solid var(--chip-border); border-radius:8px; padding:2px 6px; font-size:11px; }

    /* quick hidden flags */
    .hidden { display: none !important; }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.2/p5.min.js"></script>
</head>
<body>
  <div id="ui">
    <div id="hudHideRow">
      <h1>Brutalist City â€” 16Ã—16Ã—16</h1>
      <button id="hideHUDBtn" title="Hide all HUD (press H)">Hide HUD</button>
    </div>

    <!-- World -->
    <div class="section">
      <div class="grid">
        <label for="seedInput">Seed</label>
        <div class="row">
          <input id="seedInput" type="number" step="1" style="width:120px" />
          <button id="reseat" title="Randomize seed">Reseed</button>
          <button id="regen" title="Regenerate city">Regenerate</button>
          <button id="exportTrails" title="Export left trails at 10Ã— (transparent)">Export Trails Ã—10</button>
        </div>
        <label>Density</label>
        <input id="density" type="range" min="0" max="1" step="0.01" />
        <label>Height</label>
        <input id="height" type="range" min="4" max="16" step="1" />
      </div>
    </div>

    <!-- City toggles -->
    <div class="section">
      <div class="chips">
        <label class="chip"><input id="toggleStairs" type="checkbox" checked />Stair Shafts</label>
        <label class="chip"><input id="toggleBridges" type="checkbox" checked />Sky Bridges</label>
        <label class="chip"><input id="toggleGrid" type="checkbox" checked />Grid</label>
        <label class="chip"><input id="wireLeft" type="checkbox" checked />Wire L</label>
        <label class="chip"><input id="wireRight" type="checkbox" checked />Wire R</label>
        <label>Wire Î±</label><input id="wireAlpha" type="range" min="10" max="255" step="1" value="200" />
      </div>
    </div>

    <!-- Views & Sim -->
    <div class="section">
      <div class="grid">
        <label>Left view</label>
        <select id="leftView">
          <option value="side">Side</option>
          <option value="top">Top</option>
        </select>
        <label>Right view</label>
        <select id="rightView">
          <option value="free">Free</option>
          <option value="iso">Iso</option>
        </select>
        <label>Sim speed</label>
        <select id="simSpeed">
          <option value="0.1">0.1Ã—</option>
          <option value="1" selected>1Ã—</option>
          <option value="10">10Ã—</option>
        </select>
      </div>
    </div>

    <!-- DSL -->
    <div class="section">
      <div class="grid" style="grid-template-columns: 1fr auto;">
        <textarea id="dslBox" rows="6" style="min-width:300px; width: 100%; resize: vertical; font-family:inherit; font-size:12px;">
# Minimal DSL â€” examples:
# density=0.7
# height=14
# bridges=off
# wireL=on
# left=top
# sim=10
# zoomL=1.2
# panLX=200
# freeRotY=0.7
# green.count=3
# orange.count=1
# green.impair=1.5
# green.speed=2.4
# orange.restMult=26
# goal=random   # or goal=node:120  or goal=tower:3,level:10
# regen
        </textarea>
        <div class="row" style="align-self:start; gap:6px;">
          <button id="runDSL">Run DSL</button>
        </div>
      </div>
    </div>

    <!-- Bots / Trails -->
    <div class="section">
      <div class="grid">
        <label>Trail thickness</label>
        <input id="trailThickness" type="range" min="1" max="10" step="1" value="2" />
        <label>Bot pulsing</label>
        <label class="chip"><input id="togglePulse" type="checkbox" checked />Enabled</label>
      </div>
    </div>

    <div id="legend">
      Drag on the <b>right pane</b> to orbit (when Right view = Free). Mouse wheel zoom is disabled â€” use the pane sliders (or DSL).
      Shortcuts: <b>R</b> regenerate â€¢ <b>S</b> save stitched PNG â€¢ <b>T</b> tests â€¢ <b>[ / ]</b> speed â€¢ <b>H</b> HUD â€¢ <b>C</b> pane controls.
    </div>
    <div id="tests"></div>
  </div>

  <!-- Mini pan/zoom overlays (not included in export) -->
  <div id="paneControlsLeft" class="paneControls">
    <div class="row"><label>Zoom L</label><input id="zoomLeftCtl" type="range" min="0.4" max="3" step="0.01" value="1"></div>
    <div class="row"><label>Pan L X</label><input id="panLeftXCtl" type="range" min="-1500" max="1500" step="1" value="0"></div>
    <div class="row"><label>Pan L Y</label><input id="panLeftYCtl" type="range" min="-1500" max="1500" step="1" value="0"></div>
  </div>
  <div id="paneControlsRight" class="paneControls">
    <div class="row"><label>Zoom R</label><input id="zoomRightCtl" type="range" min="0.4" max="3" step="0.01" value="1"></div>
    <div class="row"><label>Pan R X</label><input id="panRightXCtl" type="range" min="-1500" max="1500" step="1" value="0"></div>
    <div class="row"><label>Pan R Y</label><input id="panRightYCtl" type="range" min="-1500" max="1500" step="1" value="0"></div>
  </div>

  <div id="splitLabels">
    Left: <span id="leftLabel">Side-on</span> | Right: <span id="rightLabel">Free orbit</span>
    <span id="score">ðŸŸ© 0 : 0 ðŸŸ§</span><span id="simLabel"> â€¢ speed: 1Ã—</span><span id="fatigueHUD"> â€¢ fatigue: ðŸŸ© 0% â€¢ ðŸŸ§ 0%</span>
  </div>

  <script>
    // --- Parameters ---
    const GRID=16, LEVELS=16, CELL=40, BRIDGE_THICK=8;
    const PALETTE={concrete:[128,128,128], darker:[98,98,98], accent:[150,150,155], sky:[20,20,24]};

    // Fatigue model constants
    const FATIGUE_ACC=0.0004;       // per unit movement
    const FATIGUE_REC=0.00015;      // passive recovery per frame
    const FATIGUE_IMPACT=0.6;       // speed penalty at fatigue=1
    const FATIGUE_VERT_MULT=2.5;    // extra fatigue cost when moving vertically
    const FATIGUE_REST_THRESHOLD=1.0;   // enter rest at >= 100%
    const FATIGUE_RESUME_THRESHOLD=0.0; // resume only at 0%
    const FATIGUE_REST_REC_MULT=15.0;   // fallback if bot lacks restMult

    // --- State ---
    let seed=Math.floor(Math.random()*1e9);
    let towers=[], bridges=[];
    let navNodes=[], navAdj=[], baseIndexByTower=[];
    let bots=[], goal=null, scores={green:0, orange:0};

    // Viewports / cameras
    let leftPG, rightPG, zoomLeft=1.0, zoomRight=1.0;
    let panLeftX=0, panLeftY=0, panRightX=0, panRightY=0;
    let freeRotX=-35.264*Math.PI/180, freeRotY=45*Math.PI/180;

    // HUD & pane controls visibility
    let HUD_VISIBLE = true;       // toggle with H
    let CONTROLS_VISIBLE = true;  // toggle with C

    // Toggles
    let wireLeft=true, wireRight=true, simSpeed=1.0, pulseEnabled=true;

    // Trails
    let trailThickness=2;

    // Tests
    let SHOW_TESTS=false; const testPanel=()=>document.getElementById('tests');

    // Bot overrides from DSL + counts + impairment
    const botOverrides = { green:{}, orange:{} };
    let botCounts = { green: 1, orange: 1 };
    let greenImpairScale = 1.0; // scales sway/curve/asym on green

    // --- UI helpers ---
    function reseed(val){ seed=(val!==undefined)?val:Math.floor(Math.random()*1e9); randomSeed(seed); noiseSeed(seed); const inp=document.getElementById('seedInput'); if(inp) inp.value=seed; }
    function params(){ return { density:parseFloat(document.getElementById('density').value), maxHeight:parseInt(document.getElementById('height').value,10), stairsOn:document.getElementById('toggleStairs').checked, bridgesOn:document.getElementById('toggleBridges').checked, gridOn:document.getElementById('toggleGrid').checked, leftView:document.getElementById('leftView').value, rightView:document.getElementById('rightView').value, wireLeft:document.getElementById('wireLeft').checked, wireRight:document.getElementById('wireRight').checked, wireAlpha: parseInt(document.getElementById('wireAlpha')?.value||'200',10) }; }

    function setHUDVisible(show){
      HUD_VISIBLE = !!show;
      document.getElementById('ui').classList.toggle('hidden', !HUD_VISIBLE);
      setControlsVisible(HUD_VISIBLE && CONTROLS_VISIBLE);
    }
    function setControlsVisible(show){
      const on = !!show; const cl = document.getElementById('paneControlsLeft'); const cr=document.getElementById('paneControlsRight');
      if(cl) cl.classList.toggle('hidden', !on); if(cr) cr.classList.toggle('hidden', !on);
    }

    function getWireAlpha(){ const el=document.getElementById('wireAlpha'); return el?parseInt(el.value,10):200; }

    function setup(){
      createCanvas(windowWidth, windowHeight); noStroke();
      resizePanes();
      document.getElementById('density').value=0.55; document.getElementById('height').value=12; reseed(seed);
      document.getElementById('reseat').onclick=()=>{reseed(); generateCity();};
      document.getElementById('regen').onclick=()=>{generateCity();};
      document.getElementById('seedInput').onchange=(e)=>{reseed(parseInt(e.target.value||0,10)); generateCity();};
      document.getElementById('exportTrails').onclick=()=>{exportTrailsLeftHiRes();};
      document.getElementById('simSpeed').onchange=(e)=>{simSpeed=parseFloat(e.target.value); updateSimLabel();};
      document.getElementById('trailThickness').oninput=(e)=>{trailThickness=parseInt(e.target.value,10);};
      document.getElementById('togglePulse').onchange=(e)=>{pulseEnabled=e.target.checked;};
      document.getElementById('hideHUDBtn').onclick=()=>{ setHUDVisible(false); };
      document.getElementById('runDSL').onclick=()=>{ runDSL(); };

      // Pane controls bindings
      document.getElementById('zoomLeftCtl').oninput=(e)=>{ zoomLeft=parseFloat(e.target.value); };
      document.getElementById('zoomRightCtl').oninput=(e)=>{ zoomRight=parseFloat(e.target.value); };
      document.getElementById('panLeftXCtl').oninput=(e)=>{ panLeftX=parseFloat(e.target.value); };
      document.getElementById('panLeftYCtl').oninput=(e)=>{ panLeftY=parseFloat(e.target.value); };
      document.getElementById('panRightXCtl').oninput=(e)=>{ panRightX=parseFloat(e.target.value); };
      document.getElementById('panRightYCtl').oninput=(e)=>{ panRightY=parseFloat(e.target.value); };

      ['density','height','toggleStairs','toggleBridges','toggleGrid','leftView','rightView','wireLeft','wireRight','wireAlpha']
        .forEach(id=>document.getElementById(id).oninput=()=>{
          const P=params();
          document.getElementById('leftLabel').textContent=P.leftView==='side'?'Side-on':'Top-down';
          document.getElementById('rightLabel').textContent=P.rightView==='free'?'Free orbit':'Isometric';
          wireLeft=P.wireLeft; wireRight=P.wireRight;
          generateCity();
        });

      // Disable mouse-wheel zoom (zoom only via sliders)
      window.addEventListener('wheel',(e)=>{ e.preventDefault(); },{passive:false});

      updateSimLabel(); generateCity();
    }

    function resizePanes(){ leftPG=createGraphics(Math.floor(width/2), height, WEBGL); rightPG=createGraphics(Math.floor(width/2), height, WEBGL); }
    function windowResized(){ resizeCanvas(windowWidth, windowHeight); resizePanes(); redraw(); }

    function keyPressed(){
      if (key==='H' || key==='h'){ setHUDVisible(!HUD_VISIBLE); return; }
      if (key==='C' || key==='c'){ CONTROLS_VISIBLE=!CONTROLS_VISIBLE; setControlsVisible(CONTROLS_VISIBLE && HUD_VISIBLE); return; }
      if(key==='R'||key==='r') generateCity();
      if(key==='S'||key==='s'){ const pg=createGraphics(width,height); pg.image(leftPG,0,0,width/2,height); pg.image(rightPG,width/2,0,width/2,height); pg.save('brutalist_city_'+seed+'.png'); }
      if(key==='T'||key==='t'){ SHOW_TESTS=!SHOW_TESTS; runTests(); }
      if(key==='['){ if (simSpeed===10) simSpeed=1; else if(simSpeed===1) simSpeed=0.1; document.getElementById('simSpeed').value=simSpeed.toString(); updateSimLabel(); }
      if(key===']'){ if (simSpeed===0.1) simSpeed=1; else if(simSpeed===1) simSpeed=10; document.getElementById('simSpeed').value=simSpeed.toString(); updateSimLabel(); }
    }

    function mouseDragged(){ const P=params(); if(mouseX>width/2 && P.rightView==='free'){ freeRotY+=movedX*0.01; freeRotX+=movedY*0.01; freeRotX=constrain(freeRotX,-Math.PI/2,Math.PI/2*0.99);} }

    // --- City generation ---
    function generateCity(){
      const P=params(); randomSeed(seed); noiseSeed(seed);
      towers=[]; bridges=[]; navNodes=[]; navAdj=[]; baseIndexByTower=[]; bots=[]; goal=null; scores={green:0,orange:0};
      const freq=0.08;
      for(let gx=0; gx<GRID; gx++){
        for(let gz=0; gz<GRID; gz++){
          const n=noise(gx*freq,gz*freq); const place=n*0.9+random(0.1); if(place<(1.0-P.density)) continue;
          const footprint = random()<0.2?3:(random()<0.5?2:1);
          const hNoise=noise(gx*freq*1.7+100,gz*freq*1.7+100); const maxH=constrain(Math.floor(map(hNoise,0,1,4,P.maxHeight)),4,LEVELS);
          const modules=[]; let y=0; while(y<maxH){ const mh=Math.min(maxH-y,Math.floor(random(2,5))); const offset=(random()<0.25)?(random([-1,0,1])):0; const extrude=(random()<0.25)?(random([0,1])):0; modules.push({y,h:mh,offset,extrude}); y+=mh; }
          towers.push({gx,gz,footprint,maxH,modules,hasStairs:true,renderStairs:P.stairsOn,stairSide:1,stairPos:{sx:0,sz:0}});
        }
      }
      if(P.bridgesOn){ for(let i=0;i<towers.length;i++){ const a=towers[i]; let best=null,bestd=1e9; for(let j=0;j<towers.length;j++) if(i!==j){ const b=towers[j]; const dx=b.gx-a.gx,dz=b.gz-a.gz; const d2=dx*dx+dz*dz; if(d2<bestd && d2>0){bestd=d2; best=b;} } if(best){ const y=Math.floor(random(3,Math.min(a.maxH,best.maxH))); bridges.push({a,b:best,y}); } if(random()<0.3 && towers.length>3){ const b=random(towers); if(b && b!==a){ const y=Math.floor(random(3,Math.min(a.maxH,b.maxH))); bridges.push({a,b,y}); } } } }
      ensureConnectivity(); buildNavGraph(); createBotsAndGoal(); if(SHOW_TESTS) runTests();
    }

    function towerCenter(ti){ const t=towers[ti]; return {x:(t.gx-GRID/2)*CELL, z:(t.gz-GRID/2)*CELL}; }

    function ensureConnectivity(){ if(towers.length===0) return; const n=towers.length; const adj=Array.from({length:n},()=>[]); for(const br of bridges){ const ai=towers.indexOf(br.a), bi=towers.indexOf(br.b); if(ai>=0&&bi>=0){ adj[ai].push(bi); adj[bi].push(ai);} } const comp=Array(n).fill(-1); let c=0; for(let i=0;i<n;i++) if(comp[i]===-1){ const st=[i]; comp[i]=c; while(st.length){ const u=st.pop(); for(const v of adj[u]) if(comp[v]===-1){comp[v]=c; st.push(v);} } c++; } if(c<=1) return; for(let k=1;k<c;k++){ let bestA=-1,bestB=-1,bestD=1e9; for(let i=0;i<n;i++) if(comp[i]===0) for(let j=0;j<n;j++) if(comp[j]===k){ const ci=towerCenter(i), cj=towerCenter(j); const d=(ci.x-cj.x)**2+(ci.z-cj.z)**2; if(d<bestD){bestD=d; bestA=i; bestB=j;} } if(bestA>=0){ const a=towers[bestA], b=towers[bestB]; const y=Math.floor(Math.min(a.maxH,b.maxH)/2); bridges.push({a,b,y}); for(let i=0;i<n;i++) if(comp[i]===k) comp[i]=0; } } }

    function buildNavGraph(){ navNodes=[]; navAdj=[]; baseIndexByTower=[]; let base=0; for(let ti=0;ti<towers.length;ti++){ baseIndexByTower[ti]=base; const c=towerCenter(ti), t=towers[ti]; for(let lvl=0; lvl<t.maxH; lvl++){ navNodes.push({ti,level:lvl,x:c.x,y:-lvl*CELL,z:c.z}); navAdj.push([]);} for(let lvl=0; lvl<t.maxH-1; lvl++){ const a=base+lvl,b=base+lvl+1; navAdj[a].push(b); navAdj[b].push(a);} base+=t.maxH; } function nodeIndex(ti,lvl){ return baseIndexByTower[ti]+lvl; } for(const br of bridges){ const ai=towers.indexOf(br.a), bi=towers.indexOf(br.b); if(ai<0||bi<0) continue; const lvl=Math.min(br.y, towers[ai].maxH-1, towers[bi].maxH-1); const a=nodeIndex(ai,lvl), b=nodeIndex(bi,lvl); navAdj[a].push(b); navAdj[b].push(a);} }

    function pickRandomNode(exclude=-1){ if(navNodes.length===0) return -1; let idx; do{ idx=Math.floor(random(navNodes.length)); }while(idx===exclude && navNodes.length>1); return idx; }

    // --- Bots (multi-count, green impairment scale) & goal ---
    function createBotsAndGoal(){
      if(navNodes.length===0) return;
      bots=[];
      const startIdxs=[];
      const takeStart=()=>{ let idx=pickRandomNode(); let guard=0; while(startIdxs.includes(idx) && guard++<20){ idx=pickRandomNode(); } startIdxs.push(idx); return idx; };

      // green bots
      for(let i=0;i<botCounts.green;i++){
        const gIdx = takeStart();
        const baseSway = CELL*0.18*greenImpairScale;
        const baseCurve = 0.12*greenImpairScale;
        const baseAsym = 0.22*greenImpairScale;
        const b={
          name:'green', color:[60,200,100], node:gIdx,
          pos:{...navNodes[gIdx]}, path:[], segI:0, t:0,
          speed:2.0, trail:[{...navNodes[gIdx]}],
          gaitPhase: random(Math.PI*2),
          gaitOmega:(Math.PI*2)/(CELL*0.9),
          curveBias:baseCurve, stairSlow:0.6,
          swayAmp:baseSway, speedAsym:baseAsym,
          fatigue:0, fatigueAccMult:1.35, fatigueRecMult:0.9,
          resting:false, restMult:24.7
        };
        const ov = botOverrides.green; if(ov && Object.keys(ov).length) Object.assign(b, ov);
        bots.push(b);
      }

      // orange bots
      for(let i=0;i<botCounts.orange;i++){
        const oIdx = takeStart();
        const b={
          name:'orange', color:[240,150,60], node:oIdx,
          pos:{...navNodes[oIdx]}, path:[], segI:0, t:0,
          speed:2.2, trail:[{...navNodes[oIdx]}],
          gaitPhase:0, gaitOmega:(Math.PI*2)/CELL,
          curveBias:0, stairSlow:1, swayAmp:0, speedAsym:0,
          fatigue:0, fatigueAccMult:1.0, fatigueRecMult:1.1,
          resting:false, restMult:25.25
        };
        const ov = botOverrides.orange; if(ov && Object.keys(ov).length) Object.assign(b, ov);
        bots.push(b);
      }

      goal={node:pickRandomNode()};
      for(const b of bots) planPath(b, goal.node);
      updateScoreLabel();
    }

    // HUD updaters
    function updateSimLabel(){ const el=document.getElementById('simLabel'); if(el) el.textContent = ` â€¢ speed: ${simSpeed.toFixed(1)}Ã—`; }
    function updateFatigueHUD(){
      const el=document.getElementById('fatigueHUD');
      if(!el) return;
      if(!bots || bots.length===0){ el.textContent=''; return; }
      let gSum=0,gN=0,oSum=0,oN=0;
      for(const b of bots){ if(b.name==='green'){ gSum+=(b.fatigue||0); gN++; } else if(b.name==='orange'){ oSum+=(b.fatigue||0); oN++; } }
      const gf=gN?Math.round((gSum/gN)*100):0;
      const of=oN?Math.round((oSum/oN)*100):0;
      el.textContent = ` â€¢ fatigue: ðŸŸ© ${gf}% â€¢ ðŸŸ§ ${of}%`;
    }
    function updateScoreLabel(){ const el=document.getElementById('score'); if(el) el.textContent = `ðŸŸ© ${scores.green} : ${scores.orange} ðŸŸ§`; }

    // --- Pathfinding (A*) ---
    function heuristic(a,b){ const pa=navNodes[a], pb=navNodes[b]; const dx=pa.x-pb.x, dy=pa.y-pb.y, dz=pa.z-pb.z; return Math.sqrt(dx*dx+dy*dy+dz*dz); }
    function planPath(bot, targetIdx){ const N=navNodes.length; const open=new Set([bot.node]); const came=new Map(); const g=Array(N).fill(Infinity); g[bot.node]=0; const f=Array(N).fill(Infinity); f[bot.node]=heuristic(bot.node,targetIdx); while(open.size){ let current=-1,best=Infinity; for(const n of open){ if(f[n]<best){best=f[n]; current=n;} } if(current===targetIdx) break; open.delete(current); for(const nb of navAdj[current]){ const tentative=g[current]+heuristic(current,nb); if(tentative<g[nb]){ came.set(nb,current); g[nb]=tentative; f[nb]=tentative+heuristic(nb,targetIdx); open.add(nb);} } } if(!isFinite(g[targetIdx])){ bot.path=[]; bot.segI=0; bot.t=0; return; } const nodes=[]; let u=targetIdx; nodes.unshift(u); while(u!==bot.node){ u=came.get(u); if(u===undefined) break; nodes.unshift(u);} const segs=[]; for(let i=0;i<nodes.length-1;i++){ const a=navNodes[nodes[i]], b=navNodes[nodes[i+1]]; const len=Math.hypot(a.x-b.x,a.y-b.y,a.z-b.z); segs.push({a,b,len}); } bot.path=segs; bot.segI=0; bot.t=0; bot.node=nodes[0]; }

    // --- Simulation step (fatigue + impairment dynamics, rest mode) ---
    function stepBots(){
      if(!goal || navNodes.length===0) return;
      for(const b of bots){
        const speedScale = simSpeed;
        // --- Rest mode ---
        if(b.resting){
          const restMul = (b.restMult!==undefined? b.restMult : FATIGUE_REST_REC_MULT);
          b.fatigue = constrain((b.fatigue||0) - FATIGUE_REC * (b.fatigueRecMult||1) * restMul * speedScale, 0, 1);
          if(b.fatigue <= FATIGUE_RESUME_THRESHOLD){ b.resting=false; }
          if(b.name==='green') b.gaitPhase += 0.2 * (b.gaitOmega||1) * speedScale;
          continue;
        }
        if(!b.path || b.path.length===0){ planPath(b, goal.node); continue; }
        const seg=b.path[b.segI]; if(!seg) continue;
        const ax=seg.a.x, ay=seg.a.y, az=seg.a.z;
        const bx=seg.b.x, by=seg.b.y, bz=seg.b.z;
        const dx=bx-ax, dy=by-ay, dz=bz-az; const len=seg.len;
        const isVertical = Math.abs(dy) > Math.max(Math.abs(dx), Math.abs(dz))*0.5;
        // base speed before fatigue
        let v=b.speed*speedScale;
        if(b.name==='green'){
          const gaitSlow=1 - b.speedAsym * Math.max(0, Math.sin(b.gaitPhase));
          const stairMul = isVertical ? b.stairSlow : 1.0;
          v *= gaitSlow * stairMul;
        }
        // fatigue impact on speed
        const fatigueFactor = 1 - FATIGUE_IMPACT * constrain(b.fatigue||0,0,1);
        v *= fatigueFactor;
        const dt=v; b.t+=dt;
        let s=Math.min(1, b.t/len);
        let px=ax+dx*s, py=ay+dy*s, pz=az+dz*s;
        // green drift/sway
        if(b.name==='green'){
          const hlen=Math.hypot(dx,dz)||1;
          const nx=-dz/hlen, nz=dx/hlen;
          const sway=b.swayAmp*Math.sin(b.gaitPhase);
          const curve=b.curveBias*(s*len);
          px+=nx*(sway+curve); pz+=nz*(sway+curve);
          b.gaitPhase += dt*b.gaitOmega;
        }
        // update fatigue based on movement
        const accMult = (b.fatigueAccMult||1.0);
        const recMult = (b.fatigueRecMult||1.0);
        const moveCost = FATIGUE_ACC * accMult * v * (isVertical ? FATIGUE_VERT_MULT : 1);
        b.fatigue = constrain((b.fatigue||0) + moveCost - FATIGUE_REC * recMult, 0, 1);
        // enter rest at full fatigue
        if(b.fatigue >= FATIGUE_REST_THRESHOLD){ b.resting = true; continue; }

        b.pos.x=px; b.pos.y=py; b.pos.z=pz;
        b.trail.push({x:px,y:py,z:pz});
        if(b.t>=len){
          b.segI++; b.t=0; b.pos={x:bx,y:by,z:bz}; b.trail.push({x:bx,y:by,z:bz});
          if(b.segI>=b.path.length){
            const gp=navNodes[goal.node];
            const d=Math.hypot(b.pos.x-gp.x,b.pos.y-gp.y,b.pos.z-gp.z);
            if(d<1e-3){
              scores[b.name]=(scores[b.name]||0)+1;
              b.fatigue *= 0.6; // modest recovery on goal
              goal.node=pickRandomNode();
              for(const bb of bots) planPath(bb, goal.node);
              updateScoreLabel();
            }
          }
        }
      }
    }

    // --- Drawing helpers ---
    function drawModule(g,t,mod,wire=false){
      const {gx,gz,footprint}=t;
      g.push();
      const baseX=(gx-GRID/2)*CELL, baseZ=(gz-GRID/2)*CELL;
      const y=-mod.y*CELL;
      g.translate(baseX+mod.offset*4, y-(mod.h*CELL)/2, baseZ);
      const w=footprint*CELL+mod.extrude*10, d=w, h=mod.h*CELL;
      if(wire){ g.noFill(); g.stroke(200,200,200,getWireAlpha()); g.box(w,h,d); g.noStroke(); }
      else { const tone=((mod.y/2|0)%2===0)?PALETTE.concrete:PALETTE.darker; g.ambientMaterial(tone[0],tone[1],tone[2]); g.box(w,h,d); }
      g.pop();

      if(t.renderStairs){
        g.push();
        const coreW=Math.max(CELL*0.6,(t.stairSide*CELL)*0.8), coreD=coreW;
        const baseX2=(t.gx-GRID/2)*CELL, baseZ2=(t.gz-GRID/2)*CELL;
        const y2=-(mod.y*CELL);
        g.translate(baseX2, y2-(mod.h*CELL)/2, baseZ2);
        if(wire){ g.noFill(); g.stroke(180,180,180,getWireAlpha()); g.box(coreW,mod.h*CELL*0.95,coreD); g.noStroke(); }
        else { g.ambientMaterial(PALETTE.accent[0],PALETTE.accent[1],PALETTE.accent[2]); g.specularMaterial(180); g.box(coreW,mod.h*CELL*0.95,coreD); }
        g.pop();
      }
    }

    function drawBridge(g,bridge,wire=false){
      const {a,b,y}=bridge;
      const x1=(a.gx-GRID/2)*CELL, z1=(a.gz-GRID/2)*CELL;
      const x2=(b.gx-GRID/2)*CELL, z2=(b.gz-GRID/2)*CELL;
      const midx=(x1+x2)/2, midz=(z1+z2)/2, len=dist(x1,z1,x2,z2);
      g.push();
      g.translate(midx, -y*CELL, midz);
      const ang=Math.atan2(x2-x1, z2-z1);
      g.rotateY(ang);
      if(wire){ g.noFill(); g.stroke(200,200,200,getWireAlpha()); g.box(len,BRIDGE_THICK,BRIDGE_THICK*1.4); g.noStroke(); }
      else { g.ambientMaterial(120,120,120); g.box(len,BRIDGE_THICK,BRIDGE_THICK*1.4); }
      g.pop();
    }

    function drawGround(g,wire=false){
      g.push();
      g.translate(0,2,0);
      if(wire){ g.noFill(); g.stroke(60,60,60,getWireAlpha()); g.box(GRID*CELL*1.6,4,GRID*CELL*1.6); g.noStroke(); }
      else { g.ambientMaterial(PALETTE.sky[0],PALETTE.sky[1],PALETTE.sky[2]); g.box(GRID*CELL*1.6,4,GRID*CELL*1.6); }
      g.pop();
    }

    function drawGrid(g){
      if(!params().gridOn) return;
      g.push();
      g.stroke(40);
      g.noFill();
      const half=GRID*CELL/2;
      for(let i=-half;i<=half;i+=CELL){ g.line(-half, 0, i,  half, 0, i); g.line(i, 0, -half, i, 0, half); }
      g.noStroke();
      g.pop();
    }

    // Goal as bright-blue ripple
    function drawGoal(g){
      if(!goal || !navNodes[goal.node]) return;
      const p=navNodes[goal.node];
      const baseY=p.y - CELL*0.48;
      const maxR=CELL*2.5, speed=1.2*simSpeed, t=(millis()*0.001*speed)%1, rings=4;
      g.push();
      g.translate(p.x, baseY, p.z);
      g.noFill();
      if(g.strokeWeight) g.strokeWeight(2);
      for(let i=0;i<rings;i++){
        const phase=(t+i/rings)%1, r=0.1*CELL + phase*maxR, alpha=Math.max(0,255*(1-phase));
        g.stroke(0,180,255,alpha);
        g.push();
        g.rotateX(Math.PI/2);
        g.beginShape();
        const STEPS=64;
        for(let a=0;a<=STEPS;a++){ const ang=(a/STEPS)*Math.PI*2; g.vertex(Math.cos(ang)*r, Math.sin(ang)*r, 0); }
        g.endShape();
        g.pop();
      }
      g.pop();
    }

    function drawBots(g,wire){
      const t=millis()*0.001, TWO_PI=Math.PI*2;
      for(const b of bots){
        // infinite trails
        if(b.trail && b.trail.length>1){
          g.push(); g.noFill();
          let tw=trailThickness;
          if(b.name==='green') tw=Math.max(1, trailThickness*(1+0.35*Math.sin(b.gaitPhase+Math.PI/2)));
          if(g.strokeWeight) g.strokeWeight(tw);
          const trailAlpha = 190 * (1 - 0.4 * (b.fatigue||0));
          g.stroke(b.color[0],b.color[1],b.color[2],trailAlpha);
          for(let i=1;i<b.trail.length;i++){ const p0=b.trail[i-1], p1=b.trail[i]; g.line(p0.x,p0.y - CELL*0.3,p0.z, p1.x,p1.y - CELL*0.3,p1.z); }
          g.noStroke(); g.pop();
        }

        // body + halo
        g.push();
        g.translate(b.pos.x, b.pos.y - CELL*0.3, b.pos.z);
        const basePulse=0.8;
        const phase=(b.name==='green')?b.gaitPhase:t*TWO_PI*basePulse;
        const sPulse=(pulseEnabled ? (1 + 0.15*Math.sin(phase)) : 1.0);
        const haloPulse=(pulseEnabled ? (0.9 + 0.2*Math.sin(phase)) : 1.0);
        const haloAlphaBase=pulseEnabled ? (140 + 100*(0.5 + 0.5*Math.sin(phase))) : 200;
        const fatigueDim = 1 - 0.5 * (b.fatigue||0);
        const restDim = b.resting ? 0.6 : 1.0;
        const haloAlpha = haloAlphaBase * fatigueDim * restDim;

        if(b.name==='green' && pulseEnabled){
          const sx=1.0 - 0.12*Math.sin(phase);
          const sy=1.0 + 0.08*Math.sin(phase+0.5);
          const sz=1.0 + 0.06*Math.sin(phase+1.0);
          g.scale(sx,sy,sz);
        }
        if(wire){ g.noFill(); g.stroke(255,255,255,getWireAlpha()); g.box(CELL*0.9*sPulse, CELL*0.9*sPulse, CELL*0.9*sPulse); g.noStroke(); }
        else { const k=((b.name==='green') ? (0.7 + 0.3*(0.5 + 0.5*Math.sin(phase))) : 1.0) * fatigueDim * restDim; g.emissiveMaterial(b.color[0]*k, b.color[1]*k, b.color[2]*k); g.box(CELL*0.9*sPulse, CELL*0.9*sPulse, CELL*0.9*sPulse); }
        g.noFill(); g.stroke(b.color[0], b.color[1], b.color[2], haloAlpha);
        if(g.strokeWeight) g.strokeWeight(2 + (pulseEnabled ? 2*(0.5 + 0.5*Math.sin(phase)) : 1));
        g.sphere(CELL*0.7*haloPulse);
        if(b.resting){ g.noStroke(); g.fill(255,255,255,120); if(g.text){ g.push(); g.textSize(12); g.textAlign(CENTER, CENTER); g.translate(0, -CELL*0.9, 0); g.rotateX(-Math.PI/2); g.text('Z', 0, 0); g.pop(); } }
        g.noStroke(); g.pop();
      }
    }

    function applyViewTransform(g,which,zoomVal, panX, panY){
      // Base camera stand-off
      g.translate(0,200,-200);
      g.scale(zoomVal);
      if(which==='iso'){
        g.rotateX(-35.264*Math.PI/180);
        g.rotateY(45*Math.PI/180);
        g.translate((panX||0)/zoomVal, (panY||0)/zoomVal, 0);
      } else if(which==='free'){
        g.rotateX(freeRotX);
        g.rotateY(freeRotY);
        g.translate((panX||0)/zoomVal, (panY||0)/zoomVal, 0);
      } else if(which==='side'){
        // Left: side-on â†’ panX world Z, panY world Y
        g.rotateY(Math.PI/2);
        g.translate(0,(panY||0)/zoomVal,0);
        g.translate(0,0,(panX||0)/zoomVal);
      } else if(which==='top'){
        // Left: top-down â†’ panX world X, panY world Z
        g.rotateX(Math.PI/2);
        g.translate((panX||0)/zoomVal,0,(panY||0)/zoomVal);
      } else {
        g.translate((panX||0)/zoomVal, (panY||0)/zoomVal, 0);
      }
    }

    function renderPane(g,whichView,wire,zoomVal, panX, panY){
      g.push();
      g.background(...PALETTE.sky);
      g.ambientLight(120);
      g.directionalLight(200,200,200, 0.3,-0.6,-0.2);
      applyViewTransform(g,whichView,zoomVal, panX, panY);
      drawGround(g,wire);
      drawGrid(g);
      for(const t of towers) for(const m of t.modules) drawModule(g,t,m,wire);
      for(const br of bridges) drawBridge(g,br,wire);
      drawGoal(g);
      drawBots(g,wire);
      g.pop();
    }

    function draw(){
      const P=params();
      wireLeft=P.wireLeft; wireRight=P.wireRight;
      stepBots();
      renderPane(leftPG,P.leftView,wireLeft,zoomLeft, panLeftX, panLeftY);
      renderPane(rightPG,P.rightView,wireRight,zoomRight, panRightX, panRightY);
      background(12);
      image(leftPG,0,0,width/2,height);
      image(rightPG,width/2,0,width/2,height);
      stroke(32); line(width/2,0,width/2,height); noStroke();
      updateFatigueHUD();
    }

    // --- Export (left pane trails only, 10Ã—, camera-match, proportionally thinner lines) ---
    function setExportProjection(g,refW,refH){
      const fov=Math.PI/3, aspect=g.width/g.height;
      g.perspective(fov,aspect,0.1,10000);
      const eyeZ=(refH/2)/Math.tan(Math.PI/6);
      g.camera(0,0,eyeZ,0,0,0,0,1,0);
    }
    function exportTrailsLeftHiRes(){
      const P=params(), SCALE=10;
      const W=Math.floor(width/2)*SCALE, H=height*SCALE;
      const g=createGraphics(W,H,WEBGL);
      g.clear(); g.pixelDensity(1);
      setExportProjection(g,leftPG.width,leftPG.height);
      if(g.resetMatrix) g.resetMatrix();
      applyViewTransform(g,P.leftView,zoomLeft, panLeftX, panLeftY);
      g.push(); g.noFill();
      if(g.strokeWeight) g.strokeWeight(trailThickness * SCALE / 3); // lighter at 10x
      for(const b of bots){
        if(!b.trail || b.trail.length<2) continue;
        const trailAlpha = 255 * (1 - 0.3 * (b.fatigue||0));
        g.stroke(b.color[0],b.color[1],b.color[2],trailAlpha);
        for(let i=1;i<b.trail.length;i++){ const p0=b.trail[i-1], p1=b.trail[i]; g.line(p0.x,p0.y - CELL*0.3,p0.z, p1.x,p1.y - CELL*0.3,p1.z); }
      }
      g.pop();
      g.save('trails_left_x10_'+seed+'.png');
    }

    // --- DSL helpers ---
    function setUI(id, value){
      const el=document.getElementById(id); if(!el) return;
      if(el.type==='checkbox'){ el.checked=!!value; el.dispatchEvent(new Event('input')); }
      else if(el.tagName==='SELECT' || el.type==='range' || el.type==='number' || el.type==='text'){
        el.value=value; el.dispatchEvent(new Event('input'));
      }
    }
    function setGoalByNode(idx){ if(idx<0||idx>=navNodes.length) return false; goal={node:idx}; for(const b of bots) planPath(b, idx); return true; }
    function setGoalByTowerLevel(ti,lvl){ if(ti<0||ti>=towers.length) return false; const base=baseIndexByTower[ti]||0; const max=towers[ti].maxH; lvl=constrain(lvl,0,max-1); return setGoalByNode(base+lvl); }
    function parseBool(v){ const s=String(v).toLowerCase(); return (s==='1'||s==='true'||s==='on'||s==='yes'); }
    function numOr(v, def){ const n=parseFloat(v); return isFinite(n)?n:def; }

    function runDSL(){
      const box=document.getElementById('dslBox'); if(!box) return;
      const lines=box.value.split(/\r?\n/);
      let needRegen=false, needRedraw=false;

      for(let raw of lines){
        let line=raw.trim();
        if(!line || line.startsWith('#')) continue; // comments

        const m=line.match(/^([^=]+)=(.+)$/);
        if(m){ const key=m[1].trim(); const val=m[2].trim(); applyKV(key, val); continue; }

        const cmd=line.toLowerCase();
        if(cmd==='regen' || cmd==='regenerate'){ needRegen=true; continue; }
        if(cmd==='reseed'){ reseed(); needRegen=true; continue; }
        if(cmd==='export' || cmd==='exporttrails'){ exportTrailsLeftHiRes(); continue; }
        if(cmd==='goal=random'){ goal={node:pickRandomNode()}; for(const b of bots) planPath(b, goal.node); needRedraw=true; continue; }
      }
      if(needRegen) generateCity(); else if(needRedraw) redraw();
    }

    function applyKV(key,val){
      const k=key.replace(/\s+/g,'');
      // World params / toggles
      if(k==='density'){ setUI('density', numOr(val,0.5)); return; }
      if(k==='height'){ setUI('height', Math.round(numOr(val,12))); return; }
      if(k==='bridges'){ setUI('toggleBridges', parseBool(val)); return; }
      if(k==='stairs'){ setUI('toggleStairs', parseBool(val)); return; }
      if(k==='grid'){ setUI('toggleGrid', parseBool(val)); return; }
      if(k==='wirel'){ setUI('wireLeft', parseBool(val)); return; }
      if(k==='wirer'){ setUI('wireRight', parseBool(val)); return; }
      if(k==='wirea' || k==='wirealpha'){ setUI('wireAlpha', Math.round(numOr(val,200))); return; }
      if(k==='left'){ setUI('leftView', val.toLowerCase().startsWith('t')?'top':'side'); return; }
      if(k==='right'){ setUI('rightView', val.toLowerCase().startsWith('i')?'iso':'free'); return; }
      if(k==='sim' || k==='simspeed'){ simSpeed=numOr(val,1); document.getElementById('simSpeed').value=String(simSpeed); updateSimLabel(); return; }
      if(k==='pulse' || k==='pulsing'){ pulseEnabled=parseBool(val); document.getElementById('togglePulse').checked=pulseEnabled; return; }
      if(k==='trail' || k==='trailthickness'){ trailThickness=Math.max(1,Math.round(numOr(val,2))); document.getElementById('trailThickness').value=trailThickness; return; }
      if(k==='seed'){ reseed(Math.round(numOr(val,seed))); return; }

      // Camera and panes
      if(k==='zooml'){ zoomLeft=numOr(val,1); document.getElementById('zoomLeftCtl').value=zoomLeft; return; }
      if(k==='zoomr'){ zoomRight=numOr(val,1); document.getElementById('zoomRightCtl').value=zoomRight; return; }
      if(k==='panlx'){ panLeftX=Math.round(numOr(val,0)); document.getElementById('panLeftXCtl').value=panLeftX; return; }
      if(k==='panly'){ panLeftY=Math.round(numOr(val,0)); document.getElementById('panLeftYCtl').value=panLeftY; return; }
      if(k==='panrx'){ panRightX=Math.round(numOr(val,0)); document.getElementById('panRightXCtl').value=panRightX; return; }
      if(k==='panry'){ panRightY=Math.round(numOr(val,0)); document.getElementById('panRightYCtl').value=panRightY; return; }
      if(k==='freerotx'){ freeRotX=numOr(val,freeRotX); return; }
      if(k==='freeroty'){ freeRotY=numOr(val,freeRotY); return; }

      // Goal programming
      if(k==='goal'){
        const v=val.toLowerCase();
        if(v==='random'){ goal={node:pickRandomNode()}; for(const b of bots) planPath(b, goal.node); return; }
        let mm=v.match(/^node:(\d+)$/); if(mm){ setGoalByNode(parseInt(mm[1],10)); return; }
        mm=v.match(/^tower:(\d+)\s*,\s*level:(\d+)$/); if(mm){ setGoalByTowerLevel(parseInt(mm[1],10), parseInt(mm[2],10)); return; }
        return;
      }

      // Bot counts via DSL: green.count=K, orange.count=K  (regenerates)
      const mCount = k.match(/^(green|orange)\.count$/);
      if(mCount){ const name=mCount[1]; const cnt=Math.max(0, Math.floor(numOr(val,1))); botCounts[name]=cnt; generateCity(); return; }

      // Green impairment scaler: green.impair or green.impairscale  (regenerates)
      if(k==='green.impair' || k==='green.impairscale'){ greenImpairScale = Math.max(0, numOr(val,1)); generateCity(); return; }

      // Bot programming: supports green.* and orange.* for per-property overrides (applies now + persists)
      const botM=k.match(/^(green|orange)\.(.+)$/);
      if(botM){ const name=botM[1]; const prop=botM[2]; const target=(bots.find(b=>b.name===name))||null; const nval=numOr(val,NaN); const asNumber=!isNaN(nval);
        const assign=(obj)=>{ if(asNumber) obj[prop]=nval; else obj[prop]=(parseBool(val)?true:(val)); };
        if(target){ assign(target); }
        assign(botOverrides[name]); // persist across regenerations
        return;
      }
      // Unknown keys are ignored for now
    }

    // --- Tests (optional) ---
    function runTests(){
      const P=params(), lines=[];
      // A: bridges connectivity (loose)
      let okB=true;
      if(P.bridgesOn){ for(const t of towers){ const inc=bridges.some(br=>br.a===t||br.b===t); if(!inc) okB=false; } }
      lines.push(`A/bridges: ${P.bridgesOn?(okB?'âœ“ all towers connected':'âœ— some towers unconnected'):'â€” (disabled)'}`);
      // B: bounds
      let okC=true;
      for(const t of towers){ if(t.gx<0||t.gx>=GRID||t.gz<0||t.gz>=GRID||t.maxH>LEVELS) okC=false; }
      lines.push(`B/grid-bounds: ${okC?'âœ“':'âœ— out-of-bounds tower found'}`);
      // C: random reachability
      if(navNodes.length>1){ const a=pickRandomNode(), b=pickRandomNode(a); const reachable=bfsReachable(a,b); lines.push(`C/path(${a}->${b}): ${reachable?'âœ“ reachable':'âœ— no path'}`);}
      const summary=`Tests ${((okB||!params().bridgesOn)&&okC)?'PASSED':'HAS ISSUES'}`;
      testPanel().textContent=(SHOW_TESTS?(summary+'\n'+lines.join('\n')):'');
      if(SHOW_TESTS){ console.clear(); console.group('Brutalist City â€” Tests'); console.log(summary); for(const ln of lines) console.log(ln); console.groupEnd(); }
    }
    function bfsReachable(src,dst){
      const seen=new Set([src]); const q=[src];
      while(q.length){ const u=q.shift(); if(u===dst) return true; for(const v of navAdj[u]) if(!seen.has(v)){ seen.add(v); q.push(v);} }
      return false;
    }
  </script>
</body>
</html>

