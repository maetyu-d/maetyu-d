<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Perching Robot Simulator</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #111;
            color: #fff;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            font-family: 'Consolas', 'Courier New', monospace;
            overflow: hidden;
        }
        canvas {
            background: linear-gradient(to bottom, #87CEEB 0%, #d3e9f4 70%, #B0C4DE 100%);
            border: 2px solid #fff;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
        }
        #ui-container {
            position: absolute;
            top: 20px;
            left: 20px;
            width: calc(100% - 40px);
            display: flex;
            justify-content: space-between;
            pointer-events: none;
        }
        .hud {
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid rgba(255,255,255,0.3);
            text-shadow: 1px 1px 2px black;
        }
        #instructions {
            font-size: 0.9em;
        }
        #status {
            text-align: right;
        }
        .energy-bar-container {
            width: 150px;
            height: 20px;
            background-color: #555;
            border: 1px solid #fff;
            border-radius: 3px;
            margin-top: 5px;
        }
        #energy-bar {
            width: 100%;
            height: 100%;
            background-color: #4CAF50;
            transition: width 0.2s linear;
        }
    </style>
</head>
<body>

    <div id="ui-container">
        <div id="instructions" class="hud">
            <strong>CONTROLS:</strong><br>
            [SPACE] Hold to Flap (Thrust)<br>
            [W] / [S] Wing Pitch Up/Down (Lift)<br>
            [A] / [D] Body Pitch Left/Right<br>
            [P] Hold near Perch to Stall & Land<br>
            [R] Reset Simulation
        </div>
        <div id="status" class="hud">
            <strong>ROBOT STATUS:</strong><br>
            <span>Energy:</span>
            <div class="energy-bar-container">
                <div id="energy-bar"></div>
            </div>
            <span id="wing-pitch-readout">Wing Pitch: 0.0°</span><br>
            <span id="velocity-readout">Velocity: 0.0 m/s</span><br>
            <span id="state-readout">State: Grounded</span>
        </div>
    </div>

    <canvas id="gameCanvas" width="1000" height="600"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // --- UI Elements ---
        const energyBar = document.getElementById('energy-bar');
        const wingPitchReadout = document.getElementById('wing-pitch-readout');
        const velocityReadout = document.getElementById('velocity-readout');
        const stateReadout = document.getElementById('state-readout');

        // --- Research-Based Physics Parameters ---
        const config = {
            gravity: 0.15,
            liftFactor: 0.005,
            thrustFactor: 0.003,
            dragCoefficient: 0.995,
            inducedDragFactor: 0.01,
            flapEnergyCost: 0.3,
            glideEnergyGain: 0.05,
            perchEnergyGain: 2.0,
            maxEnergy: 100,
            maxWingPitch: 45,
            minWingPitch: -10,
            stallPitch: 70,
            perchRange: 80
        };

        let robotBird = {};
        let perches = [];
        let keys = {};
        let gameState = 'grounded'; // grounded, flying, perching, perched

        function createRobotBird() {
            return {
                x: 100,
                y: canvas.height - 50,
                vx: 0,
                vy: 0,
                width: 40,
                height: 15,
                angle: 0,
                wingAngle: 0,
                wingPitch: 0,
                flapFrequency: 0,
                flapSpeed: 15,
                energy: config.maxEnergy,
            };
        }

        function createPerches() {
            return [
                { x: 400, y: 450, width: 150, height: 20 },
                { x: 750, y: 300, width: 200, height: 20 },
                { x: 50, y: 200, width: 100, height: 20 }
            ];
        }
        
        function resetSimulation() {
            robotBird = createRobotBird();
            perches = createPerches();
            gameState = 'grounded';
        }

        window.addEventListener('keydown', (e) => { keys[e.code] = true; });
        window.addEventListener('keyup', (e) => { keys[e.code] = false; });
        
        function applyFlightPhysics() {
            // --- Control Inputs ---
            if (keys['Space'] && robotBird.energy > 0) {
                robotBird.flapFrequency = Math.min(1, robotBird.flapFrequency + 0.1);
                robotBird.energy -= config.flapEnergyCost;
            } else {
                robotBird.flapFrequency = Math.max(0, robotBird.flapFrequency - 0.05);
                robotBird.energy = Math.min(config.maxEnergy, robotBird.energy + config.glideEnergyGain);
            }
            if (keys['KeyW']) robotBird.wingPitch = Math.min(config.maxWingPitch, robotBird.wingPitch + 1);
            if (keys['KeyS']) robotBird.wingPitch = Math.max(config.minWingPitch, robotBird.wingPitch - 1);
            if (keys['KeyA']) robotBird.angle = Math.max(-30, robotBird.angle - 1);
            if (keys['KeyD']) robotBird.angle = Math.min(30, robotBird.angle + 1);

            // --- Physics Simulation ---
            const bodyAngleRad = robotBird.angle * Math.PI / 180;
            const wingPitchRad = robotBird.wingPitch * Math.PI / 180;

            const thrust = robotBird.flapFrequency * config.thrustFactor;
            robotBird.vx += Math.cos(bodyAngleRad) * thrust;
            robotBird.vy += Math.sin(bodyAngleRad) * thrust;
            
            const lift = robotBird.flapFrequency * Math.abs(Math.sin(wingPitchRad)) * config.liftFactor * (1 - Math.abs(robotBird.vx)/20);
            robotBird.vy -= lift;
            robotBird.vy += config.gravity;

            robotBird.vx *= config.dragCoefficient;
            robotBird.vy *= config.dragCoefficient;
            const inducedDrag = Math.abs(robotBird.wingPitch / config.maxWingPitch) * config.inducedDragFactor * (robotBird.vx**2);
            robotBird.vx -= inducedDrag * Math.sign(robotBird.vx);

            // --- Update Position ---
            robotBird.x += robotBird.vx;
            robotBird.y += robotBird.vy;
        }

        function update() {
            if (keys['KeyR']) {
                resetSimulation();
                return;
            }

            // --- State Machine ---
            if (gameState === 'grounded' || gameState === 'perched') {
                if (gameState === 'perched') {
                    robotBird.energy = Math.min(config.maxEnergy, robotBird.energy + config.perchEnergyGain);
                }
                if (keys['Space']) { // Takeoff
                    gameState = 'flying';
                    robotBird.vy = -5;
                }
            } else if (gameState === 'flying') {
                const closestPerch = getClosestPerch();
                const canPerch = closestPerch && getDistance(robotBird, {x: closestPerch.x + closestPerch.width/2, y: closestPerch.y}) < config.perchRange;

                if (keys['KeyP'] && canPerch) {
                    gameState = 'perching';
                } else {
                    applyFlightPhysics();
                }

            } else if (gameState === 'perching') {
                const closestPerch = getClosestPerch();
                if (!keys['KeyP'] || !closestPerch || getDistance(robotBird, {x: closestPerch.x + closestPerch.width/2, y: closestPerch.y}) > config.perchRange + 20) {
                    gameState = 'flying'; // Abort perch
                    return;
                }
                
                // Stall Dynamics
                robotBird.angle = -config.stallPitch;
                robotBird.vx *= 0.9; 
                robotBird.vy *= 0.95;
                robotBird.vy += config.gravity * 0.5; // Still affected by some gravity
                robotBird.x += robotBird.vx;
                robotBird.y += robotBird.vy;

                // Check for successful landing
                if (robotBird.x > closestPerch.x && robotBird.x < closestPerch.x + closestPerch.width &&
                    robotBird.y > closestPerch.y - robotBird.height && robotBird.y < closestPerch.y + closestPerch.height) {
                    gameState = 'perched';
                    robotBird.vx = 0;
                    robotBird.vy = 0;
                    robotBird.angle = 0;
                    robotBird.wingPitch = 0;
                    robotBird.y = closestPerch.y - robotBird.height / 2;
                }
            }
            
            // Universal Checks (apply to flying/perching states)
            if (gameState === 'flying' || gameState === 'perching') {
                 if (robotBird.y > canvas.height - robotBird.height / 2) {
                    gameState = 'grounded';
                    robotBird.vx = 0; robotBird.vy = 0;
                    robotBird.y = canvas.height - robotBird.height / 2;
                }
                if (robotBird.energy <= 0) {
                    gameState = 'flying'; // fall gracefully
                }
                if (robotBird.x > canvas.width) robotBird.x = 0;
                if (robotBird.x < 0) robotBird.x = canvas.width;
            }
        }
        
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const closestPerch = getClosestPerch();
            const canPerch = closestPerch && getDistance(robotBird, {x: closestPerch.x + closestPerch.width/2, y: closestPerch.y}) < config.perchRange;
            
            perches.forEach(perch => {
                ctx.fillStyle = (canPerch && perch === closestPerch && gameState === 'flying') ? '#FFFF00' : '#8B4513';
                ctx.fillRect(perch.x, perch.y, perch.width, perch.height);
                ctx.strokeStyle = '#654321';
                ctx.strokeRect(perch.x, perch.y, perch.width, perch.height);
            });

            ctx.save();
            ctx.translate(robotBird.x, robotBird.y);
            ctx.rotate(robotBird.angle * Math.PI / 180);

            robotBird.wingAngle = robotBird.flapFrequency > 0 ? Math.sin(Date.now() / (100 / robotBird.flapSpeed)) * (30 + robotBird.flapFrequency * 20) : 0;
            
            drawWing(robotBird.wingPitch - robotBird.wingAngle);
            ctx.scale(1, -1);
            drawWing(robotBird.wingPitch + robotBird.wingAngle);
            ctx.restore();

            ctx.save();
            ctx.translate(robotBird.x, robotBird.y);
            ctx.rotate(robotBird.angle * Math.PI / 180);
            ctx.fillStyle = '#B0C4DE';
            ctx.beginPath();
            ctx.ellipse(0, 0, robotBird.width / 2, robotBird.height / 2, 0, 0, 2 * Math.PI);
            ctx.fill();
            ctx.strokeStyle = '#465362';
            ctx.stroke();
            ctx.fillStyle = '#00FFFF';
            ctx.beginPath();
            ctx.arc(robotBird.width / 3, 0, 3, 0, 2 * Math.PI);
            ctx.fill();
            ctx.restore();
            
            updateHUD();
        }

        function drawWing(rotation) {
            ctx.save();
            ctx.rotate(rotation * Math.PI / 180);
            ctx.fillStyle = '#DCDCDC';
            ctx.strokeStyle = '#808080';
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(25, 5);
            ctx.lineTo(35, 0);
            ctx.lineTo(25, -5);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            ctx.restore();
        }
        
        function updateHUD() {
            energyBar.style.width = robotBird.energy + '%';
            energyBar.style.backgroundColor = robotBird.energy < 20 ? '#FF0000' : '#4CAF50';
            wingPitchReadout.textContent = `Wing Pitch: ${robotBird.wingPitch.toFixed(1)}°`;
            const totalVelocity = Math.sqrt(robotBird.vx**2 + robotBird.vy**2);
            velocityReadout.textContent = `Velocity: ${(totalVelocity * 10).toFixed(1)} m/s`;
            stateReadout.textContent = `State: ${gameState.toUpperCase()}`;
        }

        function getClosestPerch() {
            if (perches.length === 0) return null;
            return perches.reduce((closest, perch) => {
                const dist = getDistance(robotBird, {x: perch.x + perch.width/2, y: perch.y});
                const closestDist = getDistance(robotBird, {x: closest.x + closest.width/2, y: closest.y});
                return dist < closestDist ? perch : closest;
            });
        }
        
        function getDistance(obj1, obj2) {
            return Math.sqrt((obj1.x - obj2.x)**2 + (obj1.y - obj2.y)**2);
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        resetSimulation();
        gameLoop();
    </script>
</body>
</html>
