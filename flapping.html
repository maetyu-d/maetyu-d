<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Perching Robot Simulator</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #111;
            color: #fff;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            font-family: 'Consolas', 'Courier New', monospace;
            overflow: hidden;
        }
        canvas {
            background: linear-gradient(to bottom, #87CEEB 0%, #d3e9f4 70%, #B0C4DE 100%);
            border: 2px solid #fff;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
        }
        #ui-container {
            position: absolute;
            top: 20px;
            left: 20px;
            width: calc(100% - 40px);
            display: flex;
            justify-content: space-between;
            pointer-events: none; /* Pass clicks through to canvas */
        }
        .hud {
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid rgba(255,255,255,0.3);
            text-shadow: 1px 1px 2px black;
            pointer-events: auto; /* Re-enable events for this element */
        }
        #instructions {
            font-size: 0.9em;
        }
        #status {
            text-align: right;
        }
        .energy-bar-container {
            width: 150px;
            height: 20px;
            background-color: #555;
            border: 1px solid #fff;
            border-radius: 3px;
            margin-top: 5px;
        }
        #energy-bar {
            width: 100%;
            height: 100%;
            background-color: #4CAF50;
            transition: width 0.2s linear;
        }
        /* Styles for the new slider panel */
        #sliders-container {
            position: absolute;
            top: 180px;
            left: 20px;
        }
        .slider-group {
            margin-bottom: 5px;
            display: grid;
            grid-template-columns: 100px 1fr 50px;
            align-items: center;
            font-size: 0.9em;
        }
        .slider-group label {
            text-align: right;
            margin-right: 10px;
        }
        .slider-group input[type=range] {
            width: 120px;
        }
        #reset-physics-btn {
            margin-top: 10px;
            width: 100%;
            padding: 5px;
            background-color: #c0392b;
            border: 1px solid #e74c3c;
            color: white;
            border-radius: 3px;
            cursor: pointer;
        }
        #reset-physics-btn:hover {
            background-color: #e74c3c;
        }
    </style>
</head>
<body>

    <div id="ui-container">
        <div id="instructions" class="hud">
            <strong>CONTROLS:</strong><br>
            [SPACE] Hold to Flap (Forward Thrust)<br>
            [W] / [S] Wing Pitch (Up/Down Lift)<br>
            [A] / [D] Body Pitch/Turn<br>
            [P] Hold near Perch to Land<br>
            [R] Reset Simulation
        </div>
        <div id="status" class="hud">
            <strong>ROBOT STATUS:</strong><br>
            <span>Energy:</span>
            <div class="energy-bar-container">
                <div id="energy-bar"></div>
            </div>
            <span id="wing-pitch-readout">Wing Pitch: 0.0Â°</span><br>
            <span id="velocity-readout">Velocity: 0.0 m/s</span><br>
            <span id="state-readout">State: Grounded</span>
        </div>
    </div>
    
    <!-- New Physics Sliders Panel -->
    <div id="sliders-container" class="hud">
        <strong>PHYSICS PARAMETERS:</strong>
        <div class="slider-group">
            <label for="gravity-slider">Gravity:</label>
            <input type="range" id="gravity-slider" min="0.05" max="0.8" step="0.01">
            <span id="gravity-value">0.25</span>
        </div>
        <div class="slider-group">
            <label for="lift-slider">Lift Factor:</label>
            <input type="range" id="lift-slider" min="0.1" max="1.5" step="0.05">
            <span id="lift-value">0.70</span>
        </div>
        <div class="slider-group">
            <label for="thrust-slider">Thrust Factor:</label>
            <input type="range" id="thrust-slider" min="0.05" max="0.5" step="0.01">
            <span id="thrust-value">0.25</span>
        </div>
        <div class="slider-group">
            <label for="drag-slider">Drag Coeff:</label>
            <input type="range" id="drag-slider" min="0.95" max="0.999" step="0.001">
            <span id="drag-value">0.99</span>
        </div>
        <button id="reset-physics-btn">Reset Physics</button>
    </div>

    <canvas id="gameCanvas" width="1000" height="600"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const energyBar = document.getElementById('energy-bar');
        const wingPitchReadout = document.getElementById('wing-pitch-readout');
        const velocityReadout = document.getElementById('velocity-readout');
        const stateReadout = document.getElementById('state-readout');

        // --- Default Physics Configuration ---
        const defaultConfig = {
            gravity: 0.25,
            liftFactor: 0.7,
            thrustFactor: 0.25,
            dragCoefficient: 0.99,
            flapEnergyCost: 0.25,
            glideEnergyGain: 0.05,
            perchEnergyGain: 2.0,
            maxEnergy: 100,
            maxWingPitch: 60,
            minWingPitch: -20,
            stallPitch: 70,
            perchRange: 80
        };
        
        // --- Live Config Object (will be modified by sliders) ---
        let config = { ...defaultConfig };

        let robotBird = {};
        let perches = [];
        let keys = {};
        let gameState = 'grounded';

        function createRobotBird() {
            return {
                x: 100, y: canvas.height - 50, vx: 0, vy: 0,
                width: 40, height: 15, angle: 0, wingAngle: 0,
                wingPitch: 0, flapFrequency: 0, flapSpeed: 15,
                energy: config.maxEnergy,
            };
        }

        function createPerches() {
            return [
                { x: 450, y: 450, width: 150, height: 20 },
                { x: 800, y: 300, width: 200, height: 20 },
                { x: 100, y: 250, width: 100, height: 20 }
            ];
        }
        
        function resetSimulation() {
            robotBird = createRobotBird();
            perches = createPerches();
            gameState = 'grounded';
        }

        window.addEventListener('keydown', (e) => { keys[e.code] = true; });
        window.addEventListener('keyup', (e) => { keys[e.code] = false; });
        
        function applyFlightPhysics() {
            if (keys['Space'] && robotBird.energy > 0) {
                robotBird.flapFrequency = Math.min(1, robotBird.flapFrequency + 0.1);
                robotBird.energy -= config.flapEnergyCost;
            } else {
                robotBird.flapFrequency = Math.max(0, robotBird.flapFrequency - 0.05);
                robotBird.energy = Math.min(config.maxEnergy, robotBird.energy + config.glideEnergyGain);
            }
            if (keys['KeyW']) robotBird.wingPitch = Math.min(config.maxWingPitch, robotBird.wingPitch + 1.5);
            if (keys['KeyS']) robotBird.wingPitch = Math.max(config.minWingPitch, robotBird.wingPitch - 1.5);
            if (keys['KeyA']) robotBird.angle = Math.max(-45, robotBird.angle - 1.5);
            if (keys['KeyD']) robotBird.angle = Math.min(45, robotBird.angle + 1.5);

            const bodyAngleRad = robotBird.angle * Math.PI / 180;
            const wingPitchRad = robotBird.wingPitch * Math.PI / 180;

            const thrust = robotBird.flapFrequency * config.thrustFactor;
            robotBird.vx += Math.cos(bodyAngleRad) * thrust;
            robotBird.vy += Math.sin(bodyAngleRad) * thrust;
            
            const lift = robotBird.flapFrequency * Math.abs(Math.sin(wingPitchRad)) * config.liftFactor;
            robotBird.vy -= lift; 
            
            robotBird.vy += config.gravity;

            robotBird.vx *= config.dragCoefficient;
            robotBird.vy *= config.dragCoefficient;

            robotBird.x += robotBird.vx;
            robotBird.y += robotBird.vy;
        }

        function update() {
            if (keys['KeyR']) { resetSimulation(); return; }

            if (gameState === 'grounded' || gameState === 'perched') {
                if (gameState === 'perched') robotBird.energy = Math.min(config.maxEnergy, robotBird.energy + config.perchEnergyGain);
                if (keys['Space']) {
                    gameState = 'flying';
                    robotBird.vy = -6;
                }
            } else if (gameState === 'flying') {
                const closestPerch = getClosestPerch();
                const canPerch = closestPerch && getDistance(robotBird, {x: closestPerch.x + closestPerch.width/2, y: closestPerch.y}) < config.perchRange;

                if (keys['KeyP'] && canPerch) {
                    gameState = 'perching';
                } else {
                    applyFlightPhysics();
                }

            } else if (gameState === 'perching') {
                const closestPerch = getClosestPerch();
                if (!keys['KeyP'] || !closestPerch || getDistance(robotBird, {x: closestPerch.x + closestPerch.width/2, y: closestPerch.y}) > config.perchRange + 20) {
                    gameState = 'flying';
                    return;
                }
                
                robotBird.angle = -config.stallPitch;
                robotBird.vx *= 0.92; 
                robotBird.vy *= 0.95;
                robotBird.vy += config.gravity * 0.5;
                robotBird.x += robotBird.vx;
                robotBird.y += robotBird.vy;

                if (robotBird.x > closestPerch.x && robotBird.x < closestPerch.x + closestPerch.width &&
                    robotBird.y > closestPerch.y - robotBird.height && robotBird.y < closestPerch.y + closestPerch.height) {
                    gameState = 'perched';
                    robotBird.vx = 0; robotBird.vy = 0; robotBird.angle = 0;
                    robotBird.wingPitch = 0; robotBird.y = closestPerch.y - robotBird.height / 2;
                }
            }
            
            if (gameState === 'flying' || gameState === 'perching') {
                 if (robotBird.y > canvas.height - robotBird.height) {
                    gameState = 'grounded';
                    robotBird.vx = 0; robotBird.vy = 0;
                    robotBird.y = canvas.height - robotBird.height;
                }
                if (robotBird.energy <= 0) gameState = 'flying';
                if (robotBird.x > canvas.width) robotBird.x = 0;
                if (robotBird.x < 0) robotBird.x = canvas.width;
            }
        }
        
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const closestPerch = getClosestPerch();
            const canPerch = closestPerch && getDistance(robotBird, {x: closestPerch.x + closestPerch.width/2, y: closestPerch.y}) < config.perchRange;
            
            perches.forEach(perch => {
                ctx.fillStyle = (canPerch && perch === closestPerch && gameState === 'flying') ? '#FFFF00' : '#8B4513';
                ctx.fillRect(perch.x, perch.y, perch.width, perch.height);
            });

            ctx.save();
            ctx.translate(robotBird.x, robotBird.y);
            ctx.rotate(robotBird.angle * Math.PI / 180);
            robotBird.wingAngle = robotBird.flapFrequency > 0 ? Math.sin(Date.now() / (100 / robotBird.flapSpeed)) * (30 + robotBird.flapFrequency * 20) : 0;
            drawWing(robotBird.wingPitch - robotBird.wingAngle);
            ctx.scale(1, -1);
            drawWing(robotBird.wingPitch + robotBird.wingAngle);
            ctx.restore();

            ctx.save();
            ctx.translate(robotBird.x, robotBird.y);
            ctx.rotate(robotBird.angle * Math.PI / 180);
            ctx.fillStyle = '#B0C4DE';
            ctx.beginPath();
            ctx.ellipse(0, 0, robotBird.width / 2, robotBird.height / 2, 0, 0, 2 * Math.PI);
            ctx.fill();
            ctx.strokeStyle = '#465362'; ctx.stroke();
            ctx.fillStyle = '#00FFFF';
            ctx.beginPath();
            ctx.arc(robotBird.width / 3, 0, 3, 0, 2 * Math.PI);
            ctx.fill();
            ctx.restore();
            
            updateHUD();
        }

        function drawWing(rotation) {
            ctx.save();
            ctx.rotate(rotation * Math.PI / 180);
            ctx.fillStyle = '#DCDCDC';
            ctx.strokeStyle = '#808080';
            ctx.beginPath();
            ctx.moveTo(0, 0); ctx.lineTo(25, 5);
            ctx.lineTo(35, 0); ctx.lineTo(25, -5);
            ctx.closePath(); ctx.fill(); ctx.stroke();
            ctx.restore();
        }
        
        function updateHUD() {
            energyBar.style.width = robotBird.energy + '%';
            energyBar.style.backgroundColor = robotBird.energy < 20 ? '#FF0000' : '#4CAF50';
            wingPitchReadout.textContent = `Wing Pitch: ${robotBird.wingPitch.toFixed(1)}Â°`;
            const totalVelocity = Math.sqrt(robotBird.vx**2 + robotBird.vy**2);
            velocityReadout.textContent = `Velocity: ${(totalVelocity * 5).toFixed(1)} m/s`;
            stateReadout.textContent = `State: ${gameState.toUpperCase()}`;
        }

        function getClosestPerch() {
            if (perches.length === 0) return null;
            return perches.reduce((closest, perch) => {
                const dist = getDistance(robotBird, {x: perch.x + perch.width/2, y: perch.y});
                const closestDist = getDistance(robotBird, {x: closest.x + closest.width/2, y: closest.y});
                return dist < closestDist ? perch : closest;
            });
        }
        
        function getDistance(obj1, obj2) {
            return Math.sqrt((obj1.x - obj2.x)**2 + (obj1.y - obj2.y)**2);
        }

        // --- New Slider Setup Function ---
        function setupSliders() {
            const sliders = {
                'gravity-slider': { key: 'gravity', valueEl: 'gravity-value', decimals: 2 },
                'lift-slider': { key: 'liftFactor', valueEl: 'lift-value', decimals: 2 },
                'thrust-slider': { key: 'thrustFactor', valueEl: 'thrust-value', decimals: 2 },
                'drag-slider': { key: 'dragCoefficient', valueEl: 'drag-value', decimals: 3 }
            };

            for (const [sliderId, data] of Object.entries(sliders)) {
                const slider = document.getElementById(sliderId);
                const valueEl = document.getElementById(data.valueEl);
                
                // Set initial slider position from config
                slider.value = config[data.key];
                valueEl.textContent = parseFloat(slider.value).toFixed(data.decimals);

                // Add event listener
                slider.addEventListener('input', (e) => {
                    const newValue = parseFloat(e.target.value);
                    config[data.key] = newValue;
                    valueEl.textContent = newValue.toFixed(data.decimals);
                });
            }
            
            document.getElementById('reset-physics-btn').addEventListener('click', () => {
                config = { ...defaultConfig };
                // Re-run setup to update slider positions and values
                setupSliders();
            });
        }

        function gameLoop() {
            requestAnimationFrame(gameLoop);
            update();
            draw();
        }

        // --- Initialize ---
        resetSimulation();
        setupSliders();
        gameLoop();
    </script>
</body>
</html>

