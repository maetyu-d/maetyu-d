<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Circular Rhythm App</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827; /* Tailwind gray-900 */
            color: #E5E7EB; /* Tailwind gray-200 */
            overscroll-behavior: none;
        }
        .control-panel {
            background-color: rgba(31, 41, 55, 0.5); /* Tailwind gray-800 with opacity */
            backdrop-filter: blur(10px);
            border: 1px solid rgba(75, 85, 99, 0.5); /* Tailwind gray-600 with opacity */
        }
        .sound-btn.active {
            background-color: #F97316; /* Tailwind orange-500 */
            color: #111827;
            box-shadow: 0 0 15px rgba(249, 115, 22, 0.5);
        }
        .pattern-slot {
            background-color: #374151; /* gray-700 */
            border: 2px solid transparent;
            transition: all 0.2s ease-in-out;
        }
        .pattern-slot.active {
            border-color: #F97316; /* orange-500 */
            box-shadow: 0 0 10px rgba(249, 115, 22, 0.5);
        }
        .pattern-slot.filled {
            background-color: #4f46e5; /* indigo-600 */
        }
        .slider-container label {
            text-transform: uppercase;
            font-size: 0.75rem;
            letter-spacing: 0.1em;
            color: #9CA3AF; /* Tailwind gray-400 */
        }
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 6px;
            background: #374151; /* Tailwind gray-700 */
            border-radius: 3px;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
        }
        input[type="range"]:hover {
            opacity: 1;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: #F97316; /* Tailwind orange-500 */
            cursor: pointer;
            border-radius: 50%;
            border: 2px solid #111827;
        }
        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: #F97316; /* Tailwind orange-500 */
            cursor: pointer;
            border-radius: 50%;
            border: 2px solid #111827;
        }
        .transport-btn {
            background-color: #374151;
            border: 1px solid #4B5563;
            transition: all 0.2s ease-in-out;
        }
        .transport-btn:hover {
            background-color: #4B5563;
            transform: scale(1.05);
        }
        .transport-btn.playing {
            background-color: #10B981; /* Tailwind emerald-500 */
            box-shadow: 0 0 15px rgba(16, 185, 129, 0.5);
        }
        #bpm-display, #steps-display {
            background-color: #1F2937;
            border: 1px solid #4B5563;
        }
    </style>
</head>
<body class="overflow-hidden flex flex-col h-screen">

    <div id="loading-overlay" class="fixed inset-0 bg-gray-900 bg-opacity-80 flex items-center justify-center z-50 transition-opacity duration-500">
        <div class="text-center">
            <svg class="animate-spin h-10 w-10 text-orange-500 mx-auto" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            <p class="mt-4 text-lg text-gray-300">Initializing Audio Engine... Click to start.</p>
        </div>
    </div>

    <!-- Top Bar for Global Controls -->
    <div class="w-full p-2 flex justify-center items-center gap-4 control-panel rounded-b-lg flex-wrap">
        <span class="text-sm text-gray-400 font-semibold">BPM</span>
        <div id="bpm-display" class="px-3 py-1 rounded-md text-lg font-mono">120</div>
        <input id="bpmSlider" type="range" min="40" max="200" value="120" class="w-1/3 max-w-xs">
        
        <span class="text-sm text-gray-400 font-semibold ml-4">STEPS</span>
        <div id="steps-display" class="px-3 py-1 rounded-md text-lg font-mono">16</div>
        <input id="stepsSlider" type="range" min="4" max="32" value="16" step="1" class="w-1/3 max-w-xs">
    </div>

    <!-- Main Content Area -->
    <div class="w-full flex-grow flex flex-col md:flex-row items-center justify-around p-2 md:p-4 gap-4">

        <!-- Left Panel: Sound Selection & Patterns -->
        <div id="sound-panel" class="control-panel w-full md:w-1/6 h-auto md:h-full rounded-lg p-4 flex flex-col gap-2 md:gap-3 overflow-y-auto">
            <h2 class="text-lg font-bold text-gray-300 border-b border-gray-600 pb-2 mb-2">PATTERNS</h2>
            <div id="pattern-controls" class="grid grid-cols-4 gap-2 mb-4">
                <!-- Pattern slots will be generated here -->
            </div>
            <div class="flex gap-2">
                <button id="saveBtn" class="flex-1 p-2 rounded-md bg-blue-600 hover:bg-blue-500 transition-colors text-sm font-semibold">SAVE</button>
                <button id="clearBtn" class="flex-1 p-2 rounded-md bg-red-600 hover:bg-red-500 transition-colors text-sm font-semibold">CLEAR</button>
            </div>
            <h2 class="text-lg font-bold text-gray-300 border-b border-gray-600 pb-2 my-2">DRUM KIT</h2>
            <div id="drum-kit-buttons" class="flex-grow flex flex-col gap-2">
                 <!-- Sound buttons will be injected here -->
            </div>
        </div>

        <!-- Center Panel: Sequencer -->
        <div class="w-full md:w-auto h-2/3 md:h-full flex-grow flex flex-col items-center justify-center gap-4 relative">
            <canvas id="sequencerCanvas"></canvas>
            <div class="absolute flex flex-col items-center justify-center gap-4">
                 <button id="playBtn" class="transport-btn w-20 h-20 md:w-24 md:h-24 rounded-full flex items-center justify-center text-white">
                    <svg xmlns="http://www.w3.org/2000/svg" class="w-10 h-10 md:w-12 md:h-12" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd" />
                    </svg>
                </button>
            </div>
        </div>

        <!-- Right Panel: Parameters -->
        <div id="param-panel" class="control-panel w-full md:w-1/6 h-auto md:h-full rounded-lg p-4 flex flex-col gap-4 overflow-y-auto">
             <h2 class="text-lg font-bold text-gray-300 border-b border-gray-600 pb-2 mb-2">SOUND FX</h2>
            <div class="slider-container flex-1">
                <label for="attackSlider">Attack</label>
                <input id="attackSlider" type="range" min="1" max="100" value="5">
            </div>
            <div class="slider-container flex-1">
                <label for="decaySlider">Decay</label>
                <input id="decaySlider" type="range" min="1" max="100" value="50">
            </div>
            <div class="slider-container flex-1">
                <label for="sustainSlider">Sustain</label>
                <input id="sustainSlider" type="range" min="1" max="100" value="50">
            </div>
            <div class="slider-container flex-1">
                <label for="releaseSlider">Release</label>
                <input id="releaseSlider" type="range" min="1" max="100" value="20">
            </div>
             <div class="slider-container flex-1">
                <label for="pitchSlider">Pitch</label>
                <input id="pitchSlider" type="range" min="-24" max="24" value="0">
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM ELEMENTS ---
            const canvas = document.getElementById('sequencerCanvas');
            const ctx = canvas.getContext('2d');
            const playBtn = document.getElementById('playBtn');
            const bpmSlider = document.getElementById('bpmSlider');
            const bpmDisplay = document.getElementById('bpm-display');
            const stepsSlider = document.getElementById('stepsSlider');
            const stepsDisplay = document.getElementById('steps-display');
            const drumKitButtonsContainer = document.getElementById('drum-kit-buttons');
            const paramPanel = document.getElementById('param-panel');
            const loadingOverlay = document.getElementById('loading-overlay');
            const patternControls = document.getElementById('pattern-controls');
            const saveBtn = document.getElementById('saveBtn');
            const clearBtn = document.getElementById('clearBtn');

            // --- CONSTANTS & STATE ---
            const NUM_TRACKS = 6;
            const NUM_PATTERNS = 4;
            let numSteps = 16;
            let synths = [];
            let sequenceData = Array.from({ length: NUM_TRACKS }, () => new Array(numSteps).fill(false));
            let savedPatterns = {};
            let selectedPatternSlot = 0;
            let currentStep = 0;
            let selectedTrack = 0;
            let isPlaying = false;
            let isInitialized = false;
            let transportSequence = null;

            const SOUNDS = [
                { name: 'Kick', color: '#F97316', synth: () => new Tone.MembraneSynth({ pitchDecay: 0.05, octaves: 10, oscillator: { type: 'sine' }, envelope: { attack: 0.001, decay: 0.4, sustain: 0.01, release: 1.4, attackCurve: 'exponential' } }).toDestination() },
                { name: 'Snare', color: '#EC4899', synth: () => new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.005, decay: 0.2, sustain: 0 } }).toDestination() },
                { name: 'Hi-Hat', color: '#84CC16', synth: () => new Tone.MetalSynth({ frequency: 200, envelope: { attack: 0.001, decay: 0.1, release: 0.01 }, harmonicity: 5.1, modulationIndex: 32, resonance: 4000, octaves: 1.5 }).toDestination() },
                { name: 'Tom', color: '#3B82F6', synth: () => new Tone.MembraneSynth({ pitchDecay: 0.08, octaves: 6, oscillator: { type: 'sine' }, envelope: { attack: 0.01, decay: 0.3, sustain: 0.01, release: 1, attackCurve: 'exponential' } }).toDestination() },
                { name: 'Clap', color: '#EAB308', synth: () => new Tone.NoiseSynth({ noise: { type: 'pink' }, envelope: { attack: 0.001, decay: 0.15, sustain: 0, release: 0.2 } }).toDestination() },
                { name: 'Synth', color: '#A855F7', synth: () => new Tone.FMSynth({ harmonicity: 3, modulationIndex: 10, detune: 0, oscillator: { type: "sine" }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.5, release: 0.5 }, modulation: { type: "square" }, modulationEnvelope: { attack: 0.5, decay: 0, sustain: 1, release: 0.5 } }).toDestination() },
            ];

            // --- SEQUENCER & PATTERN LOGIC ---
            function updateSequencerLength(newLength) {
                const newStepCount = parseInt(newLength);
                stepsDisplay.textContent = newStepCount;

                // Resize the current sequence data grid
                sequenceData = sequenceData.map(trackData => {
                    const currentLength = trackData.length;
                    if (newStepCount > currentLength) {
                        return trackData.concat(new Array(newStepCount - currentLength).fill(false));
                    } else {
                        return trackData.slice(0, newStepCount);
                    }
                });
                
                numSteps = newStepCount;

                // If the audio engine is running, recreate the sequence with the new length
                if (isInitialized && transportSequence) {
                    const wasPlaying = isPlaying;
                    if (wasPlaying) Tone.Transport.stop();

                    transportSequence.dispose();
                    transportSequence = createSequence();
                    
                    if (wasPlaying) Tone.Transport.start();
                }
                draw();
            }

            function createSequence() {
                const steps = Array.from(Array(numSteps).keys());
                const subdivision = `${numSteps}n`;

                return new Tone.Sequence((time, step) => {
                    currentStep = step;
                    sequenceData.forEach((track, index) => {
                        if (track[step]) {
                            const synth = synths[index];
                            const duration = subdivision;
                            if (synth instanceof Tone.MembraneSynth || synth instanceof Tone.FMSynth) {
                                synth.triggerAttackRelease("C2", duration, time);
                            } else {
                                synth.triggerAttackRelease(duration, time);
                            }
                        }
                    });
                    Tone.Draw.schedule(draw, time);
                }, steps, subdivision).start(0);
            }

            function loadPatternsFromStorage() {
                const storedPatterns = localStorage.getItem('rhythm_app_patterns');
                savedPatterns = storedPatterns ? JSON.parse(storedPatterns) : {};
            }

            function savePatternsToStorage() {
                localStorage.setItem('rhythm_app_patterns', JSON.stringify(savedPatterns));
            }
            
            function updatePatternUI() {
                document.querySelectorAll('.pattern-slot').forEach((btn, index) => {
                    btn.classList.toggle('active', index === selectedPatternSlot);
                    btn.classList.toggle('filled', !!savedPatterns[index]);
                });
            }

            function selectPattern(slot) {
                selectedPatternSlot = slot;
                const pattern = savedPatterns[slot];
                if (pattern) {
                    let loadedData = JSON.parse(JSON.stringify(pattern));
                    // Adapt loaded pattern to the current step count
                    sequenceData = loadedData.map(trackData => {
                        const patternLength = trackData.length;
                        if (numSteps > patternLength) {
                            return trackData.concat(new Array(numSteps - patternLength).fill(false));
                        } else {
                            return trackData.slice(0, numSteps);
                        }
                    });
                } else {
                    clearSequence();
                }
                updatePatternUI();
                draw();
            }
            
            function saveCurrentPattern() {
                savedPatterns[selectedPatternSlot] = JSON.parse(JSON.stringify(sequenceData));
                savePatternsToStorage();
                updatePatternUI();
            }

            function clearSequence() {
                sequenceData = Array.from({ length: NUM_TRACKS }, () => new Array(numSteps).fill(false));
                draw();
            }

            function createPatternControls() {
                for (let i = 0; i < NUM_PATTERNS; i++) {
                    const btn = document.createElement('button');
                    btn.textContent = i + 1;
                    btn.className = 'pattern-slot p-2 rounded-md font-bold';
                    btn.dataset.slot = i;
                    btn.addEventListener('click', () => selectPattern(i));
                    patternControls.appendChild(btn);
                }
            }

            // --- INITIALIZATION ---
            function initialize() {
                if (isInitialized) return;
                isInitialized = true;

                SOUNDS.forEach((soundDef, i) => {
                    synths.push(soundDef.synth());
                    const btn = document.createElement('button');
                    btn.textContent = soundDef.name;
                    btn.className = 'sound-btn w-full text-left p-3 rounded-md transition-all duration-200';
                    btn.style.borderLeft = `5px solid ${soundDef.color}`;
                    if (i === selectedTrack) btn.classList.add('active');
                    btn.addEventListener('click', () => {
                        selectedTrack = i;
                        updateActiveSoundButton();
                        updateSlidersForTrack(i);
                    });
                    drumKitButtonsContainer.appendChild(btn);
                });
                
                updateSlidersForTrack(selectedTrack);
                Tone.Transport.bpm.value = parseInt(bpmSlider.value);
                
                transportSequence = createSequence();
                requestAnimationFrame(draw);
                
                loadingOverlay.style.opacity = '0';
                setTimeout(() => loadingOverlay.style.display = 'none', 500);
            }
            
            loadingOverlay.addEventListener('click', () => Tone.start().then(initialize));

            // --- UI & DRAWING ---
            function resizeCanvas() {
                const container = canvas.parentElement;
                const size = Math.min(container.clientWidth, container.clientHeight) * 0.95;
                canvas.width = size;
                canvas.height = size;
                draw();
            }

            function draw() {
                const width = canvas.width;
                const height = canvas.height;
                const center = { x: width / 2, y: height / 2 };
                const maxRadius = Math.min(width, height) / 2;
                const innerCoreRadius = maxRadius * 0.25;
                const ringAreaWidth = maxRadius - innerCoreRadius;
                const trackWidth = ringAreaWidth / NUM_TRACKS;
                
                ctx.clearRect(0, 0, width, height);

                for (let track = 0; track < NUM_TRACKS; track++) {
                    const outerRadius = maxRadius - track * trackWidth;
                    const innerRadius = outerRadius - trackWidth;
                    for (let step = 0; step < numSteps; step++) {
                        const startAngle = (step / numSteps) * 2 * Math.PI - Math.PI / 2;
                        const endAngle = ((step + 1) / numSteps) * 2 * Math.PI - Math.PI / 2;
                        
                        ctx.beginPath();
                        ctx.arc(center.x, center.y, outerRadius, startAngle, endAngle);
                        ctx.arc(center.x, center.y, innerRadius, endAngle, startAngle, true);
                        ctx.closePath();
                        ctx.fillStyle = sequenceData[track][step] ? SOUNDS[track].color : 'rgba(75, 85, 99, 0.3)';
                        ctx.fill();
                        ctx.strokeStyle = '#111827';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }
                }

                if (isPlaying) {
                    const angle = (currentStep / numSteps) * 2 * Math.PI - Math.PI / 2;
                    const nextAngle = ((currentStep + 1) / numSteps) * 2 * Math.PI - Math.PI / 2;
                    ctx.beginPath();
                    ctx.arc(center.x, center.y, maxRadius, angle, nextAngle);
                    ctx.arc(center.x, center.y, innerCoreRadius, nextAngle, angle, true);
                    ctx.closePath();
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                    ctx.fill();
                }
            }

            function updateActiveSoundButton() {
                document.querySelectorAll('.sound-btn').forEach((btn, index) => {
                    btn.classList.toggle('active', index === selectedTrack);
                });
            }

            // --- EVENT LISTENERS ---
            playBtn.addEventListener('click', () => {
                if (!isInitialized) return;
                isPlaying = !isPlaying;
                if (isPlaying) {
                    Tone.Transport.start();
                    playBtn.classList.add('playing');
                    playBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="w-10 h-10 md:w-12 md:h-12" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8 7a1 1 0 00-1 1v4a1 1 0 001 1h4a1 1 0 001-1V8a1 1 0 00-1-1H8z" clip-rule="evenodd" /></svg>`;
                } else {
                    Tone.Transport.stop();
                    currentStep = 0;
                    playBtn.classList.remove('playing');
                    playBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="w-10 h-10 md:w-12 md:h-12" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd" /></svg>`;
                }
                draw();
            });

            bpmSlider.addEventListener('input', (e) => {
                const newBpm = parseInt(e.target.value);
                bpmDisplay.textContent = newBpm;
                if (isInitialized) Tone.Transport.bpm.value = newBpm;
            });
            
            stepsSlider.addEventListener('input', (e) => updateSequencerLength(e.target.value));
            saveBtn.addEventListener('click', saveCurrentPattern);
            clearBtn.addEventListener('click', clearSequence);

            canvas.addEventListener('click', (e) => {
                if (!isInitialized) return;
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const x = (e.clientX - rect.left) * scaleX;
                const y = (e.clientY - rect.top) * scaleY;
                const center = { x: canvas.width / 2, y: canvas.height / 2 };
                const dx = x - center.x;
                const dy = y - center.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                let angle = Math.atan2(dy, dx);
                if (angle < -Math.PI / 2) angle += 2 * Math.PI;
                const maxRadius = Math.min(canvas.width, canvas.height) / 2;
                const innerCoreRadius = maxRadius * 0.25;
                
                if (distance > innerCoreRadius && distance < maxRadius) {
                    const ringAreaWidth = maxRadius - innerCoreRadius;
                    const trackWidth = ringAreaWidth / NUM_TRACKS;
                    const distanceFromOuterEdge = maxRadius - distance;
                    const track = Math.floor(distanceFromOuterEdge / trackWidth);
                    const step = Math.floor(((angle + Math.PI / 2) / (2 * Math.PI)) * numSteps);
                    if (track >= 0 && track < NUM_TRACKS && step >= 0 && step < numSteps) {
                        sequenceData[track][step] = !sequenceData[track][step];
                        draw();
                    }
                }
            });

            // --- PARAMETER CONTROLS ---
            function updateSlidersForTrack(trackIndex) {
                const synth = synths[trackIndex];
                if (!synth) return;
                const envelope = synth.envelope;
                if (envelope) {
                    document.getElementById('attackSlider').value = envelope.attack * 100;
                    document.getElementById('decaySlider').value = envelope.decay * 100;
                    document.getElementById('sustainSlider').value = envelope.sustain * 100;
                    document.getElementById('releaseSlider').value = envelope.release * 100;
                }
                const pitchControl = synth.detune || synth.frequency;
                if (pitchControl) document.getElementById('pitchSlider').value = pitchControl.value / 100;
            }

            paramPanel.addEventListener('input', (e) => {
                const synth = synths[selectedTrack];
                if (!synth) return;
                const value = parseFloat(e.target.value);
                const envelope = synth.envelope;
                switch (e.target.id) {
                    case 'attackSlider': if (envelope) envelope.attack = value / 100; break;
                    case 'decaySlider': if (envelope) envelope.decay = value / 100; break;
                    case 'sustainSlider': if (envelope) envelope.sustain = value / 100; break;
                    case 'releaseSlider': if (envelope) envelope.release = value / 100; break;
                    case 'pitchSlider':
                        if (synth.detune) {
                            synth.detune.value = value * 100;
                        } else if (synth.frequency) {
                            const baseFrequency = SOUNDS[selectedTrack].synth().frequency.value || 200;
                            synth.frequency.value = baseFrequency * Math.pow(2, value / 12);
                        }
                        break;
                }
            });

            // --- Final Setup ---
            window.addEventListener('resize', resizeCanvas);
            loadPatternsFromStorage();
            createPatternControls();
            selectPattern(selectedPatternSlot);
            resizeCanvas();
        });
    </script>
</body>
</html>
