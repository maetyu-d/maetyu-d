<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>10k Tree Bots — Brutalist Feedback p5.js</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #05060b;
      color: #eee;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      overflow: hidden;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
<script>
// ============================================
// 10k WORLD, 4-COLUMN SPLIT VIEW, p5.js
// --------------------------------------------
// Brutalist + feedback-enhanced version.
//
// COL 0: ORANGE (side)
// COL 1: ORANGE (iso)
// COL 2: GREEN (side, disabled gait)
// COL 3: GREEN (iso, disabled gait)
//
// Features:
// - Two independent trees (orange / green).
// - Disabled gait + fatigue for green bots.
// - Video-feedback-like persistence (no hard clear).
// - Brutalist blocks & grid vibes.
// - Depth-faded nodes/links per level.
// - Chromatic aberration on links.
// - 3D-ish particle dust across levels.
// ============================================

// ------- WORLD & VIEW CONSTANTS -------
const WORLD_SIZE = 10000;
const PLANE_HALF = WORLD_SIZE * 0.4;

const MAX_LEVELS = 100;
const MAX_LINKS_PER_LEVEL = 12;

const NUM_BOTS_PER_GROUP = 100;
const BOT_SPEED = 600;      // world units per second for orange
const BOT_RADIUS = 200;     // "reached" radius

const TOTAL_TOWER_HEIGHT = WORLD_SIZE * 0.4;
const LEVEL_HEIGHT_3D = TOTAL_TOWER_HEIGHT / MAX_LEVELS;

let viewCols = 4;
let viewWidth;
let viewHeight;

// Projection scales (set in setup)
let SIDE_SCALE_X, SIDE_SCALE_Z;
let MARGIN_FACTOR = 0.8;
let ISO_MARGIN = PLANE_HALF * MARGIN_FACTOR;
let ISO_SCALE;

// Colors
let COLOR_NODE, COLOR_NODE_ACTIVE, COLOR_BOT_ORANGE, COLOR_BOT_LIME;
let COLOR_STRUCTURE, COLOR_LINK, COLOR_TEXT, COLOR_LEVEL_OUTLINE, COLOR_BOT_FOCUS;
let COLOR_COL_BG;

// Banner timing
let bannerUntilTime = 0;
let lastOrangeTitle = "";
let lastGreenTitle = "";

// ------- DATA STRUCTURES -------
class Node {
  constructor(title, x, y, level) {
    this.title = title;
    this.x = x;
    this.y = y;
    this.level = level;
    this.childrenTitles = [];
    this.expanded = false;
  }
  get pos() {
    return { x: this.x, y: this.y };
  }
}

class Bot {
  constructor(x, y, level) {
    this.x = x;
    this.y = y;
    this.level = level;
    this.targetNode = null;
    this.reached = false;
    this.trail = [];
    this.maxTrail = 40;
  }
  get pos() {
    return { x: this.x, y: this.y };
  }
  setTarget(node) {
    this.targetNode = node;
    this.reached = false;
    this.level = node.level;
    this.trail = [];
  }
  update(dt) {
    if (!this.targetNode || this.reached) return;
    const tx = this.targetNode.x;
    const ty = this.targetNode.y;
    const dx = tx - this.x;
    const dy = ty - this.y;
    const dist = Math.hypot(dx, dy);

    if (dist < 1e-6) {
      this.reached = true;
      return;
    }
    if (dist <= BOT_RADIUS) {
      this.x = tx;
      this.y = ty;
      this.reached = true;
      this.addTrailPoint();
      return;
    }

    const step = BOT_SPEED * dt;
    if (step >= dist) {
      this.x = tx;
      this.y = ty;
      this.reached = true;
    } else {
      this.x += (dx / dist) * step;
      this.y += (dy / dist) * step;
    }
    this.addTrailPoint();
  }
  addTrailPoint() {
    this.trail.push({ x: this.x, y: this.y, level: this.level });
    if (this.trail.length > this.maxTrail) this.trail.shift();
  }
}

class DisabledBot extends Bot {
  constructor(x, y, level) {
    super(x, y, level);
    this.gaitPhase = random(0, TWO_PI);
    this.gaitFreq = random(1.2, 2.0);
    this.legDiff = random(0.12, 0.3);
    this.fatigue = 0.0;
    this.baseSpeedFactor = random(0.55, 0.75);
    this.stumbleChance = 0.003;
  }
  update(dt) {
    if (!this.targetNode || this.reached) return;

    const tx = this.targetNode.x;
    const ty = this.targetNode.y;
    const dx = tx - this.x;
    const dy = ty - this.y;
    const dist = Math.hypot(dx, dy);

    if (dist < 1e-6) {
      this.reached = true;
      return;
    }
    if (dist <= BOT_RADIUS) {
      this.x = tx;
      this.y = ty;
      this.reached = true;
      this.addTrailPoint();
      return;
    }

    // Gait
    this.gaitPhase += this.gaitFreq * dt * TWO_PI;

    const dirX = dx / dist;
    const dirY = dy / dist;
    const latX = -dirY;
    const latY = dirX;

    const wobbleAmp = this.legDiff * (0.6 + 0.6 * this.fatigue);
    const wobble = Math.sin(this.gaitPhase) * wobbleAmp;

    let moveX = dirX + latX * wobble;
    let moveY = dirY + latY * wobble;
    let moveLen = Math.hypot(moveX, moveY);
    if (moveLen < 1e-6) {
      moveX = dirX;
      moveY = dirY;
      moveLen = 1.0;
    }
    moveX /= moveLen;
    moveY /= moveLen;

    const fatigueFactor = max(0.3, 1.0 - this.fatigue * 0.7);
    const speed = BOT_SPEED * this.baseSpeedFactor * fatigueFactor;
    let step = speed * dt;

    // Stumble: sideways kick
    if (random() < this.stumbleChance) {
      const stumbleMag = step * 0.6;
      moveX += latX * this.legDiff * stumbleMag;
      moveY += latY * this.legDiff * stumbleMag;
      const m2 = Math.hypot(moveX, moveY);
      if (m2 > 1e-6) {
        moveX /= m2;
        moveY /= m2;
      }
    }

    if (step >= dist) {
      this.x = tx;
      this.y = ty;
      this.reached = true;
    } else {
      this.x += moveX * step;
      this.y += moveY * step;
    }

    this.addTrailPoint();

    const effort = step * (1.0 + Math.abs(wobble) * 3.0 + this.legDiff * 2.0);
    this.fatigue += effort * 0.00002;
    if (this.fatigue > 1.0) this.fatigue = 1.0;
  }
}

class StructureSegment {
  constructor(x, y, baseLevel, topLevel) {
    this.x = x;
    this.y = y;
    this.baseLevel = baseLevel;
    this.topLevel = topLevel;
  }
}

class LinkSegment {
  constructor(x1, y1, level1, x2, y2, level2) {
    this.x1 = x1;
    this.y1 = y1;
    this.level1 = level1;
    this.x2 = x2;
    this.y2 = y2;
    this.level2 = level2;
  }
}

// Dust particles in world space (x,y,level)
class Dust {
  constructor() {
    this.reset();
  }
  reset(aroundNode = null) {
    if (aroundNode) {
      this.x = aroundNode.x + random(-PLANE_HALF * 0.05, PLANE_HALF * 0.05);
      this.y = aroundNode.y + random(-PLANE_HALF * 0.05, PLANE_HALF * 0.05);
      this.level = aroundNode.level + random(-2, 2);
    } else {
      this.x = random(-PLANE_HALF, PLANE_HALF);
      this.y = random(-PLANE_HALF, PLANE_HALF);
      this.level = random(0, MAX_LEVELS - 1);
    }
    this.vx = random(-10, 10);
    this.vy = random(-10, 10);
  }
  update(dt, attractNodes) {
    this.x += this.vx * dt;
    this.y += this.vy * dt;
    this.level += random(-0.2, 0.2);

    if (this.x < -PLANE_HALF * 1.1 || this.x > PLANE_HALF * 1.1 ||
        this.y < -PLANE_HALF * 1.1 || this.y > PLANE_HALF * 1.1 ||
        this.level < 0 || this.level > MAX_LEVELS - 1) {

      // Occasionally respawn near a current target node for extra drama
      if (attractNodes && attractNodes.length > 0 && random() < 0.7) {
        const n = random(attractNodes);
        this.reset(n);
      } else {
        this.reset();
      }
    }
  }
}

// ------- GLOBAL STATE -------
let nodesOrange = [];
let nodesGreen = [];

let botsOrange = [];
let botsGreen = [];

let structOrange = [];
let structGreen = [];
let linksOrange = [];
let linksGreen = [];

let curLvlOrange = 0;
let curLvlGreen = 0;
let tgtOrange = null;
let tgtGreen = null;
let builtOrange = 0;
let builtGreen = 0;
let prunedOrange = false;
let prunedGreen = false;

let paused = false;

// Dust
const NUM_DUST = 400;
let dustParticles = [];

// ==============================
// UTILS
// ==============================

function generateSyntheticTitles(levelIndex, count, tag) {
  const arr = [];
  for (let i = 0; i < count; i++) {
    arr.push(`${tag}L${levelIndex}-N${i}`);
  }
  return arr;
}

function layoutLevel(nodeTitles, levelIndex) {
  const nodes = [];
  if (!nodeTitles || nodeTitles.length === 0) return nodes;
  const margin = PLANE_HALF * MARGIN_FACTOR;
  for (const t of nodeTitles) {
    const x = random(-margin, margin);
    const y = random(-margin, margin);
    nodes.push(new Node(t, x, y, levelIndex));
  }
  return nodes;
}

function initializeBots(num, level, disabled) {
  const arr = [];
  const jitter = PLANE_HALF * 0.1;
  for (let i = 0; i < num; i++) {
    const bx = random(-jitter, jitter);
    const by = random(-jitter, jitter);
    if (disabled) arr.push(new DisabledBot(bx, by, level));
    else arr.push(new Bot(bx, by, level));
  }
  return arr;
}

function assignBotsToNode(bots, node) {
  for (const b of bots) b.setTarget(node);
}

function allBotsReached(bots) {
  return bots.every(b => b.reached);
}

function anyBotReached(bots) {
  return bots.some(b => b.reached);
}

function chooseTarget(nodesPerLevel, levelIndex) {
  if (levelIndex >= nodesPerLevel.length) return null;
  const lvlNodes = nodesPerLevel[levelIndex];
  if (!lvlNodes || lvlNodes.length === 0) return null;
  return random(lvlNodes);
}

function levelToHeight(levelIndex) {
  return levelIndex * LEVEL_HEIGHT_3D;
}

// Projections
function isoProject(x, y, levelIndex, colIndex) {
  const z = levelToHeight(levelIndex);
  const isoX = x - y;
  const isoY = (x + y) * 0.5 - z * 1.2;
  const ix = isoX * ISO_SCALE;
  const iy = isoY * ISO_SCALE;
  const sx = colIndex * viewWidth + viewWidth / 2 + ix;
  const sy = height * 0.75 + iy;
  return { x: sx, y: sy };
}

function sideProject(x, y, levelIndex, colIndex) {
  const z = levelToHeight(levelIndex);
  const sx = colIndex * viewWidth + viewWidth / 2 + x * SIDE_SCALE_X;
  const sy = height * 0.8 - z * SIDE_SCALE_Z;
  return { x: sx, y: sy };
}

// Depth fade factor  (1 at level 0, ~0.15 at top)
function depthAlpha(levelIndex) {
  const t = constrain(levelIndex / (MAX_LEVELS - 1), 0, 1);
  return 1.0 - 0.85 * t;
}

// ==============================
// DRAW HELPERS
// ==============================

function drawColumnBackgrounds() {
  // Brutalist flat base, no gradient. Feedback is handled by translucent cover in draw().
  noStroke();
  for (let c = 0; c < viewCols; c++) {
    fill(
      red(COLOR_COL_BG[c]),
      green(COLOR_COL_BG[c]),
      blue(COLOR_COL_BG[c]),
      60
    );
    rect(c * viewWidth, 0, viewWidth, height);
  }

  // column labels baseline bars
  stroke(80, 80, 100, 200);
  strokeWeight(2);
  for (let c = 0; c <= viewCols; c++) {
    const x = c * viewWidth;
    line(x, 0, x, height);
  }

  // horizontal brutalist grid
  stroke(40, 40, 60, 60);
  strokeWeight(1);
  for (let y = 80; y < height; y += 40) {
    line(0, y, width, y);
  }
}

function drawLevelOutlineSide(levelIndex, colIndex) {
  const xLeft = -PLANE_HALF * MARGIN_FACTOR;
  const xRight = PLANE_HALF * MARGIN_FACTOR;
  const p1 = sideProject(xLeft, 0, levelIndex, colIndex);
  const p2 = sideProject(xRight, 0, levelIndex, colIndex);
  const a = depthAlpha(levelIndex);
  stroke(
    red(COLOR_LEVEL_OUTLINE),
    green(COLOR_LEVEL_OUTLINE),
    blue(COLOR_LEVEL_OUTLINE),
    80 * a
  );
  strokeWeight(1);
  line(p1.x, p1.y, p2.x, p2.y);
}

function drawLevelOutlineIso(levelIndex, colIndex) {
  const r = PLANE_HALF * MARGIN_FACTOR;
  const corners = [
    { x: 0, y: -r },
    { x: r, y: 0 },
    { x: 0, y: r },
    { x: -r, y: 0 }
  ];
  const pts = corners.map(c => isoProject(c.x, c.y, levelIndex, colIndex));
  const a = depthAlpha(levelIndex);
  noFill();
  stroke(
    red(COLOR_LEVEL_OUTLINE),
    green(COLOR_LEVEL_OUTLINE),
    blue(COLOR_LEVEL_OUTLINE),
    80 * a
  );
  strokeWeight(1);
  beginShape();
  for (const p of pts) vertex(p.x, p.y);
  endShape(CLOSE);
}

function drawNodeGlow(px, py, isActive, baseRadius, levelIndex) {
  const depth = depthAlpha(levelIndex);
  noStroke();
  if (isActive) {
    for (let i = 4; i >= 1; i--) {
      const rr = baseRadius * (i * 1.6);
      const alpha = 14 * i * depth;
      fill(255, 255, 255, alpha);
      ellipse(px, py, rr, rr);
    }
    fill(
      red(COLOR_NODE_ACTIVE),
      green(COLOR_NODE_ACTIVE),
      blue(COLOR_NODE_ACTIVE),
      220 * depth
    );
    ellipse(px, py, baseRadius * 1.8, baseRadius * 1.8);
  } else {
    for (let i = 3; i >= 1; i--) {
      const rr = baseRadius * (i * 1.4);
      const alpha = 12 * i * depth;
      fill(130, 190, 255, alpha);
      ellipse(px, py, rr, rr);
    }
    fill(
      red(COLOR_NODE),
      green(COLOR_NODE),
      blue(COLOR_NODE),
      220 * depth
    );
    ellipse(px, py, baseRadius * 1.5, baseRadius * 1.5);
  }
}

function drawBotTrail(bot, projectFunc, colIndex, colorBase) {
  if (!bot.trail || bot.trail.length < 2) return;
  noFill();
  const aMax = 80;
  beginShape();
  for (let i = 0; i < bot.trail.length; i++) {
    const p = bot.trail[i];
    const sp = projectFunc(p.x, p.y, p.level, colIndex);
    const depth = depthAlpha(p.level);
    const t = i / (bot.trail.length - 1);
    const a = aMax * t * depth;
    stroke(red(colorBase), green(colorBase), blue(colorBase), a);
    vertex(sp.x, sp.y);
  }
  endShape();
}

function drawBots(bots, projectFunc, colIndex, botColor) {
  noStroke();
  for (const b of bots) {
    const sp = projectFunc(b.x, b.y, b.level, colIndex);
    const cxMin = colIndex * viewWidth;
    const cxMax = (colIndex + 1) * viewWidth;
    if (sp.x < cxMin || sp.x > cxMax) continue;

    const depth = depthAlpha(b.level);

    fill(
      red(botColor),
      green(botColor),
      blue(botColor),
      220 * depth
    );
    ellipse(sp.x, sp.y, 6, 6);

    fill(
      red(botColor),
      green(botColor),
      blue(botColor),
      80 * depth
    );
    ellipse(sp.x, sp.y, 12, 12);
  }
}

function drawBotsFocus(bots, projectFunc, colIndex) {
  if (!bots || bots.length === 0) return;
  let sumX = 0, sumY = 0, lvl = bots[0].level;
  for (const b of bots) {
    sumX += b.x;
    sumY += b.y;
  }
  const avgX = sumX / bots.length;
  const avgY = sumY / bots.length;
  const sp = projectFunc(avgX, avgY, lvl, colIndex);
  const cxMin = colIndex * viewWidth;
  const cxMax = (colIndex + 1) * viewWidth;
  if (sp.x < cxMin || sp.x > cxMax) return;
  const depth = depthAlpha(lvl);
  noFill();
  stroke(
    red(COLOR_BOT_FOCUS),
    green(COLOR_BOT_FOCUS),
    blue(COLOR_BOT_FOCUS),
    160 * depth
  );
  strokeWeight(1.5);
  ellipse(sp.x, sp.y, 14, 14);
}

// Chromatic aberration link
function drawChromaticLink(p1, p2, depth) {
  const baseAlpha = 180 * depth;

  // Red offset
  stroke(255, 60, 80, baseAlpha * 0.7);
  strokeWeight(2.5);
  line(p1.x + 1.5, p1.y - 1.5, p2.x + 1.5, p2.y - 1.5);

  // Cyan offset
  stroke(60, 255, 255, baseAlpha * 0.7);
  strokeWeight(2.5);
  line(p1.x - 1.5, p1.y + 1.5, p2.x - 1.5, p2.y + 1.5);

  // Core white
  stroke(230, 230, 255, baseAlpha);
  strokeWeight(2);
  line(p1.x, p1.y, p2.x, p2.y);
}

// Structures: brutalist thick lines
function drawStructureSegment(seg, projectFunc, colIndex) {
  const baseDepth = depthAlpha(seg.baseLevel);
  const topDepth = depthAlpha(seg.topLevel);
  const d = 0.5 * (baseDepth + topDepth);
  const p1 = projectFunc(seg.x, seg.y, seg.baseLevel, colIndex);
  const p2 = projectFunc(seg.x, seg.y, seg.topLevel, colIndex);
  stroke(
    red(COLOR_STRUCTURE),
    green(COLOR_STRUCTURE),
    blue(COLOR_STRUCTURE),
    220 * d
  );
  strokeWeight(4);
  line(p1.x, p1.y, p2.x, p2.y);
}

// Dust
function drawDust(projectFunc, colIndex) {
  noStroke();
  for (const d of dustParticles) {
    const depth = depthAlpha(floor(d.level));
    const sp = projectFunc(d.x, d.y, d.level, colIndex);
    const a = 40 * depth;
    fill(200, 220, 255, a);
    rect(sp.x, sp.y, 2, 2);
  }
}

// ==============================
// DRAW SCENE
// ==============================

function drawScene() {
  drawColumnBackgrounds();

  const orangeTitle = tgtOrange ? tgtOrange.title : "None";
  const greenTitle = tgtGreen ? tgtGreen.title : "None";

  // -------- ORANGE TREE: COL 0 (side) --------
  let col = 0;

  // Dust (side view, orange columns share same dust)
  drawDust(sideProject, col);

  for (let lvl = 0; lvl < nodesOrange.length; lvl++) {
    if (!nodesOrange[lvl] || nodesOrange[lvl].length === 0) continue;
    drawLevelOutlineSide(lvl, col);
  }

  for (const seg of structOrange) {
    drawStructureSegment(seg, sideProject, col);
  }

  for (const link of linksOrange) {
    const p1 = sideProject(link.x1, link.y1, link.level1, col);
    const p2 = sideProject(link.x2, link.y2, link.level2, col);
    const depth = 0.5 * (depthAlpha(link.level1) + depthAlpha(link.level2));
    drawChromaticLink(p1, p2, depth);
  }

  for (const lvlNodes of nodesOrange) {
    for (const node of lvlNodes) {
      const sp = sideProject(node.x, node.y, node.level, col);
      const cxMin = col * viewWidth;
      const cxMax = (col + 1) * viewWidth;
      if (sp.x < cxMin || sp.x > cxMax) continue;
      drawNodeGlow(sp.x, sp.y, node === tgtOrange, 4, node.level);
    }
  }

  for (const b of botsOrange) {
    drawBotTrail(b, sideProject, col, COLOR_BOT_ORANGE);
  }
  drawBots(botsOrange, sideProject, col, COLOR_BOT_ORANGE);
  drawBotsFocus(botsOrange, sideProject, col);

  fill(COLOR_TEXT);
  noStroke();
  textAlign(LEFT, TOP);
  text("orange (side)", 5, 5);
  text("active: " + orangeTitle, 5, 25);

  // -------- ORANGE TREE: COL 1 (iso) --------
  col = 1;
  drawDust(isoProject, col);

  for (let lvl = 0; lvl < nodesOrange.length; lvl++) {
    if (!nodesOrange[lvl] || nodesOrange[lvl].length === 0) continue;
    drawLevelOutlineIso(lvl, col);
  }

  for (const seg of structOrange) {
    drawStructureSegment(seg, isoProject, col);
  }

  for (const link of linksOrange) {
    const p1 = isoProject(link.x1, link.y1, link.level1, col);
    const p2 = isoProject(link.x2, link.y2, link.level2, col);
    const depth = 0.5 * (depthAlpha(link.level1) + depthAlpha(link.level2));
    drawChromaticLink(p1, p2, depth);
  }

  for (const lvlNodes of nodesOrange) {
    for (const node of lvlNodes) {
      const sp = isoProject(node.x, node.y, node.level, col);
      const cxMin = col * viewWidth;
      const cxMax = (col + 1) * viewWidth;
      if (sp.x < cxMin || sp.x > cxMax) continue;
      drawNodeGlow(sp.x, sp.y, node === tgtOrange, 5, node.level);
    }
  }

  for (const b of botsOrange) {
    drawBotTrail(b, isoProject, col, COLOR_BOT_ORANGE);
  }
  drawBots(botsOrange, isoProject, col, COLOR_BOT_ORANGE);
  drawBotsFocus(botsOrange, isoProject, col);

  fill(COLOR_TEXT);
  noStroke();
  textAlign(LEFT, TOP);
  text("orange (iso)", viewWidth + 5, 5);
  text("active: " + orangeTitle, viewWidth + 5, 25);

  // -------- GREEN TREE: COL 2 (side) --------
  col = 2;
  drawDust(sideProject, col);

  for (let lvl = 0; lvl < nodesGreen.length; lvl++) {
    if (!nodesGreen[lvl] || nodesGreen[lvl].length === 0) continue;
    drawLevelOutlineSide(lvl, col);
  }

  for (const seg of structGreen) {
    drawStructureSegment(seg, sideProject, col);
  }

  for (const link of linksGreen) {
    const p1 = sideProject(link.x1, link.y1, link.level1, col);
    const p2 = sideProject(link.x2, link.y2, link.level2, col);
    const depth = 0.5 * (depthAlpha(link.level1) + depthAlpha(link.level2));
    drawChromaticLink(p1, p2, depth);
  }

  for (const lvlNodes of nodesGreen) {
    for (const node of lvlNodes) {
      const sp = sideProject(node.x, node.y, node.level, col);
      const cxMin = col * viewWidth;
      const cxMax = (col + 1) * viewWidth;
      if (sp.x < cxMin || sp.x > cxMax) continue;
      drawNodeGlow(sp.x, sp.y, node === tgtGreen, 4, node.level);
    }
  }

  for (const b of botsGreen) {
    drawBotTrail(b, sideProject, col, COLOR_BOT_LIME);
  }
  drawBots(botsGreen, sideProject, col, COLOR_BOT_LIME);
  drawBotsFocus(botsGreen, sideProject, col);

  fill(COLOR_TEXT);
  noStroke();
  text("green (side)", 2 * viewWidth + 5, 5);
  text("active: " + greenTitle, 2 * viewWidth + 5, 25);

  // -------- GREEN TREE: COL 3 (iso) --------
  col = 3;
  drawDust(isoProject, col);

  for (let lvl = 0; lvl < nodesGreen.length; lvl++) {
    if (!nodesGreen[lvl] || nodesGreen[lvl].length === 0) continue;
    drawLevelOutlineIso(lvl, col);
  }

  for (const seg of structGreen) {
    drawStructureSegment(seg, isoProject, col);
  }

  for (const link of linksGreen) {
    const p1 = isoProject(link.x1, link.y1, link.level1, col);
    const p2 = isoProject(link.x2, link.y2, link.level2, col);
    const depth = 0.5 * (depthAlpha(link.level1) + depthAlpha(link.level2));
    drawChromaticLink(p1, p2, depth);
  }

  for (const lvlNodes of nodesGreen) {
    for (const node of lvlNodes) {
      const sp = isoProject(node.x, node.y, node.level, col);
      const cxMin = col * viewWidth;
      const cxMax = (col + 1) * viewWidth;
      if (sp.x < cxMin || sp.x > cxMax) continue;
      drawNodeGlow(sp.x, sp.y, node === tgtGreen, 5, node.level);
    }
  }

  for (const b of botsGreen) {
    drawBotTrail(b, isoProject, col, COLOR_BOT_LIME);
  }
  drawBots(botsGreen, isoProject, col, COLOR_BOT_LIME);
  drawBotsFocus(botsGreen, isoProject, col);

  fill(COLOR_TEXT);
  noStroke();
  text("green (iso)", 3 * viewWidth + 5, 5);
  text("active: " + greenTitle, 3 * viewWidth + 5, 25);

  // ----- TEXT OVERLAY -----
  const botsAtTargetOrange = botsOrange.filter(b => b.reached).length;
  const botsAtTargetGreen = botsGreen.filter(b => b.reached).length;

  const infoLines = [
    "4-COLUMN — DUAL TREES — BRUTALIST FEEDBACK",
    `ORANGE: Level ${curLvlOrange + 1}/${MAX_LEVELS}  |  Built: ${builtOrange}  |  Bots at target: ${botsAtTargetOrange}/${botsOrange.length}`,
    `GREEN (DISABLED): Level ${curLvlGreen + 1}/${MAX_LEVELS}  |  Built: ${builtGreen}  |  Bots at target: ${botsAtTargetGreen}/${botsGreen.length}`,
    "SPACE: pause / play"
  ];

  textAlign(LEFT, TOP);
  let yy = height - 22 * infoLines.length - 40;
  for (const line of infoLines) {
    fill(240, 240, 255, 230);
    text(line, 10, yy);
    yy += 22;
  }

  // ----- BANNER -----
  const now = millis() / 1000.0;
  if (orangeTitle !== lastOrangeTitle || greenTitle !== lastGreenTitle) {
    lastOrangeTitle = orangeTitle;
    lastGreenTitle = greenTitle;
    bannerUntilTime = now + 1.0;
  }

  if (now <= bannerUntilTime) {
    const banner = `ORANGE: ${orangeTitle}    |    GREEN: ${greenTitle}`;
    const tw = textWidth(banner);
    const bx = (width - tw) / 2;
    const by = height - 24;

    noStroke();
    fill(0, 0, 0, 200);
    rect(bx - 12, by - 6, tw + 24, 24, 4);

    fill(255);
    textAlign(LEFT, TOP);
    text(banner, bx, by - 2);
  }
}


// ==============================
// TREE STEP LOGIC
// ==============================

function stepTree(nodes, bots, structArr, linksArr, curLvl, tgt, built, pruned, tag) {
  let levelComplete = false;

  if (!pruned && anyBotReached(bots) && tgt) {
    if (curLvl > 0 && nodes[curLvl - 1].length === 1) {
      const prevNode = nodes[curLvl - 1][0];
      linksArr.push(new LinkSegment(
        prevNode.x, prevNode.y, prevNode.level,
        tgt.x,      tgt.y,      tgt.level
      ));
    }
    nodes[curLvl] = [tgt];
    pruned = true;
  }

  if (allBotsReached(bots)) {
    levelComplete = true;

    if (built < MAX_LEVELS - 1) {
      const baseLevel = curLvl;
      const topLevel = curLvl + 1;
      structArr.push(new StructureSegment(tgt.x, tgt.y, baseLevel, topLevel));
      built++;

      let children;
      if (!tgt.childrenTitles || tgt.childrenTitles.length === 0) {
        children = generateSyntheticTitles(curLvl + 1, MAX_LINKS_PER_LEVEL, tag);
        tgt.childrenTitles = children;
        tgt.expanded = true;
      } else {
        children = tgt.childrenTitles;
      }

      const nextLevelIndex = curLvl + 1;
      if (nextLevelIndex >= nodes.length) {
        const unique = [...new Set(children)].slice(0, MAX_LINKS_PER_LEVEL);
        const nextNodes = layoutLevel(unique, nextLevelIndex);
        for (const n of nextNodes) n.childrenTitles = [];
        nodes.push(nextNodes);
      }

      curLvl = nextLevelIndex;

      const jitter = PLANE_HALF * 0.1;
      for (const b of bots) {
        b.x = tgt.x + random(-jitter, jitter);
        b.y = tgt.y + random(-jitter, jitter);
        b.level = curLvl;
        b.reached = false;
        b.trail = [];
        if (b instanceof DisabledBot) {
          b.fatigue *= 0.5; // partial recovery
        }
      }

      tgt = chooseTarget(nodes, curLvl);
      if (tgt) assignBotsToNode(bots, tgt);
      pruned = false;
    }
  }

  return { nodes, bots, structArr, linksArr, curLvl, tgt, built, pruned, levelComplete };
}


// ==============================
// P5 SETUP & DRAW
// ==============================

function setup() {
  createCanvas(1400, 900);
  viewWidth = width / 4;
  viewHeight = height;
  frameRate(60);
  smooth(8);

  SIDE_SCALE_X = (viewWidth * 0.45) / PLANE_HALF;
  SIDE_SCALE_Z = (height * 0.7) / TOTAL_TOWER_HEIGHT;
  ISO_MARGIN = PLANE_HALF * MARGIN_FACTOR;
  ISO_SCALE = (viewWidth * 0.45) / (2.0 * ISO_MARGIN * 2.0);

  textFont("monospace", 14);

  COLOR_NODE = color(90, 170, 255);
  COLOR_NODE_ACTIVE = color(255, 255, 255);
  COLOR_BOT_ORANGE = color(255, 140, 0);
  COLOR_BOT_LIME = color(0, 255, 120);
  COLOR_STRUCTURE = color(240, 240, 240);
  COLOR_LINK = color(200, 150, 255);
  COLOR_TEXT = color(235, 235, 245);
  COLOR_LEVEL_OUTLINE = color(80, 80, 110);
  COLOR_BOT_FOCUS = color(255, 60, 60);
  COLOR_COL_BG = [
    color(18, 18, 32),
    color(26, 16, 40),
    color(12, 26, 36),
    color(36, 34, 18)
  ];

  // ORANGE ROOT
  const rootLinksOrange = generateSyntheticTitles(0, MAX_LINKS_PER_LEVEL, "O");
  const level0Orange = layoutLevel(rootLinksOrange, 0);
  for (const n of level0Orange) n.childrenTitles = [];
  nodesOrange.push(level0Orange);

  // GREEN ROOT
  const rootLinksGreen = generateSyntheticTitles(0, MAX_LINKS_PER_LEVEL, "G");
  const level0Green = layoutLevel(rootLinksGreen, 0);
  for (const n of level0Green) n.childrenTitles = [];
  nodesGreen.push(level0Green);

  botsOrange = initializeBots(NUM_BOTS_PER_GROUP, 0, false);
  botsGreen = initializeBots(NUM_BOTS_PER_GROUP, 0, true);

  tgtOrange = chooseTarget(nodesOrange, curLvlOrange);
  tgtGreen  = chooseTarget(nodesGreen,  curLvlGreen);
  if (tgtOrange) assignBotsToNode(botsOrange, tgtOrange);
  if (tgtGreen)  assignBotsToNode(botsGreen,  tgtGreen);

  // Dust
  for (let i = 0; i < NUM_DUST; i++) {
    dustParticles.push(new Dust());
  }
}

function draw() {
  // Video-feedback style fade: do NOT hard-clear, just darken slightly
  noStroke();
  fill(5, 6, 12, 40);  // tweak alpha for longer/shorter persistence
  rect(0, 0, width, height);

  // Clamp dt for smoother motion and stable speeds
  let dt = deltaTime / 1000.0;
  dt = min(dt, 1.0 / 60.0);

  if (!paused) {
    for (const b of botsOrange) b.update(dt);
    for (const b of botsGreen) b.update(dt);

    const attract = [];
    if (tgtOrange) attract.push(tgtOrange);
    if (tgtGreen) attract.push(tgtGreen);
    for (const d of dustParticles) d.update(dt, attract);

    let resO = stepTree(
      nodesOrange,
      botsOrange,
      structOrange,
      linksOrange,
      curLvlOrange,
      tgtOrange,
      builtOrange,
      prunedOrange,
      "O"
    );
    nodesOrange = resO.nodes;
    botsOrange  = resO.bots;
    structOrange = resO.structArr;
    linksOrange  = resO.linksArr;
    curLvlOrange = resO.curLvl;
    tgtOrange    = resO.tgt;
    builtOrange  = resO.built;
    prunedOrange = resO.pruned;

    let resG = stepTree(
      nodesGreen,
      botsGreen,
      structGreen,
      linksGreen,
      curLvlGreen,
      tgtGreen,
      builtGreen,
      prunedGreen,
      "G"
    );
    nodesGreen = resG.nodes;
    botsGreen  = resG.bots;
    structGreen = resG.structArr;
    linksGreen  = resG.linksArr;
    curLvlGreen = resG.curLvl;
    tgtGreen    = resG.tgt;
    builtGreen  = resG.built;
    prunedGreen = resG.pruned;
  }

  drawScene();
}

function keyPressed() {
  if (key === ' ') paused = !paused;
}

</script>
</body>
</html>

