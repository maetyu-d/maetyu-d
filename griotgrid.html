<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Griot Grid</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c;
            color: #e2e8f0;
        }
        .grid-container {
            display: grid;
            grid-template-columns: repeat(32, 20px);
            gap: 2px;
            padding: 10px;
            background-color: #2d3748;
            border-radius: 8px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        .switch {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            background-color: #4a5568;
            cursor: pointer;
            transition: all 0.1s ease-in-out;
        }
        .switch:hover {
            transform: scale(1.1);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.2);
        }
        /* Color classes for different modes */
        .c-osc { background-color: #4299e1; } /* Blue */
        .c-filter { background-color: #48bb78; } /* Green */
        .c-env { background-color: #ed64a6; } /* Pink */
        .c-seq { background-color: #9f7aea; } /* Purple */
        .c-op { background-color: #ed8936; } /* Orange */
        .c-time { background-color: #38b2ac; } /* Teal */
        .c-spawn { background-color: #f6e05e; } /* Yellow */
        .c-kill { background-color: #c53030; } /* Dark Red */
        
        /* Active state for a placed element */
        .c-active {
            box-shadow: 0 0 8px 2px currentColor;
        }

        /* Visual feedback for a triggered element */
        .triggered {
            transform: scale(1.2);
            opacity: 0.8;
            border: 1px solid #fff;
        }
        .synth-btn-active {
            background-color: #4299e1;
            color: white;
        }
        /* Toggle Switch Styles */
        .toggle-checkbox:checked {
            right: 0;
            border-color: #48bb78;
        }
        .toggle-checkbox:checked + .toggle-label {
            background-color: #48bb78;
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4">

    <div class="text-center mb-6">
        <h1 class="text-4xl font-bold">Griot Grid</h1>
        <p class="text-lg text-gray-400">Bit-Byte Synthesis & Pattern Weaving</p>
    </div>

    <div class="flex items-start gap-8">
        <div id="grid-container" class="grid-container">
            <!-- The 32x32 grid is generated by JavaScript -->
        </div>

        <div class="flex flex-col gap-6 w-64">
            <div class="bg-gray-800 p-4 rounded-lg shadow-lg">
                <h2 class="text-xl font-semibold mb-3">Function Mode</h2>
                <div class="flex flex-col gap-2">
                    <button class="mode-btn p-2 rounded-md text-left font-semibold text-white" style="background-color: #9f7aea;" data-mode="seq">Sequencer</button>
                    <button class="mode-btn p-2 rounded-md text-left font-semibold" style="background-color: #f6e05e; color: #1a202c;" data-mode="spawn">Spawner</button>
                    <button class="mode-btn p-2 rounded-md text-left font-semibold text-white" style="background-color: #c53030;" data-mode="kill">Terminator</button>
                    <button class="mode-btn p-2 rounded-md text-left font-semibold text-white" style="background-color: #4299e1;" data-mode="osc">Oscillator</button>
                    <button class="mode-btn p-2 rounded-md text-left font-semibold text-white" style="background-color: #ed8936;" data-mode="op">Operator</button>
                    <button class="mode-btn p-2 rounded-md text-left font-semibold text-white" style="background-color: #48bb78;" data-mode="filter">Filter/FX</button>
                    <button class="mode-btn p-2 rounded-md text-left font-semibold text-white" style="background-color: #ed64a6;" data-mode="env">Envelope</button>
                    <button class="mode-btn p-2 rounded-md text-left font-semibold text-white" style="background-color: #38b2ac;" data-mode="time">Time</button>
                </div>
            </div>
            <div class="bg-gray-800 p-4 rounded-lg shadow-lg">
                <h2 class="text-xl font-semibold mb-3">Master Controls</h2>
                <button id="start-stop-btn" class="w-full p-2 rounded-md bg-green-600 hover:bg-green-700 font-bold">Start</button>
                <div class="mt-3">
                    <label for="bpm-slider" class="block">BPM: <span id="bpm-value">120</span></label>
                    <input type="range" id="bpm-slider" min="30" max="240" value="120" class="w-full">
                </div>
                <div class="mt-4">
                     <h3 class="text-lg font-semibold mb-2">Synth Mode</h3>
                     <div class="flex gap-2">
                        <button id="synth-btn-byte" class="synth-btn synth-btn-active w-full p-2 rounded-md bg-gray-700 hover:bg-gray-600 font-semibold">Bit-Byte</button>
                        <button id="synth-btn-sine" class="synth-btn w-full p-2 rounded-md bg-gray-700 hover:bg-gray-600 font-semibold">Sine Wave</button>
                     </div>
                </div>
            </div>
            <div class="bg-gray-800 p-4 rounded-lg shadow-lg">
                <h2 class="text-xl font-semibold mb-3">Generate</h2>
                <button id="randomize-btn" class="w-full p-2 rounded-md bg-blue-600 hover:bg-blue-700 font-bold">Randomize Pattern</button>
                <div class="mt-3">
                    <label for="density-slider" class="block">Density: <span id="density-value">50</span>%</label>
                    <input type="range" id="density-slider" min="10" max="100" value="50" class="w-full">
                </div>
            </div>
             <!-- Evolution Controls -->
            <div class="bg-gray-800 p-4 rounded-lg shadow-lg">
                <div class="flex justify-between items-center mb-3">
                    <h2 class="text-xl font-semibold">Evolution</h2>
                    <div class="relative inline-block w-10 mr-2 align-middle select-none transition duration-200 ease-in">
                        <input type="checkbox" name="toggle" id="evolution-toggle" class="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer"/>
                        <label for="evolution-toggle" class="toggle-label block overflow-hidden h-6 rounded-full bg-gray-600 cursor-pointer"></label>
                    </div>
                </div>
                <div class="mt-3">
                    <label for="evolution-rate-slider" class="block">Rate: <span id="evolution-rate-value">4m</span></label>
                    <input type="range" id="evolution-rate-slider" min="0" max="4" value="2" class="w-full">
                </div>
                 <div class="mt-3">
                    <label for="evolution-amount-slider" class="block">Amount: <span id="evolution-amount-value">1</span></label>
                    <input type="range" id="evolution-amount-slider" min="1" max="10" value="1" class="w-full">
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Core Variables ---
            const gridContainer = document.getElementById('grid-container');
            const gridSize = 32;
            let currentMode = 'seq';
            let gridState = Array(gridSize * gridSize).fill(null).map(() => ({ mode: null, active: false }));
            let sequencers = [];
            let evolutionEventId = null;

            // --- UI Elements ---
            const modeButtons = document.querySelectorAll('.mode-btn');
            const startStopBtn = document.getElementById('start-stop-btn');
            const bpmSlider = document.getElementById('bpm-slider');
            const bpmValue = document.getElementById('bpm-value');
            const randomizeBtn = document.getElementById('randomize-btn');
            const densitySlider = document.getElementById('density-slider');
            const densityValue = document.getElementById('density-value');
            const synthBtnByte = document.getElementById('synth-btn-byte');
            const synthBtnSine = document.getElementById('synth-btn-sine');
            const evolutionToggle = document.getElementById('evolution-toggle');
            const evolutionRateSlider = document.getElementById('evolution-rate-slider');
            const evolutionRateValue = document.getElementById('evolution-rate-value');
            const evolutionAmountSlider = document.getElementById('evolution-amount-slider');
            const evolutionAmountValue = document.getElementById('evolution-amount-value');

            // --- Tone.js Audio Setup ---
            // Distorted Chain for Bit-Byte Synth
            const distortion = new Tone.Distortion(0.1).toDestination();
            const reverb = new Tone.Reverb({ decay: 3, wet: 0.3 }).connect(distortion);
            const filter = new Tone.AutoFilter("4n").connect(reverb).start();
            
            // Synth 1: Original "Bit-Byte" sound (connects to distorted chain)
            const synth = new Tone.PolySynth(Tone.Synth, { oscillator: { type: 'fmsquare', modulationType: 'sine', harmonicity: 0.8 }, envelope: { attack: 0.01, decay: 0.15, sustain: 0.3, release: 0.4 } }).connect(filter);
            synth.volume.value = -16;

            // Clean Chain for Sine Synth
            const cleanReverb = new Tone.Reverb({ decay: 2.5, wet: 0.4 }).toDestination();

            // Synth 2: "Beautiful Sine" sound (connects to clean chain)
            const sineSynth = new Tone.PolySynth(Tone.FMSynth, { harmonicity: 1.01, modulationIndex: 3, oscillator: { type: 'sine' }, envelope: { attack: 0.02, decay: 0.3, sustain: 0.1, release: 1.0 }, modulation: { type: 'sine' }, modulationEnvelope: { attack: 0.05, decay: 0.2, sustain: 0.1, release: 1.0 } }).connect(cleanReverb);
            sineSynth.volume.value = -18;

            let activeSynth = synth;
            const malianPentatonic = ['C3', 'Eb3', 'F3', 'G3', 'Bb3', 'C4', 'Eb4', 'F4', 'G4', 'Bb4', 'C5', 'Eb5', 'F5', 'G5', 'Bb5', 'C6'];
            const allModes = ['osc', 'op', 'filter', 'env', 'time', 'spawn', 'kill'];

            // --- Grid & UI Initialization ---
            function createGrid() {
                gridContainer.innerHTML = '';
                for (let i = 0; i < gridSize * gridSize; i++) {
                    const switchEl = document.createElement('div');
                    switchEl.classList.add('switch');
                    switchEl.dataset.index = i;
                    gridContainer.appendChild(switchEl);
                    switchEl.addEventListener('click', () => handleSwitchClick(i));
                }
            }

            function updateCell(index) {
                if (index === null || index < 0 || index >= gridSize * gridSize) return;
                const element = gridContainer.children[index];
                const state = gridState[index];
                
                element.className = 'switch';
                if (state.mode) {
                    element.classList.add(`c-${state.mode}`);
                    if (state.active) element.classList.add('c-active');
                }
            }

            function updateFullGrid() {
                for (let i = 0; i < gridSize * gridSize; i++) {
                    updateCell(i);
                }
            }

            function updateSequencerVisuals() {
                // Clear all old borders first
                const allCells = gridContainer.children;
                for(let i = 0; i < allCells.length; i++) {
                    allCells[i].style.border = 'none';
                }
                // Then draw new borders
                sequencers.forEach(seq => {
                    const cell = gridContainer.children[seq.currentIndex];
                    if (cell) cell.style.border = seq.isGhost ? '2px dashed #f6e05e' : '2px solid #f6e05e';
                });
            }

            // --- Event Handlers ---
            function handleSwitchClick(index) {
                const state = gridState[index];
                if (currentMode === 'seq') {
                    const existingSeqIndex = sequencers.findIndex(s => s.startIndex === index);
                    if (existingSeqIndex > -1) {
                        sequencers.splice(existingSeqIndex, 1);
                        state.mode = null; state.active = false;
                    } else {
                        sequencers.push(createSequencer(index));
                        state.mode = 'seq'; state.active = true;
                    }
                } else {
                    if (state.mode === currentMode) {
                        state.active = !state.active;
                    } else {
                        if (state.mode === 'seq') {
                            const existingSeqIndex = sequencers.findIndex(s => s.startIndex === index);
                            if (existingSeqIndex > -1) sequencers.splice(existingSeqIndex, 1);
                        }
                        state.mode = currentMode; state.active = true;
                    }
                    if (!state.active) state.mode = null;
                }
                updateCell(index);
            }
            
            modeButtons.forEach(btn => btn.addEventListener('click', () => currentMode = btn.dataset.mode));
            
            startStopBtn.addEventListener('click', async () => {
                await Tone.start();
                if (Tone.Transport.state === 'started') {
                    Tone.Transport.stop();
                    startStopBtn.textContent = 'Start';
                    startStopBtn.classList.remove('bg-red-600', 'hover:bg-red-700');
                    startStopBtn.classList.add('bg-green-600', 'hover:bg-green-700');
                } else {
                    Tone.Transport.start();
                    startStopBtn.textContent = 'Stop';
                    startStopBtn.classList.add('bg-red-600', 'hover:bg-red-700');
                    startStopBtn.classList.remove('bg-green-600', 'hover:bg-green-700');
                }
            });

            bpmSlider.addEventListener('input', e => { Tone.Transport.bpm.value = e.target.value; bpmValue.textContent = e.target.value; });
            densitySlider.addEventListener('input', e => { densityValue.textContent = e.target.value; });
            randomizeBtn.addEventListener('click', generateRandomPattern);
            synthBtnByte.addEventListener('click', () => { activeSynth = synth; synthBtnByte.classList.add('synth-btn-active'); synthBtnSine.classList.remove('synth-btn-active'); });
            synthBtnSine.addEventListener('click', () => { activeSynth = sineSynth; synthBtnSine.classList.add('synth-btn-active'); synthBtnByte.classList.remove('synth-btn-active'); });

            // --- Evolution Logic ---
            const evolutionRates = ["16m", "8m", "4m", "2m", "1m"];
            evolutionRateSlider.addEventListener('input', e => { evolutionRateValue.textContent = evolutionRates[e.target.value]; if (evolutionEventId) setupEvolution(); });
            evolutionAmountSlider.addEventListener('input', e => { evolutionAmountValue.textContent = e.target.value; });
            evolutionToggle.addEventListener('change', () => { if (evolutionToggle.checked) { setupEvolution(); } else if (evolutionEventId) { Tone.Transport.clear(evolutionEventId); evolutionEventId = null; } });

            function setupEvolution() { if (evolutionEventId) Tone.Transport.clear(evolutionEventId); const rate = evolutionRates[evolutionRateSlider.value]; evolutionEventId = Tone.Transport.scheduleRepeat(() => { mutateGrid(); }, rate); }
            function mutateGrid() { const amount = parseInt(evolutionAmountSlider.value); for(let i=0; i < amount; i++) { const mType = Math.random(); if (mType < 0.4) addRandomCell(); else if (mType < 0.7) removeRandomCell(); else if (mType < 0.9) nudgeRandomCell(); else changeRandomCellMode(); } }
            function addRandomCell() { const empty = gridState.map((s, i) => s.mode === null ? i : -1).filter(i => i !== -1); if (empty.length === 0) return; const index = empty[Math.floor(Math.random() * empty.length)]; const mode = allModes[Math.floor(Math.random() * allModes.length)]; gridState[index] = { mode: mode, active: true }; updateCell(index); }
            function removeRandomCell() { const active = gridState.map((s, i) => s.mode !== null && s.mode !== 'seq' ? i : -1).filter(i => i !== -1); if (active.length === 0) return; const index = active[Math.floor(Math.random() * active.length)]; gridState[index] = { mode: null, active: false }; updateCell(index); }
            function nudgeRandomCell() { const active = gridState.map((s, i) => s.mode !== null && s.mode !== 'seq' ? i : -1).filter(i => i !== -1); if (active.length === 0) return; const index = active[Math.floor(Math.random() * active.length)]; const {x, y} = indexToCoords(index); const neighbors = [ {x: x+1, y: y}, {x: x-1, y: y}, {x: x, y: y+1}, {x: x, y: y-1} ].map(c => ({x: (c.x + gridSize) % gridSize, y: (c.y + gridSize) % gridSize})); const empty = neighbors.filter(n => gridState[coordsToIndex(n.x, n.y)].mode === null); if (empty.length > 0) { const target = empty[Math.floor(Math.random() * empty.length)]; const targetIdx = coordsToIndex(target.x, target.y); gridState[targetIdx] = gridState[index]; gridState[index] = { mode: null, active: false }; updateCell(index); updateCell(targetIdx); } }
            function changeRandomCellMode() { const active = gridState.map((s, i) => s.mode !== null && s.mode !== 'seq' ? i : -1).filter(i => i !== -1); if (active.length === 0) return; const index = active[Math.floor(Math.random() * active.length)]; gridState[index].mode = allModes[Math.floor(Math.random() * allModes.length)]; updateCell(index); }

            // --- Pattern Generation ---
            function clearGrid() { gridState = Array(gridSize * gridSize).fill(null).map(() => ({ mode: null, active: false })); sequencers = []; updateFullGrid(); }
            function generateRandomPattern() { clearGrid(); const density = parseInt(densitySlider.value) / 100; const cellsToPlace = Math.floor(gridSize * gridSize * density); const numSequencers = Math.max(1, Math.floor(density * 5)); for (let i = 0; i < numSequencers; i++) { const index = Math.floor(Math.random() * gridSize * gridSize); if (!gridState[index].mode) { gridState[index] = { mode: 'seq', active: true }; sequencers.push(createSequencer(index)); } } const modeWeights = [0.45, 0.20, 0.05, 0.05, 0.1, 0.1, 0.05]; let placed = sequencers.length; while (placed < cellsToPlace) { const mode = weightedRandom(allModes, modeWeights); const len = Math.floor(Math.random() * (gridSize / 2)) + 3; let { x, y } = { x: Math.floor(Math.random() * gridSize), y: Math.floor(Math.random() * gridSize) }; for (let i = 0; i < len && placed < cellsToPlace; i++) { x = (x + Math.floor(Math.random() * 3) - 1 + gridSize) % gridSize; y = (y + Math.floor(Math.random() * 3) - 1 + gridSize) % gridSize; const index = coordsToIndex(x, y); if (!gridState[index].mode) { gridState[index] = { mode: mode, active: true }; placed++; } } } updateFullGrid(); }
            function weightedRandom(items, weights) { let i, sum = 0, r = Math.random(); for (i in weights) { sum += weights[i]; if (r <= sum) return items[i]; } }

            // --- Sequencer & Logic ---
            function createSequencer(index, direction, isGhost = false) { const dirs = [{x:1, y:0}, {x:-1, y:0}, {x:0, y:1}, {x:0, y:-1}]; return { id: Date.now() + Math.random(), startIndex: index, currentIndex: index, prevIndex: index, direction: direction || dirs[Math.floor(Math.random() * dirs.length)], speed: '16n', lastStepTime: 0, isGhost: isGhost }; }

            Tone.Transport.scheduleRepeat(time => {
                let sequencersToRemove = [];
                [...sequencers].forEach((seq, seqIndex) => {
                    if (time >= seq.lastStepTime + Tone.Time(seq.speed).toSeconds()) {
                        seq.lastStepTime = time;
                        const shouldBeRemoved = processCell(seq.currentIndex, seq, time);
                        if (shouldBeRemoved) {
                            sequencersToRemove.push(seq.id);
                        } else {
                            moveSequencer(seq);
                        }
                    }
                });
                if (sequencersToRemove.length > 0) {
                    sequencers = sequencers.filter(s => !sequencersToRemove.includes(s.id));
                }
                requestAnimationFrame(updateSequencerVisuals);
            }, "32n");

            function moveSequencer(seq) { seq.prevIndex = seq.currentIndex; let { x, y } = indexToCoords(seq.currentIndex); x = (x + seq.direction.x + gridSize) % gridSize; y = (y + seq.direction.y + gridSize) % gridSize; seq.currentIndex = coordsToIndex(x, y); }

            function processCell(index, sequencer, time) {
                const state = gridState[index];
                if (!state.active) return false;
                const { x: col, y: row } = indexToCoords(index);
                const cellElement = gridContainer.children[index];
                if(cellElement) { cellElement.classList.add('triggered'); setTimeout(() => cellElement.classList.remove('triggered'), 100); }

                switch (state.mode) {
                    case 'osc': const note = malianPentatonic[row % malianPentatonic.length]; const vel = 0.5 + (col / gridSize) * 0.5; const dur = activeSynth === sineSynth ? '2n' : '8n'; activeSynth.triggerAttackRelease(note, dur, time, vel); if (activeSynth === synth) { synth.set({ detune: (col % 8 - 4) * 2 }); } break;
                    case 'filter': if(activeSynth === synth) { filter.baseFrequency = 100 + (col * 40); filter.filter.Q.rampTo(1 + (row / gridSize) * 10, 0.1); } break; // Filter only affects distorted synth
                    case 'env': if (activeSynth === synth) { synth.set({ envelope: { decay: 0.05 + (row / gridSize) * 0.5, release: 0.05 + (col / gridSize) * 0.5 } }); } break;
                    case 'op': applyBinaryOperator(sequencer, row); break;
                    case 'time': const speeds = ['8n', '8t', '16n', '16t', '32n']; sequencer.speed = speeds[row % speeds.length]; break;
                    case 'kill': return true; // Signal to remove this sequencer
                    case 'spawn':
                        if (sequencers.length < 256) {
                            let newDirection, isGhost = false;
                            if (row <= 10) { // Bottom third: right angle
                                newDirection = Math.random() < 0.5 ? { x: sequencer.direction.y, y: sequencer.direction.x } : { x: -sequencer.direction.y, y: -sequencer.direction.x };
                            } else if (row <= 20) { // Middle third: opposite
                                newDirection = { x: -sequencer.direction.x, y: -sequencer.direction.y };
                            } else { // Top third: ghost
                                newDirection = { ...sequencer.direction };
                                isGhost = true;
                            }
                            if (newDirection.x === 0 && newDirection.y === 0) newDirection.x = 1;
                            sequencers.push(createSequencer(index, newDirection, isGhost));
                        }
                        break;
                }
                return false;
            }

            function applyBinaryOperator(sequencer, row) {
                if (sequencer.isGhost) return; // Ghosts ignore operators
                const operatorType = row % 5;
                let dir = sequencer.direction;
                switch (operatorType) {
                    case 0: dir.x *= -1; dir.y *= -1; break; // NOT
                    case 1: [dir.x, dir.y] = [dir.y, dir.x]; break; // SHIFT
                    case 2: if (Math.abs(dir.x) > 0) { dir.y = dir.x; dir.x = 0; } else if (Math.abs(dir.y) > 0) { dir.x = dir.y; dir.y = 0; } else { dir.x = 1; } break; // XOR
                    case 3: if (dir.x === 0 && dir.y === 0) dir.x = 1; else dir.y = 0; break; // FORCE-X
                    case 4: if (dir.x === 0 && dir.y === 0) dir.y = 1; else dir.x = 0; break; // FORCE-Y
                }
            }

            // --- Utility Functions ---
            const indexToCoords = index => ({ x: index % gridSize, y: Math.floor(index / gridSize) });
            const coordsToIndex = (x, y) => y * gridSize + x;

            // --- Initialization ---
            createGrid();
            Tone.Transport.bpm.value = 120;
        });
    </script>

</body>
</html>
