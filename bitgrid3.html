<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bitgrid Synthesizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <style>
        :root {
            --bg-color-dark: #0f172a;
            --bg-color-light: #1e293b;
            --cell-off-color: #334155;
            --cell-on-note: #22d3ee;
            --playhead-color: rgba(251, 146, 60, 0.5);
            --header-bg: #475569;
            --header-text: #cbd5e1;
            
            /* Role-based colors */
            --mod-len: #f59e0b;      /* Amber */
            --mod-synth: #14b8a6;    /* Teal */
            --mod-pitch: #ec4899;    /* Pink */
            --mod-bitwise: #818cf8;  /* Indigo */
            --mod-transform: #ef4444;/* Red */
            --mod-data: #78716c;      /* Stone */
            
            font-family: 'Inter', sans-serif;
        }
        body {
            background-color: var(--bg-color-dark);
            background-image: radial-gradient(circle at top left, var(--bg-color-light) 0%, var(--bg-color-dark) 40%);
            color: #f1f5f9;
            overscroll-behavior: none;
        }
        /* Custom scrollbar */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #1e293b; }
        ::-webkit-scrollbar-thumb { background: #475569; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #64748b; }

        #grid-container {
            touch-action: none;
            padding: 1rem;
            background-color: rgba(0,0,0,0.2);
            border-radius: 1rem;
            box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1), 0 4px 6px -2px rgba(0,0,0,0.05), inset 0 2px 4px 0 rgba(255,255,255,0.05);
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(33, 1fr);
            grid-template-rows: repeat(33, 1fr);
            gap: 3px;
            position: relative;
            aspect-ratio: 1 / 1;
        }
        
        .playhead {
            position: absolute;
            top: 0;
            bottom: 0;
            width: calc(100% / 33);
            background-color: var(--playhead-color);
            border-right: 2px solid var(--mod-len);
            box-shadow: 0 0 15px var(--mod-len);
            left: calc(var(--playhead-col, 0) * (100% / 33));
            transition: left 0.05s linear;
            z-index: 10;
            pointer-events: none;
        }

        .header {
            background-color: transparent;
            color: var(--header-text);
            font-size: 0.6rem;
            font-weight: 500;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .cell {
            background-color: var(--cell-off-color);
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.1s ease;
            position: relative;
            border: 1px solid rgba(0,0,0,0.2);
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.3);
        }
        .cell:hover {
            transform: scale(1.2);
            z-index: 20;
            border-color: #fff;
        }
        .cell.on {
            background-color: var(--cell-on-note);
            box-shadow: 0 0 10px var(--cell-on-note), inset 0 1px 1px rgba(255,255,255,0.2);
            border-color: rgba(255,255,255,0.3);
        }
        .cell.triggered { animation: pulse 0.2s 1; }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.4); }
            100% { transform: scale(1); }
        }

        /* Color coding for modulator roles */
        .mod-len-track.on { background-color: var(--mod-len); box-shadow: 0 0 10px var(--mod-len); }
        .mod-synth-track.on { background-color: var(--mod-synth); box-shadow: 0 0 10px var(--mod-synth); }
        .mod-pitch-track.on { background-color: var(--mod-pitch); box-shadow: 0 0 10px var(--mod-pitch); }
        .mod-bitwise-track.on { background-color: var(--mod-bitwise); box-shadow: 0 0 10px var(--mod-bitwise); }
        .mod-transform-track.on { background-color: var(--mod-transform); box-shadow: 0 0 10px var(--mod-transform); }
        .mod-data-track.on { background-color: var(--mod-data); box-shadow: 0 0 10px var(--mod-data); }

    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
</head>
<body class="bg-gray-900 text-gray-100 flex flex-col items-center justify-center min-h-screen p-4 antialiased">

    <div class="w-full max-w-5xl mx-auto">
        <header class="text-center mb-6">
            <h1 class="text-4xl font-bold text-sky-400 tracking-wider" style="font-family: 'Roboto Mono', monospace;">Bitgrid</h1>
            <p class="text-slate-400 mt-1">A 32x32 generative audio automaton.</p>
        </header>

        <div id="controls" class="flex flex-wrap items-center justify-center gap-4 mb-6 p-4 bg-slate-800/50 rounded-xl shadow-lg border border-slate-700">
            <button id="play-button" class="px-6 py-2 bg-sky-500 hover:bg-sky-600 text-white font-bold rounded-lg transition-all duration-200 shadow-md hover:shadow-sky-400/30 w-28">
                Play
            </button>
            <div class="flex items-center space-x-3">
                <label for="bpm-slider" class="text-sm font-medium text-slate-300">BPM</label>
                <input type="range" id="bpm-slider" min="30" max="240" value="120" class="w-32 md:w-48">
                <span id="bpm-display" class="text-sm font-mono bg-slate-700 px-3 py-1 rounded-md w-14 text-center">120</span>
            </div>
             <button id="clear-button" class="px-5 py-2 bg-rose-600 hover:bg-rose-700 text-white font-bold rounded-lg transition-all duration-200 shadow-md hover:shadow-rose-500/30">
                Clear
            </button>
            <button id="random-button" class="px-5 py-2 bg-purple-600 hover:bg-purple-700 text-white font-bold rounded-lg transition-all duration-200 shadow-md hover:shadow-purple-500/30">
                Random
            </button>
            <button id="help-button" class="px-5 py-2 bg-slate-600 hover:bg-slate-700 text-white font-bold rounded-lg transition-all duration-200 shadow-md">
                Help
            </button>
        </div>

        <div id="grid-container" class="w-full max-w-2xl mx-auto">
            <div class="grid">
                <div class="playhead"></div>
                <!-- Grid will be populated by JavaScript -->
            </div>
        </div>
    </div>
    
    <!-- Help Modal -->
    <div id="help-modal" class="fixed inset-0 bg-black/70 backdrop-blur-sm flex items-center justify-center p-4 z-50 hidden">
        <div class="bg-slate-800 border border-slate-700 rounded-xl shadow-2xl p-6 max-w-3xl w-full text-slate-300 overflow-y-auto max-h-full">
            <h2 class="text-2xl font-bold mb-4 text-sky-400">How Bitgrid Works</h2>
            <div class="space-y-4 text-sm">
                <p>Bitgrid is a sequencer where the grid itself is the program. The playhead sweeps from left to right, and active switches trigger events. Some switches define behavior, while others trigger actions.</p>
                
                 <div>
                    <h3 class="font-semibold text-lg text-white mb-2">Implicit Sound Modulation</h3>
                    <p>The sound engine reacts dynamically to the patterns on the grid:</p>
                    <ul class="list-disc list-inside space-y-1 pl-2">
                        <li><strong>Pattern Density → Envelope:</strong> The number of active notes in a track's sequence determines its envelope. Sparse patterns have a long, ambient decay, while dense patterns become short and percussive.</li>
                        <li><strong>Note Concurrency → Filter:</strong> A master low-pass filter opens and closes based on how many notes are playing at the same time. More simultaneous notes create a brighter, more open sound.</li>
                    </ul>
                </div>

                 <div>
                    <h3 class="font-semibold text-lg text-white mb-2">Modulator Tracks (Rows 24-31)</h3>
                    <p>Modulators modify note tracks. The target is determined by the <span class="italic">total number of active switches</span> in the modulator's row.</p>
                    <ul class="list-disc list-inside space-y-2 pl-2">
                        <li><strong><span style="color: var(--mod-len)">Row 24 (Length Mod):</span></strong> Modulates the <strong class="text-yellow-400">Length</strong> of its target note track.</li>
                        <li><strong><span style="color: var(--mod-synth)">Row 25 (Random Synth Mod):</span></strong> Sets the <strong class="text-green-400">Synth Type</strong> of its target note track to a new, random type.</li>
                        <li><strong><span style="color: var(--mod-pitch)">Row 26 (Pitch Offset):</span></strong> Adds a pitch offset to its target note track for one step.</li>
                        <li><strong><span style="color: var(--mod-bitwise)">Row 27 (XOR Operator):</span></strong> Performs a bitwise XOR between its own pattern and the target note track's pattern.</li>
                        <li><strong><span style="color: var(--mod-bitwise)">Row 28 (OR Operator):</span></strong> Performs a bitwise OR (combines notes) between its pattern and the target's.</li>
                        <li><strong><span style="color: var(--mod-bitwise)">Row 29 (AND Operator):</span></strong> Performs a bitwise AND (filters notes) between its pattern and the target's.</li>
                        <li><strong><span style="color: var(--mod-transform)">Row 30 (Multi-Transform Trigger):</span></strong> Applies a <strong class="text-purple-400">stack of transformations</strong> to its target. The transformations are selected on Row 31.</li>
                        <li><strong><span style="color: var(--mod-data)">Row 31 (Transformation Selector):</span></strong> This row is <strong class="text-purple-400">data only</strong>. Its active switches determine which transformations Row 30 will apply. The first 6 columns correspond to: <strong>Invert, Flip, Rotate Left, Rotate Right, Shift Left, Shift Right</strong>.</li>
                    </ul>
                </div>
            </div>
            <button id="close-help" class="mt-6 w-full bg-sky-500 hover:bg-sky-600 text-white font-bold py-2 px-4 rounded-lg">Got It</button>
        </div>
    </div>


    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- CONSTANTS AND CONFIGURATION ---
            const GRID_SIZE = 32;
            const NOTE_TRACKS = 24;
            const MOD_TRACKS = 8;
            const PENTATONIC_SCALE = ['C', 'D#', 'F', 'G', 'A#'];
            
            const SYNTH_CONFIGS = [
                { name: 'Sine', type: Tone.Synth, options: { oscillator: { type: 'sine' } } },
                { name: 'Triangle', type: Tone.Synth, options: { oscillator: { type: 'triangle' } } },
                { name: 'Sawtooth', type: Tone.Synth, options: { oscillator: { type: 'sawtooth' } } },
                { name: 'Square', type: Tone.Synth, options: { oscillator: { type: 'square' } } },
                { name: 'FM', type: Tone.FMSynth, options: { harmonicity: 1.5, modulationIndex: 5 } },
                { name: 'AM', type: Tone.AMSynth, options: { harmonicity: 2 } },
                { name: 'Pluck', type: Tone.PluckSynth, options: { attackNoise: 0.5, dampening: 4000 } },
                { name: 'Membrane', type: Tone.MembraneSynth, options: { pitchDecay: 0.05, octaves: 10 } }
            ];
            const SYNTH_TYPE_BITS = 3;
            const TRIGGER_START_COL = SYNTH_TYPE_BITS;
            const TRIGGER_END_COL = 27;
            const TRIGGER_LENGTH = TRIGGER_END_COL - TRIGGER_START_COL;

            // --- STATE MANAGEMENT ---
            let gridState = Array(GRID_SIZE).fill(0).map(() => Array(GRID_SIZE).fill(false));
            let trackSynths = [];
            let masterFilter;
            let isPlaying = false;
            let currentStep = 0;
            let isMouseDown = false;
            let lastToggledCell = null;

            // --- DOM ELEMENTS ---
            const gridContainer = document.querySelector('.grid');
            const playButton = document.getElementById('play-button');
            const bpmSlider = document.getElementById('bpm-slider');
            const bpmDisplay = document.getElementById('bpm-display');
            const clearButton = document.getElementById('clear-button');
            const randomButton = document.getElementById('random-button');
            const helpButton = document.getElementById('help-button');
            const helpModal = document.getElementById('help-modal');
            const closeHelpButton = document.getElementById('close-help');

            // --- AUDIO INITIALIZATION ---
            function setupAudio() {
                const limiter = new Tone.Limiter(-6).toDestination();
                masterFilter = new Tone.Filter(20000, "lowpass").connect(limiter);
                trackSynths = [];
                for (let i = 0; i < NOTE_TRACKS; i++) {
                    const synthsForTrack = {};
                    SYNTH_CONFIGS.forEach(config => {
                        const synthOptions = { 
                            ...config.options, 
                            volume: -15, // Lowered individual synth volume further
                            envelope: { attack: 0.01, decay: 0.2, sustain: 0.5, release: 1.0 } 
                        };
                        const synth = new config.type(synthOptions).connect(masterFilter);
                        synthsForTrack[config.name] = synth;
                    });
                    trackSynths.push(synthsForTrack);
                }
            }

            // --- GRID UI & INTERACTION ---
            function createGridUI() {
                gridContainer.innerHTML = '<div class="playhead"></div>';
                gridContainer.appendChild(document.createElement('div'));
                for (let i = 0; i < GRID_SIZE; i++) {
                    const header = document.createElement('div');
                    header.classList.add('header', 'col-header'); header.textContent = i;
                    gridContainer.appendChild(header);
                }
                for (let row = 0; row < GRID_SIZE; row++) {
                    const rowHeader = document.createElement('div');
                    rowHeader.classList.add('header', 'row-header'); rowHeader.textContent = row;
                    gridContainer.appendChild(rowHeader);
                    for (let col = 0; col < GRID_SIZE; col++) {
                        const cell = document.createElement('div');
                        cell.classList.add('cell');
                        cell.dataset.row = row; cell.dataset.col = col;
                        
                        // Add role-based classes for styling
                        if (row >= NOTE_TRACKS) {
                            switch(row) {
                                case 24: cell.classList.add('mod-len-track'); break;
                                case 25: cell.classList.add('mod-synth-track'); break;
                                case 26: cell.classList.add('mod-pitch-track'); break;
                                case 27: case 28: case 29: cell.classList.add('mod-bitwise-track'); break;
                                case 30: cell.classList.add('mod-transform-track'); break;
                                case 31: cell.classList.add('mod-data-track'); break;
                            }
                        }
                        gridContainer.appendChild(cell);
                    }
                }
                updateGridUI();
            }
            
            function updateGridUI() {
                for (let row = 0; row < GRID_SIZE; row++) {
                    for (let col = 0; col < GRID_SIZE; col++) {
                        const cell = gridContainer.querySelector(`.cell[data-row='${row}'][data-col='${col}']`);
                        if (cell) cell.classList.toggle('on', gridState[row][col]);
                    }
                }
            }
            
            function toggleCell(cellElement, forceState) {
                if (!cellElement) return;
                const row = parseInt(cellElement.dataset.row), col = parseInt(cellElement.dataset.col);
                const newState = forceState !== undefined ? forceState : !gridState[row][col];
                if (gridState[row][col] !== newState) {
                    gridState[row][col] = newState;
                    cellElement.classList.toggle('on', newState);
                }
            }
            
            // --- HELPER FUNCTIONS ---
            const bitsToNum = (bits) => bits.reduce((acc, bit, i) => acc + (bit ? 1 << (bits.length - 1 - i) : 0), 0);
            const numToBits = (num, bitCount) => Array.from({ length: bitCount }, (_, i) => (num >> (bitCount - 1 - i)) & 1 === 1);
            const countActive = (arr) => arr.filter(Boolean).length;
            const getPitch = (trackIndex) => `${PENTATONIC_SCALE[trackIndex % PENTATONIC_SCALE.length]}${Math.floor(trackIndex / PENTATONIC_SCALE.length) + 2}`;
            
            function randomizeGrid() {
                for (let row = 0; row < GRID_SIZE; row++) {
                    for (let col = 0; col < GRID_SIZE; col++) {
                        gridState[row][col] = Math.random() > 0.85;
                    }
                }
            }

            // --- SEQUENCER LOGIC ---
            const loop = new Tone.Loop(time => {
                // MODIFY PHASE (Mod -> Grid)
                for (let row = NOTE_TRACKS; row < GRID_SIZE; row++) {
                    if (gridState[row][currentStep] && row !== 31) { // Row 31 is data-only
                        const modRow = gridState[row];
                        const activeCount = countActive(modRow);
                        const targetNoteTrack = activeCount % NOTE_TRACKS;
                        
                        let targetPattern = gridState[targetNoteTrack].slice(TRIGGER_START_COL, TRIGGER_END_COL);
                        const modPattern = modRow.slice(TRIGGER_START_COL, TRIGGER_END_COL);

                        switch(row) {
                            case 24: // Modulate Length
                                const newLengthBits = numToBits((currentStep % 31) + 1, 5);
                                for(let i = 0; i < 5; i++) gridState[targetNoteTrack][27 + i] = newLengthBits[i];
                                break;
                            case 25: // Random Synth Type
                                const randomSynthIndex = Math.floor(Math.random() * SYNTH_CONFIGS.length);
                                const newSynthBits = numToBits(randomSynthIndex, SYNTH_TYPE_BITS);
                                for(let i = 0; i < SYNTH_TYPE_BITS; i++) gridState[targetNoteTrack][i] = newSynthBits[i];
                                break;
                            case 26: // Pitch Offset handled in play phase
                                break;
                            case 27: // XOR Operator
                                for(let i=0; i < TRIGGER_LENGTH; i++) targetPattern[i] = targetPattern[i] !== modPattern[i];
                                break;
                            case 28: // OR Operator
                                for(let i=0; i < TRIGGER_LENGTH; i++) targetPattern[i] = targetPattern[i] || modPattern[i];
                                break;
                            case 29: // AND Operator
                                for(let i=0; i < TRIGGER_LENGTH; i++) targetPattern[i] = targetPattern[i] && modPattern[i];
                                break;
                            case 30: // Multi-Transform Trigger
                                const selectors = gridState[31];
                                if (selectors[0]) targetPattern = targetPattern.map(bit => !bit); // Invert
                                if (selectors[1]) targetPattern.reverse(); // Flip
                                if (selectors[2]) targetPattern.push(targetPattern.shift()); // Rotate Left
                                if (selectors[3]) targetPattern.unshift(targetPattern.pop()); // Rotate Right
                                if (selectors[4]) { targetPattern.shift(); targetPattern.push(false); } // Shift Left
                                if (selectors[5]) { targetPattern.pop(); targetPattern.unshift(false); } // Shift Right
                                break;
                        }

                        if (row >= 27 && row <= 30) {
                             for(let i = 0; i < TRIGGER_LENGTH; i++) {
                                gridState[targetNoteTrack][TRIGGER_START_COL + i] = targetPattern[i];
                            }
                        }
                    }
                }

                // PLAY PHASE (Process Note Tracks)
                let notesThisStep = 0;
                for (let row = 0; row < NOTE_TRACKS; row++) {
                    const trackState = gridState[row];
                    const patternLength = bitsToNum(trackState.slice(27, 32)) || GRID_SIZE;
                    
                    if (currentStep < patternLength && trackState[currentStep + TRIGGER_START_COL]) {
                        notesThisStep++;
                        const synthTypeIndex = bitsToNum(trackState.slice(0, SYNTH_TYPE_BITS));
                        const config = SYNTH_CONFIGS[synthTypeIndex];
                        const synth = trackSynths[row][config.name];
                        let pitch = getPitch(row);

                        // Density -> Envelope Modulation
                        if (synth.envelope) {
                            const density = countActive(trackState.slice(TRIGGER_START_COL, TRIGGER_END_COL));
                            const releaseTime = Math.max(0.05, 1.5 - (density / TRIGGER_LENGTH) * 1.45);
                            synth.envelope.release = releaseTime;
                        }

                        if (gridState[26][currentStep]) {
                            const activeCount = countActive(gridState[26]);
                            if (row === (activeCount % NOTE_TRACKS)) {
                                pitch = Tone.Frequency(pitch).transpose(currentStep - 16);
                            }
                        }
                        
                        synth.triggerAttackRelease(pitch, '16n', time);
                        
                        const cell = gridContainer.querySelector(`.cell[data-row='${row}'][data-col='${currentStep + TRIGGER_START_COL}']`);
                        if(cell) {
                            cell.classList.add('triggered');
                            setTimeout(() => cell.classList.remove('triggered'), 200);
                        }
                    }
                }
                
                // Concurrency -> Filter Modulation
                const filterFreq = 200 + (notesThisStep * notesThisStep) * 150;
                masterFilter.frequency.rampTo(Math.min(filterFreq, 20000), 0.05);

                // UPDATE & ADVANCE
                requestAnimationFrame(() => {
                    updateGridUI();
                    gridContainer.style.setProperty('--playhead-col', currentStep + 1);
                });
                currentStep = (currentStep + 1) % GRID_SIZE;
            }, '16n');

            // --- EVENT LISTENERS ---
            playButton.addEventListener('click', async () => {
                if (Tone.context.state !== 'running') {
                    await Tone.start();
                    setupAudio();
                }
                isPlaying = !isPlaying;
                if (isPlaying) {
                    Tone.Transport.start();
                    loop.start(0);
                    playButton.textContent = 'Stop';
                    playButton.classList.replace('bg-sky-500', 'bg-pink-500');
                    playButton.classList.replace('hover:bg-sky-600', 'hover:bg-pink-600');
                } else {
                    Tone.Transport.stop();
                    loop.stop();
                    currentStep = 0;
                    gridContainer.style.setProperty('--playhead-col', 0);
                    playButton.textContent = 'Play';
                    playButton.classList.replace('bg-pink-500', 'bg-sky-500');
                    playButton.classList.replace('hover:bg-pink-600', 'hover:bg-sky-600');
                }
            });

            bpmSlider.addEventListener('input', (e) => {
                Tone.Transport.bpm.value = e.target.value;
                bpmDisplay.textContent = e.target.value;
            });

            clearButton.addEventListener('click', () => {
                gridState = Array(GRID_SIZE).fill(0).map(() => Array(GRID_SIZE).fill(false));
                updateGridUI();
            });

            randomButton.addEventListener('click', () => {
                randomizeGrid();
                updateGridUI();
            });

            helpButton.addEventListener('click', () => helpModal.classList.remove('hidden'));
            closeHelpButton.addEventListener('click', () => helpModal.classList.add('hidden'));
            
            // Grid drawing listeners
            gridContainer.addEventListener('mousedown', (e) => { if (e.target.classList.contains('cell')) { isMouseDown = true; const forceState = !gridState[e.target.dataset.row][e.target.dataset.col]; toggleCell(e.target, forceState); lastToggledCell = e.target; } });
            gridContainer.addEventListener('mouseover', (e) => { if (isMouseDown && e.target.classList.contains('cell') && e.target !== lastToggledCell) { const forceState = gridState[lastToggledCell.dataset.row][lastToggledCell.dataset.col]; toggleCell(e.target, forceState); } });
            window.addEventListener('mouseup', () => { isMouseDown = false; lastToggledCell = null; });
            gridContainer.addEventListener('touchstart', (e) => { e.preventDefault(); if (e.target.classList.contains('cell')) { isMouseDown = true; const forceState = !gridState[e.target.dataset.row][e.target.dataset.col]; toggleCell(e.target, forceState); lastToggledCell = e.target; } }, { passive: false });
            gridContainer.addEventListener('touchmove', (e) => { e.preventDefault(); if (isMouseDown) { const touch = e.touches[0]; const element = document.elementFromPoint(touch.clientX, touch.clientY); if (element && element.classList.contains('cell') && element !== lastToggledCell) { const forceState = gridState[lastToggledCell.dataset.row][lastToggledCell.dataset.col]; toggleCell(element, forceState); } } }, { passive: false });
            window.addEventListener('touchend', () => { isMouseDown = false; lastToggledCell = null; });


            // --- INITIALIZATION ---
            createGridUI();
        });
    </script>
</body>
</html>
