<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>100√ó100√ó100 Grid Bot Sim ‚Äî Top/Side/Iso + Zoom (Full)</title>
<style>
  :root { --ui:#e7edf4; --bg1:#0b0d10; --bg2:#0a0d11; --p1:#11151a; --p2:#0f1318; }
  html,body{height:100%}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif;background:linear-gradient(180deg,var(--bg1),#080a0d 40%);color:var(--ui)}
  header{padding:12px 18px;border-bottom:1px solid #1a212b;background:linear-gradient(180deg,#0e1217,var(--bg2));position:sticky;top:0;z-index:5}
  header h1{margin:0;font-size:16px;font-weight:600;letter-spacing:.2px}
  .wrap{display:grid;grid-template-columns:380px 1fr;gap:14px;padding:14px}
  .panel{background:var(--p1);border:1px solid #18202a;border-radius:14px;box-shadow:0 10px 30px rgba(0,0,0,.35);overflow:hidden}
  .panel header{background:var(--p2);border:0;padding:10px 14px}
  .panel header h2{margin:0;font-size:13px;opacity:.9}
  .panel .inner{padding:12px 14px}
  .grid{display:grid;grid-template-columns:repeat(3,1fr);gap:12px}
  .fullrow{margin-top:12px}
  canvas{width:100%;height:320px;background:#0b0f14;border-radius:12px;border:1px solid #16202a;display:block}
  #cvTopZoom{height:480px}
  .btns{display:flex;gap:8px;flex-wrap:wrap}
  .pill{padding:6px 10px;border-radius:999px;border:1px solid #1b2633;background:#0b0f14;color:var(--ui);font-size:12px;cursor:pointer}
  .pill[data-on="1"]{background:linear-gradient(180deg,#13202c,#0b1520);border-color:#223546;box-shadow:inset 0 0 0 1px #2a4358}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  label{display:block;font-size:12px;color:#a8b6c6;margin:8px 0 6px}
  input[type="number"], input[type="text"], select, textarea{ width:100%;padding:8px 10px;border-radius:10px;border:1px solid #1b2633;background:#0b0f14;color:var(--ui);font-size:13px;box-sizing:border-box }
  input[type="range"]{width:100%}
  textarea{min-height:120px;max-height:220px;font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}
  .mini{font-size:11px;color:#92a3b7}
  .legend{display:flex;align-items:center;gap:8px;margin-top:6px}
  .dot{width:10px;height:10px;border-radius:50%}
  .dot.orange{background:#ffa726}
  .dot.green{background:#20e37a}
  .stat{font-size:12px;color:#cfe6ff;border:1px solid #24415e;background:#0a1320;border-radius:10px;padding:6px 8px;margin-top:8px}
</style>
</head>
<body>
<header>
  <h1>100√ó100√ó100 Cube World ‚Äî Top / Side / Iso / Zoom ¬∑ Orange vs Green ¬∑ Paths ¬∑ Trails ¬∑ PNG Export ¬∑ DSL</h1>
</header>

<div class="wrap">
  <section class="panel">
    <header><h2>Control Panel</h2></header>
    <div class="inner">
      <div class="btns">
        <button class="pill" id="btnStart">‚ñ∂ Start</button>
        <button class="pill" id="btnPause">‚è∏ Pause</button>
        <button class="pill" id="btnReset">‚ü≤ Reset</button>
        <button class="pill" id="btnNewGoal">üéØ New Goal</button>
        <button class="pill" id="btnClearTrails">üßπ Clear Trails</button>
        <button class="pill" id="btnWireTop">‚ò∞ Wire: Top</button>
        <button class="pill" id="btnWireSide">‚ò∞ Wire: Side</button>
        <button class="pill" id="btnWireIso">‚ò∞ Wire: Iso</button>
        <button class="pill" id="btnTogglePaths">‚Ä¢ Path Overlay</button>
      </div>

      <label>Time scale</label>
      <div class="btns">
        <button class="pill" data-scale="1">1√ó</button>
        <button class="pill" data-scale="5">5√ó</button>
        <button class="pill" data-scale="10">10√ó</button>
      </div>

      <div class="row">
        <div><label>Orange bots</label><input type="number" id="orangeCount" min="0" max="200" value="12" /></div>
        <div><label>Green bots</label><input type="number" id="greenCount" min="0" max="200" value="12" /></div>
      </div>

      <div class="row">
        <div>
          <label>Goal policy</label>
          <select id="goalPolicy">
            <option value="random">Randomized (new goal when any bot reaches)</option>
            <option value="team">Team completion (new goal when all bots reach)</option>
          </select>
        </div>
        <div>
          <label>Seed</label>
          <input type="text" id="seedInput" value="ark100" />
        </div>
      </div>

      <details>
        <summary class="mini">Green gait & constraints</summary>
        <div class="row">
          <div><label>Left-turn bias (0‚Äì1)</label><input type="number" id="biasLeft" step="0.05" min="0" max="1" value="0.25" /></div>
          <div><label>Lateral wobble (0‚Äì1)</label><input type="number" id="wobble" step="0.05" min="0" max="1" value="0.35" /></div>
        </div>
        <div class="row">
          <div><label>Fatigue rate (per s)</label><input type="number" id="fatigueRate" step="0.0005" min="0" max="0.02" value="0.004" /></div>
          <div><label>Speed jitter (0‚Äì1)</label><input type="number" id="speedJitter" step="0.05" min="0" max="1" value="0.3" /></div>
        </div>
      </details>

      <div class="row" style="margin-top:10px">
        <div>
          <label>Follow stiffness <span class="mini">(<span id="lblFollow">6.0</span>)</span></label>
          <input type="range" id="sFollow" min="1" max="12" step="0.1" value="6" />
        </div>
        <div>
          <label>Zoom (fourth view) <span class="mini">(<span id="lblZoom">1.0√ó</span>)</span></label>
          <input type="range" id="sZoom" min="0.5" max="4" step="0.1" value="1.0" />
        </div>
      </div>

      <div class="row" style="margin-top:10px">
        <div>
          <label>Top view zoom <span class="mini">(<span id="lblZoomTop">1.0√ó</span>)</span></label>
          <input type="range" id="sZoomTop" min="0.5" max="3" step="0.1" value="1.0" />
        </div>
        <div>
          <label>Side view zoom <span class="mini">(<span id="lblZoomSide">1.0√ó</span>)</span></label>
          <input type="range" id="sZoomSide" min="0.5" max="3" step="0.1" value="1.0" />
        </div>
      </div>

      <div class="row" style="margin-top:6px">
        <div>
          <label>Iso view zoom <span class="mini">(<span id="lblZoomIso">1.0√ó</span>)</span></label>
          <input type="range" id="sZoomIso" min="0.5" max="3" step="0.1" value="1.0" />
        </div>
        <div></div>
      </div>

      <div class="legend"><span class="dot orange"></span> Orange = shortest paths (stairs or ramps)</div>
      <div class="legend"><span class="dot green"></span> Green = accessibility-aware (ramps only up; stairs/ramps down) + gait</div>
      <div class="stat" id="statBox">Green ascents: 0 ¬∑ descents: 0</div>

      <label style="margin-top:12px">World / Bots / Goals / Cameras ‚Äî DSL</label>
      <textarea id="dsl" spellcheck="false">seed=ark100
world.size=100
bots.orange=12 bots.green=12
goals.policy=random
orange.speed=1.0
green.speed=0.9 green.bias=0.25 green.wobble=0.35 green.fatigue=0.004 green.jitter=0.3
camera.follow=6.0 camera.zoom4=1.0
camera.top.zoom=1.0 camera.side.zoom=1.0 camera.iso.zoom=1.0</textarea>
      <div class="btns">
        <button class="pill" id="btnApplyDSL">Apply DSL</button>
        <button class="pill" id="btnExportTop">‚¨á Export Top (2√ó)</button>
        <button class="pill" id="btnExportSide">‚¨á Export Side (2√ó)</button>
        <button class="pill" id="btnExportIso">‚¨á Export Iso (2√ó)</button>
      </div>
    </div>
  </section>

  <section class="panel">
    <header><h2>Views</h2></header>
    <div class="inner">
      <div class="grid">
        <div>
          <canvas id="cvTop" width="720" height="720" title="Top-down (x,y)"></canvas>
          <div class="mini">Top-down: floors (x,y); bots projected ignoring z. Per-layer stairs ‚ñ≤ / ramps ‚ñ≠.</div>
        </div>
        <div>
          <canvas id="cvSide" width="720" height="360" title="Side-on (x,z)"></canvas>
          <div class="mini">Side-on: x horizontal, z vertical (0 bottom‚Üí99 top), y collapsed.</div>
        </div>
        <div>
          <canvas id="cvIso" width="720" height="540" title="Isometric"></canvas>
          <div class="mini">Isometric: 3D rhombic projection, trails, and Z-slice planes (every 10) when wireframe is on.</div>
        </div>
      </div>
      <div class="fullrow">
        <canvas id="cvTopZoom" width="1440" height="480" title="Top-down (zoom-follow on first green)"></canvas>
        <div class="mini">Zoomed Top-down: follows the first green bot with smooth camera. Wireframe & Path Overlay apply.</div>
      </div>
    </div>
  </section>
</div>

<script>
(() => {
  // ------------------ Constants & Colors ------------------
  const SIZE=100, WORLD_H=100;
  const COL_ORANGE="#ffa726", COL_GREEN="#20e37a", COL_GOAL="#ffd54f";
  // DOM
  const $=id=>document.getElementById(id);
  const cvTop=$('cvTop'), cvSide=$('cvSide'), cvIso=$('cvIso'), cvTopZoom=$('cvTopZoom');
  const ctxTop=cvTop.getContext('2d'), ctxSide=cvSide.getContext('2d'), ctxIso=cvIso.getContext('2d'), ctxTopZoom=cvTopZoom.getContext('2d');

  const btnStart=$('btnStart'), btnPause=$('btnPause'), btnReset=$('btnReset'), btnNewGoal=$('btnNewGoal'), btnClearTrails=$('btnClearTrails');
  const btnWireTop=$('btnWireTop'), btnWireSide=$('btnWireSide'), btnWireIso=$('btnWireIso'), btnTogglePaths=$('btnTogglePaths');
  const btnExportTop=$('btnExportTop'), btnExportSide=$('btnExportSide'), btnExportIso=$('btnExportIso');
  const btnApplyDSL=$('btnApplyDSL'), dslEl=$('dsl');
  const orangeCountEl=$('orangeCount'), greenCountEl=$('greenCount'), goalPolicyEl=$('goalPolicy'), seedInputEl=$('seedInput');
  const biasLeftEl=$('biasLeft'), wobbleEl=$('wobble'), fatigueRateEl=$('fatigueRate'), speedJitterEl=$('speedJitter');
  const sFollow=$('sFollow'), sZoom=$('sZoom'), lblFollow=$('lblFollow'), lblZoom=$('lblZoom');
  const sZoomTop=$('sZoomTop'), sZoomSide=$('sZoomSide'), sZoomIso=$('sZoomIso');
  const lblZoomTop=$('lblZoomTop'), lblZoomSide=$('lblZoomSide'), lblZoomIso=$('lblZoomIso');
  const statBox=$('statBox');
  const timeScaleButtons=Array.from(document.querySelectorAll('[data-scale]'));

  // ------------------ State ------------------
  let running=true, timeScale=1, tPrev=0;
  let showWireTop=false, showWireSide=false, showWireIso=false, showPaths=false;
  let orangeSpeed=1.0, greenSpeed=0.9;
  let goalPolicy='random';
  // Follow-cam (4th view)
  let camX=SIZE/2, camY=SIZE/2, camZ=0, followSpeed=6.0, zoomScale=1.0, VIEW_BASE_TILES=16;
  // Per-view zooms
  let zoomTop=1.0, zoomSide=1.0, zoomIso=1.0;
  // Counters
  let greenAscents=0, greenDescents=0;

  // ------------------ RNG & Noise ------------------
  function hashStr(s){ let h=1779033703 ^ s.length; for(let i=0;i<s.length;i++){ h=Math.imul(h ^ s.charCodeAt(i),3432918353); h=(h<<13)|(h>>>19);} return (h>>>0); }
  function mulberry32(a){ return function(){ let t=a+=0x6D2B79F5; t=Math.imul(t^(t>>>15),t|1); t^=t+Math.imul(t^(t>>>7),t|61); return ((t^(t>>>14))>>>0)/4294967296; } }
  let seed='ark100', rng=mulberry32(hashStr(seed));
  function reseed(s){ seed=s; rng=mulberry32(hashStr(s)); }
  function clamp(x,a,b){ return Math.max(a,Math.min(b,x)); }
  const IDX=(x,y,z)=> z*SIZE*SIZE + y*SIZE + x;

  function fade(t){ return t*t*(3-2*t); }
  function hash3(i,j,k){ let h=2166136261; h=Math.imul(h^i,16777619); h=Math.imul(h^j,16777619); h=Math.imul(h^k,16777619); h^=(h>>>13); return (h>>>0)/4294967295; }
  function noise3(x,y,z){ const xi=Math.floor(x), yi=Math.floor(y), zi=Math.floor(z); const xf=x-xi, yf=y-yi, zf=z-zi; const u=fade(xf), v=fade(yf), w=fade(zf); const lerp=(a,b,t)=>a+(b-a)*t;
    const c000=hash3(xi,yi,zi), c100=hash3(xi+1,yi,zi), c010=hash3(xi,yi+1,zi), c110=hash3(xi+1,yi+1,zi), c001=hash3(xi,yi,zi+1), c101=hash3(xi+1,yi,zi+1), c011=hash3(xi,yi+1,zi+1), c111=hash3(xi+1,yi+1,zi+1);
    const x00=lerp(c000,c100,u), x10=lerp(c010,c110,u), x01=lerp(c001,c101,u), x11=lerp(c011,c111,u); const y0=lerp(x00,x10,v), y1=lerp(x01,x11,v); return lerp(y0,y1,w);
  }

  // ------------------ World ------------------
  const world={ size:SIZE, floors:new Float32Array(SIZE*SIZE*WORLD_H), access:new Uint8Array(SIZE*SIZE*WORLD_H), stairs:new Uint8Array(WORLD_H*4), ramps:new Uint8Array(WORLD_H*4) };
  function cornerXY(c){ return c===0?{x:0,y:0}:c===1?{x:SIZE-1,y:0}:c===2?{x:0,y:SIZE-1}:{x:SIZE-1,y:SIZE-1}; }
  function isCornerStairAt(x,y,z){ for(let c=0;c<4;c++) if(world.stairs[z*4+c]){ const p=cornerXY(c); if(p.x===x && p.y===y) return true; } return false; }
  function isCornerRampAt (x,y,z){ for(let c=0;c<4;c++) if(world.ramps [z*4+c]){ const p=cornerXY(c); if(p.x===x && p.y===y) return true; } return false; }

  function genWorld(){
    const scale=0.12;
    for(let z=0; z<WORLD_H; z++){
      for(let y=0; y<SIZE; y++){
        for(let x=0; x<SIZE; x++){
          const n = 0.4*noise3(x*scale, y*scale, z*scale)
                  +0.3*noise3(x*scale*2, y*scale*2, z*scale*2)
                  +0.3*noise3(x*scale*4+13.7, y*scale*4+7.3, z*scale*4+2.5);
          const noisy = clamp(n,0,1);
          world.floors[IDX(x,y,z)] = noisy;
          world.access[IDX(x,y,z)] = Math.round((1-noisy)*10); // 10 = most accessible
        }
      }
      // stairs & ramps: different corners each layer
      const corners=[0,1,2,3];
      for(let i=corners.length-1;i>0;i--){ const j=(rng()*(i+1))|0; [corners[i],corners[j]]=[corners[j],corners[i]]; }
      const sCorner=corners[0], rCorner=corners[1];
      for(let c=0;c<4;c++){ world.stairs[z*4+c]=0; world.ramps[z*4+c]=0; }
      world.stairs[z*4+sCorner]=1;
      world.ramps [z*4+rCorner]=1;
    }
  }

  // ------------------ Goals ------------------
  const goalState={ current:{x:50,y:50,z:50}, reachedBy:new Set() };
  const randomGoal=()=>({x:(rng()*SIZE)|0,y:(rng()*SIZE)|0,z:(rng()*WORLD_H)|0});
  function setNewGoal(){ goalState.current=randomGoal(); goalState.reachedBy.clear(); }

  // ------------------ Bots ------------------
  const bots=[];
  function newBot(kind){
    const x=(rng()*SIZE)|0, y=(rng()*SIZE)|0, z=(rng()*WORLD_H)|0;
    return { kind,x,y,z, path:[], pathIndex:0, reached:false,
             vx:0,vy:0,vz:0, speedBase:(kind==='orange'?orangeSpeed:greenSpeed), speedSmoothed:(kind==='orange'?orangeSpeed:greenSpeed),
             fatigue:0, lastDir:{dx:1,dy:0,dz:0} };
  }

  // A* + Fallback Pathfinding
  const DIRS=[ [1,0,0],[-1,0,0],[0,1,0],[0,-1,0],[0,0,1],[0,0,-1] ];
  const heuristic=(a,b)=>Math.abs(a.x-b.x)+Math.abs(a.y-b.y)+Math.abs(a.z-b.z);
  function canMove(bot,x,y,z,nx,ny,nz){
    if(nx<0||ny<0||nz<0||nx>=SIZE||ny>=SIZE||nz>=WORLD_H) return false;
    const dz=nz-z;
    if(dz===1){ // going up
      const stair=isCornerStairAt(x,y,z), ramp=isCornerRampAt(x,y,z);
      return bot.kind==='green' ? ramp : (stair||ramp);
    }
    if(dz===-1){ // going down
      return isCornerStairAt(nx,ny,nz) || isCornerRampAt(nx,ny,nz);
    }
    return true;
  }
  function moveCost(bot,nx,ny,nz){
    if(bot.kind==='orange') return 1;
    const acc=world.access[IDX(nx,ny,nz)];
    return 1 + (10-acc)*0.2;
  }
  function TinyQueue(data,cmp){ this.data=data||[]; this.length=this.data.length; this.cmp=cmp||( (a,b)=>a<b?-1:a>b?1:0 ); if(this.length){ for(let i=(this.length>>1); i>=0; i--) this._down(i);} }
  TinyQueue.prototype.push=function(it){ this.data.push(it); this.length++; this._up(this.length-1); };
  TinyQueue.prototype.pop=function(){ if(!this.length) return; const top=this.data[0], bot=this.data.pop(); this.length--; if(this.length){ this.data[0]=bot; this._down(0);} return top; };
  TinyQueue.prototype._up=function(p){ const d=this.data,c=this.cmp, it=d[p]; while(p>0){ const parent=(p-1)>>1, cur=d[parent]; if(c(it,cur)>=0) break; d[p]=cur; p=parent;} d[p]=it; };
  TinyQueue.prototype._down=function(p){ const d=this.data,c=this.cmp, half=this.length>>1, it=d[p]; while(p<half){ let left=(p<<1)+1, right=left+1, best=d[left]; if(right<this.length && c(d[right],best)<0){ left=right; best=d[right]; } if(c(best,it)>=0) break; d[p]=best; p=left;} d[p]=it; };

  function findPath(bot, start, goal, maxNodes = 1200000) {
    // Primary A*
    const key = (i) => i.x | (i.y << 7) | (i.z << 14); // 100√ó100√ó100 safe packing
    const open = new TinyQueue([], (a, b) => a.f - b.f);
    const gScore = new Map();
    const came = new Map();
    gScore.set(key(start), 0);
    open.push({ x: start.x, y: start.y, z: start.z, f: heuristic(start, goal) });
    let visited = 0;
    while (open.length && visited < maxNodes) {
      const cur = open.pop(); visited++;
      if (cur.x === goal.x && cur.y === goal.y && cur.z === goal.z) {
        const path = [];
        let node = cur, k = key(cur);
        while (true) {
          path.push({ x: node.x, y: node.y, z: node.z });
          const prev = came.get(k); if (!prev) break;
          node = prev; k = key(node);
        }
        path.reverse(); return path;
      }
      const cKey = key(cur), cG = gScore.get(cKey) ?? Infinity;
      for (const d of DIRS) {
        const nx = cur.x + d[0], ny = cur.y + d[1], nz = cur.z + d[2];
        if (!canMove(bot, cur.x, cur.y, cur.z, nx, ny, nz)) continue;
        const tentative = cG + moveCost(bot, nx, ny, nz);
        const nKey = key({ x: nx, y: ny, z: nz });
        if (tentative < (gScore.get(nKey) ?? Infinity)) {
          gScore.set(nKey, tentative);
          came.set(nKey, cur);
          open.push({ x: nx, y: ny, z: nz, f: tentative + heuristic({ x: nx, y: ny, z: nz }, goal) });
        }
      }
    }

    // ----- Fallback: legal corner-route between floors -----
    function nearestCornerTo(x, y) {
      const cs = [ {c:0,x:0,y:0}, {c:1,x:SIZE-1,y:0}, {c:2,x:0,y:SIZE-1}, {c:3,x:SIZE-1,y:SIZE-1} ];
      let best = cs[0], bd = Infinity;
      for (const p of cs) { const d = Math.abs(p.x - x) + Math.abs(p.y - y); if (d < bd) { bd = d; best = p; } }
      return best;
    }
    function pushLine(path, from, to) {
      let { x, y, z } = from;
      while (x !== to.x) { x += (to.x > x ? 1 : -1); path.push({ x, y, z }); }
      while (y !== to.y) { y += (to.y > y ? 1 : -1); path.push({ x, y, z }); }
    }

    const path = [{ x: start.x, y: start.y, z: start.z }];
    let cx = start.x, cy = start.y, cz = start.z;

    const stepVert = (up) => {
      let targetCorner = -1;
      if (up) {
        for (let c = 0; c < 4; c++) {
          const p = cornerXY(c);
          if (bot.kind === 'green') { if (isCornerRampAt(p.x, p.y, cz)) { targetCorner = c; break; } }
          else { if (isCornerRampAt(p.x, p.y, cz) || isCornerStairAt(p.x, p.y, cz)) { targetCorner = c; break; } }
        }
      } else {
        for (let c = 0; c < 4; c++) {
          const p = cornerXY(c);
          if (isCornerRampAt(p.x, p.y, cz - 1) || isCornerStairAt(p.x, p.y, cz - 1)) { targetCorner = c; break; }
        }
      }
      if (targetCorner < 0) targetCorner = nearestCornerTo(cx, cy).c;
      const pc = cornerXY(targetCorner);
      pushLine(path, { x: cx, y: cy, z: cz }, { x: pc.x, y: pc.y, z: cz });
      const nz = cz + (up ? 1 : -1);
      path.push({ x: pc.x, y: pc.y, z: nz });
      cx = pc.x; cy = pc.y; cz = nz;
    };

    while (cz < goal.z) stepVert(true);
    while (cz > goal.z) stepVert(false);
    pushLine(path, { x: cx, y: cy, z: cz }, { x: goal.x, y: goal.y, z: goal.z });

    const cleaned = [path[0]];
    for (let i = 1; i < path.length; i++) {
      const a = cleaned[cleaned.length - 1], b = path[i];
      if (a.x !== b.x || a.y !== b.y || a.z !== b.z) cleaned.push(b);
    }
    return cleaned;
  }

  // ------------------ Trails ------------------
  const trailTop=document.createElement('canvas'); trailTop.width=cvTop.width; trailTop.height=cvTop.height; const trailTopCtx=trailTop.getContext('2d');
  const trailSide=document.createElement('canvas'); trailSide.width=cvSide.width; trailSide.height=cvSide.height; const trailSideCtx=trailSide.getContext('2d');
  const trailIso=document.createElement('canvas'); trailIso.width=cvIso.width; trailIso.height=cvIso.height; const trailIsoCtx=trailIso.getContext('2d');
  function clearTrails(){ trailTopCtx.clearRect(0,0,trailTop.width,trailTop.height); trailSideCtx.clearRect(0,0,trailSide.width,trailSide.height); trailIsoCtx.clearRect(0,0,trailIso.width,trailIso.height); }

  // ------------------ Init Bots ------------------
  function initBots(){
    bots.length=0;
    const oc=parseInt(orangeCountEl.value||'12',10), gc=parseInt(greenCountEl.value||'12',10);
    for(let i=0;i<oc;i++) bots.push(newBot('orange'));
    for(let i=0;i<gc;i++) bots.push(newBot('green'));
    for(const b of bots){ b.path=findPath(b,{x:b.x,y:b.y,z:b.z},goalState.current); b.pathIndex=0; b.reached=false; b._stuckT=0; }
    const g=bots.find(b=>b.kind==='green')||bots[0]; if(g){ camX=g.x; camY=g.y; camZ=Math.round(g.z); }
  }

  // ------------------ Bot Update (with stuck detector) ------------------
  function updateBot(b, dt) {
    // Stuck detection: if no progress for ~2 seconds, force replan
    b._stuckT = (b._stuckT ?? 0) + dt;
    const lastPX = b._lastPX ?? b.x, lastPY = b._lastPY ?? b.y, lastPZ = b._lastPZ ?? b.z;
    const progressed = Math.hypot(b.x - lastPX, b.y - lastPY) + Math.abs(b.z - lastPZ);
    if (progressed > 0.1) { b._stuckT = 0; }
    b._lastPX = b.x; b._lastPY = b.y; b._lastPZ = b.z;

    if (!b.path || b.pathIndex >= b.path.length || b._stuckT > 2.0) {
      b.path = findPath(b, { x: Math.round(b.x), y: Math.round(b.y), z: Math.round(b.z) }, goalState.current);
      b.pathIndex = 0;
      b._stuckT = 0;
    }
    if (!b.path || !b.path.length) return;

    const t = b.path[b.pathIndex];
    const dx = t.x - b.x, dy = t.y - b.y, dz = t.z - b.z;
    const dist = Math.hypot(dx, dy, dz) || 1;

    // Desired direction
    let ux = dx / dist, uy = dy / dist, uz = dz / dist;

    // Green gait shaping
    if (b.kind === 'green') {
      const bias = parseFloat(biasLeftEl.value || '0.25');
      const wob  = parseFloat(wobbleEl.value   || '0.35');
      const leftX = -(b.lastDir?.dy || 0), leftY = (b.lastDir?.dx || 1);
      ux += leftX * bias * 0.35; uy += leftY * bias * 0.35;
      const perpX = -uy, perpY = ux; const wobAmt = (rng()*2 - 1) * wob * 0.25;
      ux += perpX * wobAmt; uy += perpY * wobAmt;
      const nrm = Math.hypot(ux, uy, uz) || 1; ux /= nrm; uy /= nrm; uz /= nrm;
    }

    // Fatigue / jitter
    if (b.kind === 'green') b.fatigue = clamp(b.fatigue + parseFloat(fatigueRateEl.value || '0.004') * dt, 0, 1);
    const fatigueMul = (b.kind === 'green') ? (1 - 0.6 * b.fatigue) : 1.0;
    const jitterTarget = (rng()*2 - 1) * (b.kind === 'green' ? parseFloat(speedJitterEl.value || '0.3') : 0.15);
    const baseTarget = ((b.kind === 'orange' ? orangeSpeed : greenSpeed) + jitterTarget) * fatigueMul * timeScale;

    // Smooth speed & velocity
    const alphaJ = 1 - Math.exp(-6 * dt);
    b.speedSmoothed += (baseTarget - b.speedSmoothed) * alphaJ;

    const dvx = ux * b.speedSmoothed, dvy = uy * b.speedSmoothed, dvz = uz * b.speedSmoothed;
    const alphaV = 1 - Math.exp(-(b.kind === 'green' ? 7 : 9) * dt);
    b.vx += (dvx - b.vx) * alphaV; b.vy += (dvy - b.vy) * alphaV; b.vz += (dvz - b.vz) * alphaV;

    // Integrate
    const prevZ = Math.round(b.z);
    b.x += b.vx * dt; b.y += b.vy * dt; b.z += b.vz * dt;
    b.x = clamp(b.x, 0, SIZE - 1); b.y = clamp(b.y, 0, SIZE - 1); b.z = clamp(b.z, 0, WORLD_H - 1);

    // Snap to node when close
    if (Math.hypot(t.x - b.x, t.y - b.y, t.z - b.z) < 0.2) {
      b.x = t.x; b.y = t.y; b.z = t.z; b.lastDir = { dx: dx, dy: dy, dz: dz };
      b.pathIndex++;
      const newZ = t.z;
      if (b.kind === 'green' && newZ !== prevZ) {
        if (newZ > prevZ) {
          if (isCornerRampAt(t.x, t.y, prevZ)) { greenAscents++; statBox.textContent = `Green ascents: ${greenAscents} ¬∑ descents: ${greenDescents}`; }
        } else {
          if (isCornerStairAt(t.x, t.y, newZ) || isCornerRampAt(t.x, t.y, newZ)) { greenDescents++; statBox.textContent = `Green ascents: ${greenAscents} ¬∑ descents: ${greenDescents}`; }
        }
      }
      if (b.pathIndex >= b.path.length) { b.reached = true; goalState.reachedBy.add(b); }
    }
  }

  // ------------------ Camera Update (4th view) ------------------
  function updateCamera(dt){
    const g=bots.find(b=>b.kind==='green')||bots[0]; if(!g) return;
    camZ = Math.round(g.z);
    const alpha = 1 - Math.exp(-followSpeed * dt);
    camX += (g.x - camX) * alpha;
    camY += (g.y - camY) * alpha;
    camX = clamp(camX,0,SIZE-1); camY = clamp(camY,0,SIZE-1);
  }

  // ------------------ Goal Renewal ------------------
  function maybeRenewGoal(){
    if(goalPolicy==='random'){
      for(const b of bots){ if(b.reached){ setNewGoal(); for(const x of bots){ x.reached=false; x.path=findPath(x,{x:Math.round(x.x),y:Math.round(x.y),z:Math.round(x.z)},goalState.current); x.pathIndex=0; } break; } }
    } else {
      const allReached=bots.length>0 && bots.every(b=>b.reached);
      if(allReached){ setNewGoal(); for(const x of bots){ x.reached=false; x.path=findPath(x,{x:Math.round(x.x),y:Math.round(x.y),z:Math.round(x.z)},goalState.current); x.pathIndex=0; } }
    }
  }

  // ------------------ Path Overlay (planned nodes in red) ------------------
  function drawPathOverlayTop(){ if(!showPaths) return; const W=cvTop.width,H=cvTop.height; const tile=Math.max(1, Math.floor(Math.min(W,H)/SIZE * zoomTop)); ctxTop.save(); ctxTop.globalAlpha=0.9; ctxTop.strokeStyle='#ff5252'; ctxTop.fillStyle='#ff5252'; for(const b of bots){ if(!b.path||b.path.length<2) continue; ctxTop.beginPath(); let started=false; for(let i=b.pathIndex;i<b.path.length;i++){ const n=b.path[i]; const cx=n.x*tile+tile/2, cy=n.y*tile+tile/2; if(!started){ ctxTop.moveTo(cx,cy); started=true; } else ctxTop.lineTo(cx,cy); if(tile>=6) ctxTop.fillRect(cx-1,cy-1,2,2); } ctxTop.stroke(); } ctxTop.restore(); }
  function drawPathOverlaySide(){ if(!showPaths) return; const W=cvSide.width,H=cvSide.height; const sx=(W/SIZE)*zoomSide, sz=(H/WORLD_H)*zoomSide; ctxSide.save(); ctxSide.globalAlpha=0.9; ctxSide.strokeStyle='#ff5252'; ctxSide.fillStyle='#ff5252'; for(const b of bots){ if(!b.path||b.path.length<2) continue; ctxSide.beginPath(); let started=false; for(let i=b.pathIndex;i<b.path.length;i++){ const n=b.path[i]; const cx=n.x*sx, cz=H - n.z*sz; if(!started){ ctxSide.moveTo(cx,cz); started=true; } else ctxSide.lineTo(cx,cz); ctxSide.fillRect(cx-1,cz-1,2,2); } ctxSide.stroke(); } ctxSide.restore(); }
  function drawPathOverlayIso(){ if(!showPaths) return; const W=cvIso.width,H=cvIso.height; const tw=8*zoomIso, th=4*zoomIso, hz=3*zoomIso; const ix=(x,y)=>(x-y)*(tw/2)+W/2; const iy=(x,y,z)=>(x+y)*(th/2)-z*hz+120; ctxIso.save(); ctxIso.globalAlpha=0.9; ctxIso.strokeStyle='#ff5252'; ctxIso.fillStyle='#ff5252'; for(const b of bots){ if(!b.path||b.path.length<2) continue; ctxIso.beginPath(); let started=false; for(let i=b.pathIndex;i<b.path.length;i++){ const n=b.path[i]; const cx=ix(n.x+0.5,n.y+0.5), cy=iy(n.x+0.5,n.y+0.5,n.z+0.5); if(!started){ ctxIso.moveTo(cx,cy); started=true; } else ctxIso.lineTo(cx,cy); ctxIso.fillRect(cx-1,cy-1,2,2); } ctxIso.stroke(); } ctxIso.restore(); }
  function drawPathOverlayTopZoom(view){ if(!showPaths) return; const {tile,startXf,startYf,W,H}=view; ctxTopZoom.save(); ctxTopZoom.globalAlpha=0.9; ctxTopZoom.strokeStyle='#ff5252'; ctxTopZoom.fillStyle='#ff5252'; for(const b of bots){ if(!b.path||b.path.length<2) continue; ctxTopZoom.beginPath(); let started=false; for(let i=b.pathIndex;i<b.path.length;i++){ const n=b.path[i]; const xi=(n.x-startXf)*tile+tile/2, yi=(n.y-startYf)*tile+tile/2; if(xi<-10||yi<-10||xi>W+10||yi>H+10) continue; if(!started){ ctxTopZoom.moveTo(xi,yi); started=true; } else ctxTopZoom.lineTo(xi,yi); ctxTopZoom.fillRect(xi-1,yi-1,2,2); } if(started) ctxTopZoom.stroke(); } ctxTopZoom.restore(); }

  // ------------------ Rendering ------------------
  function drawTop(){
    const W=cvTop.width,H=cvTop.height; const tile=Math.max(2, Math.floor(Math.min(W,H)/SIZE * zoomTop));
    ctxTop.clearRect(0,0,W,H);
    // visualize a layer (cycle slowly)
    const z = (Date.now()/1500|0)%WORLD_H;
    for(let y=0;y<SIZE;y++){
      for(let x=0;x<SIZE;x++){
        const noisy = world.floors[IDX(x,y,z)];
        const g = Math.round(22 + (1-noisy)*28);
        ctxTop.fillStyle = `rgb(${g},${g+5},${g+10})`;
        ctxTop.fillRect(x*tile, y*tile, tile, tile);
      }
    }
    // stairs / ramps glyphs
    ctxTop.font='12px system-ui, sans-serif';
    for(let c=0;c<4;c++){
      const p=cornerXY(c);
      if(world.stairs[z*4+c]){ ctxTop.fillStyle='#97b0ff'; ctxTop.fillText('‚ñ≤', p.x*tile+3, p.y*tile+3); }
      if(world.ramps [z*4+c]){ ctxTop.fillStyle='#7cf0c4'; ctxTop.fillText('‚ñ≠', p.x*tile+12, p.y*tile+3); }
    }
    if(showWireTop){
      ctxTop.strokeStyle='rgba(255,255,255,0.15)'; ctxTop.lineWidth=0.5;
      for(let i=0;i<=SIZE;i+=10){
        ctxTop.beginPath(); ctxTop.moveTo(i*tile+0.5,0); ctxTop.lineTo(i*tile+0.5,H); ctxTop.stroke();
        ctxTop.beginPath(); ctxTop.moveTo(0,i*tile+0.5); ctxTop.lineTo(W,i*tile+0.5); ctxTop.stroke();
      }
    }
    // trails
    ctxTop.drawImage(trailTop,0,0);
    drawPathOverlayTop();
    // goal
    ctxTop.strokeStyle=COL_GOAL; ctxTop.lineWidth=2; ctxTop.strokeRect(goalState.current.x*tile+1, goalState.current.y*tile+1, tile-2, tile-2);
    // bots + trail
    for(const b of bots){
      const px=b.x*tile, py=b.y*tile; const r=Math.max(3,tile*0.3);
      ctxTop.fillStyle=(b.kind==='orange')?COL_ORANGE:COL_GREEN;
      ctxTop.beginPath(); ctxTop.arc(px+tile/2, py+tile/2, r, 0, Math.PI*2); ctxTop.fill();
      trailTopCtx.fillStyle=(b.kind==='orange')?'rgba(255,167,38,0.55)':'rgba(32,227,122,0.55)';
      trailTopCtx.fillRect(Math.floor(px+tile/2), Math.floor(py+tile/2), 1,1);
    }
  }

  function drawSide(){
    const W=cvSide.width,H=cvSide.height; const sx=(W/SIZE)*zoomSide, sz=(H/WORLD_H)*zoomSide;
    ctxSide.clearRect(0,0,W,H);
    // background accessibility bands per z
    for(let z=0; z<WORLD_H; z++){
      let acc=0; for(let x=0;x<SIZE;x++){ for(let y=0;y<SIZE;y+=5) acc+=world.access[IDX(x,y,z)]; }
      acc/=(SIZE*(SIZE/5)); const g=Math.round(16+(acc/10)*26);
      ctxSide.fillStyle=`rgb(${g},${g+4},${g+8})`;
      ctxSide.fillRect(0, H-(z+1)*sz, W, sz+1);
    }
    if(showWireSide){
      ctxSide.save(); ctxSide.strokeStyle='rgba(255,255,255,0.15)'; ctxSide.lineWidth=0.5;
      for(let x=0;x<=SIZE;x+=10){ ctxSide.beginPath(); ctxSide.moveTo(x*sx+0.5,0); ctxSide.lineTo(x*sx+0.5,H); ctxSide.stroke(); }
      for(let z=0;z<=WORLD_H;z+=10){ ctxSide.beginPath(); ctxSide.moveTo(0,H-z*sz+0.5); ctxSide.lineTo(W,H-z*sz+0.5); ctxSide.stroke(); }
      ctxSide.restore();
    }
    // trails & overlay
    ctxSide.drawImage(trailSide,0,0);
    drawPathOverlaySide();
    // bots + trail
    for(const b of bots){
      const px=b.x*sx, pz=H - b.z*sz;
      ctxSide.fillStyle=(b.kind==='orange')?COL_ORANGE:COL_GREEN;
      ctxSide.fillRect(px-3,pz-3,6,6);
      trailSideCtx.fillStyle=(b.kind==='orange')?'rgba(255,167,38,0.6)':'rgba(32,227,122,0.6)';
      trailSideCtx.fillRect(Math.floor(px), Math.floor(pz), 1,1);
    }
  }

  function drawIso(){
    const W=cvIso.width,H=cvIso.height; ctxIso.clearRect(0,0,W,H);
    const tw=8*zoomIso, th=4*zoomIso, hz=3*zoomIso;
    const ix=(x,y)=>(x-y)*(tw/2)+W/2;
    const iy=(x,y,z)=>(x+y)*(th/2)-z*hz+120;

    if(showWireIso){
      ctxIso.save();
      // X/Y grid
      ctxIso.strokeStyle='rgba(255,255,255,0.12)'; ctxIso.lineWidth=0.5;
      for(let x=0;x<=SIZE;x+=10){ ctxIso.beginPath(); ctxIso.moveTo(ix(x,0), iy(x,0,0)); ctxIso.lineTo(ix(x,SIZE), iy(x,SIZE,0)); ctxIso.stroke(); }
      for(let y=0;y<=SIZE;y+=10){ ctxIso.beginPath(); ctxIso.moveTo(ix(0,y), iy(0,y,0)); ctxIso.lineTo(ix(SIZE,y,0), iy(SIZE,y,0)); ctxIso.stroke(); }
      // Z slices
      ctxIso.strokeStyle='rgba(255,255,255,0.08)';
      for(let z=0; z<=WORLD_H; z+=10){
        ctxIso.beginPath();
        ctxIso.moveTo(ix(0,0),       iy(0,0,z));
        ctxIso.lineTo(ix(SIZE,0),    iy(SIZE,0,z));
        ctxIso.lineTo(ix(SIZE,SIZE), iy(SIZE,SIZE,z));
        ctxIso.lineTo(ix(0,SIZE),    iy(0,SIZE,z));
        ctxIso.closePath(); ctxIso.stroke();
      }
      ctxIso.restore();
    }

    // trails & overlay
    ctxIso.drawImage(trailIso,0,0);
    drawPathOverlayIso();

    // bots + trails
    for(const b of bots){
      const cx=ix(b.x+0.5,b.y+0.5), cy=iy(b.x+0.5,b.y+0.5,b.z+0.5);
      ctxIso.fillStyle=(b.kind==='orange')?COL_ORANGE:COL_GREEN;
      ctxIso.beginPath(); ctxIso.arc(cx,cy,Math.max(3,3*zoomIso),0,Math.PI*2); ctxIso.fill();
      trailIsoCtx.fillStyle=(b.kind==='orange')?'rgba(255,167,38,0.5)':'rgba(32,227,122,0.5)';
      trailIsoCtx.fillRect(Math.floor(cx),Math.floor(cy),1,1);
    }
  }

  function drawTopZoom(){
    const g=bots.find(b=>b.kind==='green')||bots[0]; const W=cvTopZoom.width,H=cvTopZoom.height; ctxTopZoom.clearRect(0,0,W,H); if(!g) return;
    const tilesAcross = clamp(Math.round(VIEW_BASE_TILES/ clamp(zoomScale,0.5,4)), 6, 60);
    const tile = Math.max(4, Math.floor(Math.min(W,H)/tilesAcross));
    const tilesX=Math.ceil(W/tile)+2, tilesY=Math.ceil(H/tile)+2;
    const halfX=tilesX/2, halfY=tilesY/2;
    camX=clamp(camX,halfX,SIZE-halfX); camY=clamp(camY,halfY,SIZE-halfY);
    const cz=Math.round(camZ);
    const startXf=camX-halfX, startYf=camY-halfY; const sx0=Math.floor(startXf), sy0=Math.floor(startYf);
    const offX=(startXf-sx0)*tile, offY=(startYf-sy0)*tile;

    for(let yi=0; yi<tilesY; yi++){
      const y=sy0+yi; if(y<0||y>=SIZE) continue;
      for(let xi=0; xi<tilesX; xi++){
        const x=sx0+xi; if(x<0||x>=SIZE) continue;
        const noisy=world.floors[IDX(x,y,cz)]; const g2=Math.round(22+(1-noisy)*28);
        ctxTopZoom.fillStyle=`rgb(${g2},${g2+5},${g2+10})`;
        ctxTopZoom.fillRect(xi*tile-offX, yi*tile-offY, tile, tile);
      }
    }
    if(showWireTop){
      ctxTopZoom.strokeStyle='rgba(255,255,255,0.15)'; ctxTopZoom.lineWidth=0.5;
      for(let xi=0; xi<=tilesX; xi++){ ctxTopZoom.beginPath(); ctxTopZoom.moveTo(xi*tile-offX+0.5,0); ctxTopZoom.lineTo(xi*tile-offX+0.5,H); ctxTopZoom.stroke(); }
      for(let yi=0; yi<=tilesY; yi++){ ctxTopZoom.beginPath(); ctxTopZoom.moveTo(0, yi*tile-offY+0.5); ctxTopZoom.lineTo(W, yi*tile-offY+0.5); ctxTopZoom.stroke(); }
    }
    drawPathOverlayTopZoom({tile,startXf,startYf,W,H});
    for(const b of bots){
      if(Math.round(b.z)!==cz) continue;
      const xi=(b.x-startXf)*tile+tile/2, yi=(b.y-startYf)*tile+tile/2;
      if(xi<-10||yi<-10||xi>W+10||yi>H+10) continue;
      ctxTopZoom.fillStyle=(b.kind==='orange')?COL_ORANGE:COL_GREEN;
      ctxTopZoom.beginPath(); ctxTopZoom.arc(xi,yi,Math.max(4,tile*0.3),0,Math.PI*2); ctxTopZoom.fill();
    }
  }

  // ------------------ Export ------------------
  function exportCanvas2x(canvas,name){ const out=document.createElement('canvas'); out.width=canvas.width*2; out.height=canvas.height*2; const o=out.getContext('2d'); o.scale(2,2); o.drawImage(canvas,0,0); const url=out.toDataURL('image/png'); const a=document.createElement('a'); a.href=url; a.download=name+'.png'; a.click(); }

  // ------------------ DSL ------------------
  function applyDSL(text){
    const tokens=text.split(/[\s\r\n]+/).filter(Boolean);
    const kv={};
    for(const t of tokens){ const m=t.match(/^([^=]+)=(.+)$/); if(m) kv[m[1].trim()]=m[2].trim(); }
    if(kv['seed']) seedInputEl.value=kv['seed'];

    if(kv['bots.orange']) orangeCountEl.value = String(Math.max(0, Math.min(200, parseInt(kv['bots.orange'],10)||0)));
    if(kv['bots.green'])  greenCountEl.value  = String(Math.max(0, Math.min(200, parseInt(kv['bots.green'],10)||0)));
    if(kv['goals.policy']){ const v=kv['goals.policy']; goalPolicyEl.value=(v==='team'?'team':'random'); goalPolicy=goalPolicyEl.value; }

    if(kv['orange.speed']) orangeSpeed = Math.max(0.1, parseFloat(kv['orange.speed'])||orangeSpeed);
    if(kv['green.speed'])  greenSpeed  = Math.max(0.1, parseFloat(kv['green.speed']) ||greenSpeed);
    if(kv['green.bias'])   biasLeftEl.value   = String(Math.max(0, Math.min(1, parseFloat(kv['green.bias'])||0)));
    if(kv['green.wobble']) wobbleEl.value     = String(Math.max(0, Math.min(1, parseFloat(kv['green.wobble'])||0)));
    if(kv['green.fatigue'])fatigueRateEl.value= String(Math.max(0, Math.min(0.02, parseFloat(kv['green.fatigue'])||0)));
    if(kv['green.jitter']) speedJitterEl.value= String(Math.max(0, Math.min(1, parseFloat(kv['green.jitter'])||0)));

    if(kv['camera.follow']){ const v=parseFloat(kv['camera.follow']); if(Number.isFinite(v)){ sFollow.value=String(v); followSpeed=v; lblFollow.textContent=v.toFixed(1); } }
    if(kv['camera.zoom4']) { const v=parseFloat(kv['camera.zoom4']); if(Number.isFinite(v)){ sZoom.value=String(v); zoomScale=v; lblZoom.textContent=v.toFixed(1)+'√ó'; } }
    if(kv['camera.top.zoom']) { const v=parseFloat(kv['camera.top.zoom']);  if(Number.isFinite(v)&&v>0){ zoomTop = v; sZoomTop.value=String(v); lblZoomTop.textContent=v.toFixed(1)+'√ó'; } }
    if(kv['camera.side.zoom']){ const v=parseFloat(kv['camera.side.zoom']); if(Number.isFinite(v)&&v>0){ zoomSide= v; sZoomSide.value=String(v); lblZoomSide.textContent=v.toFixed(1)+'√ó'; } }
    if(kv['camera.iso.zoom']) { const v=parseFloat(kv['camera.iso.zoom']);  if(Number.isFinite(v)&&v>0){ zoomIso = v; sZoomIso.value=String(v); lblZoomIso.textContent=v.toFixed(1)+'√ó'; } }

    // Rebuild world & bots
    reseed(seedInputEl.value||'ark100'); genWorld(); setNewGoal(); initBots();
  }

  // ------------------ Controls ------------------
  btnStart.onclick=()=>{ running=true; };
  btnPause.onclick=()=>{ running=false; };
  btnReset.onclick=()=>{ running=false; reseed(seedInputEl.value||'ark100'); genWorld(); setNewGoal(); initBots(); clearTrails(); running=true; };
  btnNewGoal.onclick=()=>{ setNewGoal(); for(const b of bots){ b.reached=false; b.path=findPath(b,{x:Math.round(b.x),y:Math.round(b.y),z:Math.round(b.z)},goalState.current); b.pathIndex=0;} };
  btnClearTrails.onclick=()=>{ clearTrails(); };

  btnWireTop.onclick =()=>{ showWireTop=!showWireTop; btnWireTop.dataset.on=showWireTop?'1':''; };
  btnWireSide.onclick=()=>{ showWireSide=!showWireSide; btnWireSide.dataset.on=showWireSide?'1':''; };
  btnWireIso.onclick =()=>{ showWireIso=!showWireIso; btnWireIso.dataset.on=showWireIso?'1':''; };
  btnTogglePaths.onclick=()=>{ showPaths=!showPaths; btnTogglePaths.dataset.on=showPaths?'1':''; };

  btnExportTop.onclick =()=> exportCanvas2x(cvTop, 'top');
  btnExportSide.onclick=()=> exportCanvas2x(cvSide, 'side');
  btnExportIso.onclick =()=> exportCanvas2x(cvIso, 'iso');

  btnApplyDSL.onclick =()=> applyDSL(dslEl.value);

  timeScaleButtons.forEach(btn=>{ btn.onclick=()=>{ timeScaleButtons.forEach(b=>b.dataset.on=''); btn.dataset.on='1'; timeScale=parseInt(btn.dataset.scale,10)||1; }; });

  const fmt=n=>(+n).toFixed(1);
  sFollow.oninput=()=>{ followSpeed=parseFloat(sFollow.value); lblFollow.textContent=fmt(followSpeed); };
  sZoom.oninput  =()=>{ zoomScale =parseFloat(sZoom.value); lblZoom.textContent=fmt(zoomScale)+'√ó'; };
  sZoomTop.oninput =()=>{ zoomTop = parseFloat(sZoomTop.value); lblZoomTop.textContent = fmt(zoomTop)+'√ó'; };
  sZoomSide.oninput=()=>{ zoomSide= parseFloat(sZoomSide.value); lblZoomSide.textContent=fmt(zoomSide)+'√ó'; };
  sZoomIso.oninput =()=>{ zoomIso = parseFloat(sZoomIso.value); lblZoomIso.textContent = fmt(zoomIso)+'√ó'; };

  // ------------------ Loop ------------------
  function render(){ drawTop(); drawSide(); drawIso(); drawTopZoom(); }
  function step(ts){ if(!tPrev) tPrev=ts; const dt=Math.min(0.05,(ts-tPrev)/1000); tPrev=ts; if(running){ for(const b of bots) updateBot(b,dt); updateCamera(dt); maybeRenewGoal(); } render(); requestAnimationFrame(step); }

  // ------------------ Boot ------------------
  reseed(seedInputEl.value||'ark100'); genWorld(); setNewGoal(); initBots(); render(); requestAnimationFrame(step);
})();
</script>
</body>
</html>

