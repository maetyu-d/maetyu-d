<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Modular 6000×6000 World (6×6×3 cube module)</title>
  <style>
    :root {
      --bg: #0e0f11;
      --fg: #e6e6e6;
      --panel: #17191d;
      --muted: #9aa2ad;
      --accent: #6ad2a0;
    }
    html, body { height: 100%; margin: 0; background: var(--bg); color: var(--fg); font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; }
    #wrap { position: relative; height: 100%; }

    /* Floating control panel (toggle with H) */
    #panel {
      position: absolute; top: 12px; left: 12px; width: 320px; max-height: calc(100% - 24px);
      background: var(--panel); border: 1px solid #23262b; border-radius: 12px; padding: 16px;
      overflow-y: auto; z-index: 10; box-shadow: 0 10px 30px rgba(0,0,0,0.4);
      transition: transform 160ms ease-out, opacity 160ms ease-out;
    }
    #panel.hidden { transform: translateX(-110%); opacity: 0; pointer-events: none; }
    #panel h1 { font-size: 18px; margin: 0 0 10px; }
    #panel .sub { color: var(--muted); font-size: 12px; margin-bottom: 12px; }
    #panel .tiny { font-size: 11px; color: var(--muted); }
    #panel .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    #panel button { background: var(--accent); color: #0b0c0d; border: 0; border-radius: 10px; padding: 8px 10px; font-weight: 700; cursor: pointer; margin-top: 8px; }

    /* Split view */
    #viewport { position: absolute; inset: 0; }
    #split { position: absolute; inset: 0; display: grid; grid-template-columns: 1fr 6px 1fr; }
    #leftPane, #rightPane { position: relative; overflow: hidden; }
    #divider { background: #22272e; cursor: col-resize; box-shadow: inset 0 0 0 1px #2f3540; }
    #divider::after { content: ''; position: absolute; top: 50%; left: 50%; width: 2px; height: 40px; transform: translate(-50%, -50%); background: #3a414d; border-radius: 2px; }
    .paneCanvas { position: absolute; inset: 0; width: 100%; height: 100%; display: block; }
    .paneHud { position: absolute; left: 8px; bottom: 8px; background: rgba(0,0,0,0.5); padding: 6px 8px; border-radius: 8px; font-size: 11px; }
    .paneToolbar { position: absolute; right: 8px; top: 8px; display: flex; gap: 6px; background: rgba(0,0,0,0.45); padding: 6px; border-radius: 8px; align-items: center; }
    .paneToolbar button { background: #20242b; border: 1px solid #363c47; color: var(--fg); border-radius: 8px; padding: 4px 8px; font-size: 12px; cursor: pointer; }
    .paneToolbar button.active { background: var(--accent); color: #0b0c0d; border-color: transparent; }

    /* Iso mini controls */
    .isoControls { display: none; gap: 6px; align-items: center; margin-left: 8px; }
    .isoControls .group { display: inline-flex; gap: 4px; align-items: center; }
    .isoControls .sep { width: 1px; height: 16px; background: rgba(255,255,255,0.12); margin: 0 6px; display: inline-block; }
    .isoControls button { padding: 2px 6px; font-size: 11px; border-radius: 8px; }
    .isoControls label { font-size: 11px; display: inline-flex; gap: 4px; align-items: center; }
  </style>
</head>
<body>
  <div id="wrap">
    <aside id="panel">
      <h1>6000×6000 Modular World</h1>
      <div class="sub">World built from modules of <b>6×6×3 cubes</b> (each cube is <b>100×100×100 px</b>). Modules can rotate (0/90/180/270°), stack into towers, and connect by skybridges. Left pane: top-down/side-on. Right pane: zoomed top-down/isometric.</div>
      <p class="tiny">Controls: drag to pan, scroll to zoom, double-click to center. Keys: <span class="mono">H</span> toggle panel, <span class="mono">R</span> regenerate.</p>

      <button id="regenBtn">Regenerate</button>
      <hr style="border-color:#23262b; opacity:.5; margin:14px 0;">

      <!-- Mode UI -->
      <div id="modeUI" style="margin:8px 0 10px 0;">
        <div style="font-size:12px;color:var(--muted);margin-bottom:6px;">Mode</div>
        <label style="display:block;margin-bottom:4px;"><input type="radio" name="worldMode" id="mode1" value="1" checked> Mode 1: 3D World</label>
        <label style="display:block;margin-bottom:4px;"><input type="radio" name="worldMode" id="mode2" value="2"> Mode 2: Ground-plane 2D</label>
      </div>

      <div id="botsUI">
        <label style="display:block; margin-bottom:6px;"><input type="checkbox" id="randomGoals" checked> Random Goals</label>

        <div style="margin-bottom:8px;">
          <label for="greenThreshold">Green bot accessibility ≥ <span id="threshLabel">0.50</span></label>
          <input type="range" id="greenThreshold" min="0" max="1" step="0.05" value="0.5" style="width:100%;">
        </div>

        <div style="margin-bottom:8px;">
          <label for="lldSeverity">LLD severity (green): <span id="lldSeverityLabel">0.70</span></label>
          <input type="range" id="lldSeverity" min="0" max="1" step="0.05" value="0.7" style="width:100%;">
        </div>

        <!-- New wobble controls -->
        <div style="margin-bottom:6px;display:flex;gap:8px;align-items:center;">
          <label><input type="checkbox" id="wobbleEnabled" checked> LLD wobble</label>
        </div>
        <div style="margin-bottom:8px;">
          <label for="wobbleAmp">Wobble amplitude: <span id="wobbleAmpLabel">0.25</span></label>
          <input type="range" id="wobbleAmp" min="0" max="1" step="0.05" value="0.25" style="width:100%;">
        </div>

        <div style="margin-bottom:8px;">
          <label for="trailWidth">Trail thickness: <span id="trailWidthLabel">6</span> px</label>
          <input type="range" id="trailWidth" min="1" max="20" step="1" value="6" style="width:100%;">
        </div>

        <div style="margin-bottom:8px;">
          <div style="margin-bottom:4px;">Trail Renderer</div>
          <label style="margin-right:8px;"><input type="radio" name="trailRenderer" id="trailStroke" value="stroke" checked> Stroke</label>
          <label><input type="radio" name="trailRenderer" id="trailStamp" value="stamp"> Stamp</label>
        </div>

        <div style="margin-bottom:6px;display:flex;gap:8px;align-items:center;flex-wrap:wrap;">
          <label><input type="checkbox" id="fatigueEnabled" checked> Fatigue</label>
          <label><input type="checkbox" id="microRests" checked> Micro rests</label>
        </div>
        <div style="margin-bottom:6px;display:flex;gap:8px;align-items:center;flex-wrap:wrap;">
          <label><input type="checkbox" id="speed10x"> 10× Speed</label>
        </div>

        <div style="display:flex; gap:8px; flex-wrap:wrap;">
          <button id="newGoalBtn">New Goal Now</button>
          <button id="exportTrailsBtn">Export Trails PNG</button>
          <button id="exportTrailsVectorBtn">Export Trails (vector)</button>
        </div>
      </div>
    </aside>

    <main id="viewport">
      <div id="split">
        <section id="leftPane">
          <canvas id="leftCanvas" class="paneCanvas"></canvas>
          <div class="paneToolbar">
            <button id="leftTopDown" class="active">Top-down</button>
            <button id="leftSide">Side-on</button>
          </div>
          <div id="hudLeft" class="paneHud"></div>
        </section>
        <div id="divider" title="Drag to resize"></div>
        <section id="rightPane">
          <canvas id="rightCanvas" class="paneCanvas"></canvas>
          <div class="paneToolbar">
            <button id="rightTopDown" class="active">Top-down (zoomed)</button>
            <button id="rightIso">Isometric</button>
            <div id="isoControls" class="isoControls" title="Isometric controls">
              <span class="sep"></span>
              <div class="group">
                <button id="isoZoomOut" title="Zoom out">−</button>
                <button id="isoZoomIn" title="Zoom in">+</button>
              </div>
              <div class="group">
                <button id="isoPanLeft" title="Pan left">◀</button>
                <button id="isoPanUp" title="Pan up">▲</button>
                <button id="isoPanDown" title="Pan down">▼</button>
                <button id="isoPanRight" title="Pan right">▶</button>
              </div>
              <div class="group">
                <button id="isoWireBtn" class="active" title="Toggle wireframe">Wire</button>
              </div>
              <span class="sep"></span>
              <div class="group">
                <label><input type="checkbox" id="isoFollow" checked> Follow Green</label>
              </div>
            </div>
          </div>
          <div id="hudRight" class="paneHud"></div>
        </section>
      </div>
    </main>
  </div>

  <script>
  // ===== Constants =====
  const WORLD_PX = 6000;
  const CUBE = 100;
  const MODULE_SIDE = 6;
  const MODULE_LAYERS = 3;
  const MODULE_PX = MODULE_SIDE * CUBE; // 600
  const GRID = WORLD_PX / CUBE;        // 60
  const MODGRID = GRID / MODULE_SIDE;  // 10

  // ===== RNG & helpers =====
  function XorShift32(seed){ let x=(seed>>>0)||0xdeadbeef; return function(){ x^=x<<13; x>>>=0; x^=x>>>17; x>>>=0; x^=x<<5; x>>>=0; return (x>>>0)/4294967296; }; }
  const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));

  // === LLD model (green bot) ===
  const LLD = {
    enabled:true, severity:0.70, leftShort:true,
    driftBias:0.20, rampBias:0.35, roughBoost:0.12,
    wobbleEnabled:true, wobbleAmp:0.25, wobbleBias:0.35
  };

  // Textures
  const textureCache=new Map();
  function cubeRng(seed,gx,gy,h){ const s=((seed>>>0)^(gx*73856093)^(gy*19349663)^(h*83492791))>>>0; return XorShift32(s); }
  function scoreToColor(score){ const t=clamp(score/10,0,1); const hue=0+140*t; const light=22+40*t; const sat=70-15*t; return `hsl(${hue}, ${sat}%, ${light}%)`; }
  function makeTexture(score,variant=0){ const key=score+"-"+variant; if(textureCache.has(key)) return textureCache.get(key); const off=document.createElement('canvas'); off.width=off.height=CUBE; const g=off.getContext('2d'); g.fillStyle=scoreToColor(score); g.fillRect(0,0,CUBE,CUBE); g.strokeStyle='rgba(0,0,0,0.25)'; g.lineWidth=1; for(let i=0;i<score+2;i++){ g.beginPath(); g.moveTo(Math.random()*CUBE, Math.random()*CUBE); g.lineTo(Math.random()*CUBE, Math.random()*CUBE); g.stroke(); } textureCache.set(key,off); return off; }

  const moduleTopCache=new Map();
  function moduleKey(seed,m){ return `${seed}:${m.mx},${m.my}:h${m.height}:r${m.rotation}`; }
  function buildModuleTop(seed,m){
    const key=moduleKey(seed,m); if(moduleTopCache.has(key)) return moduleTopCache.get(key);
    const off=document.createElement('canvas'); off.width=off.height=MODULE_PX; const g=off.getContext('2d');
    const visibleLayerIndex=m.height*MODULE_LAYERS - 1;
    for(let iy=0;iy<MODULE_SIDE;iy++){
      for(let ix=0;ix<MODULE_SIDE;ix++){
        let rx=ix, ry=iy;
        if(m.rotation===90){ rx=MODULE_SIDE-1-iy; ry=ix; }
        else if(m.rotation===180){ rx=MODULE_SIDE-1-ix; ry=MODULE_SIDE-1-iy; }
        else if(m.rotation===270){ rx=iy; ry=MODULE_SIDE-1-ix; }
        const gx=m.mx*MODULE_SIDE+rx, gy=m.my*MODULE_SIDE+ry;
        const rng=cubeRng(seed,gx,gy,visibleLayerIndex); const score=Math.floor(rng()*11); const variant=Math.floor(rng()*4);
        const tex=makeTexture(score,variant); g.drawImage(tex, ix*CUBE, iy*CUBE);
      }
    }
    moduleTopCache.set(key,off); return off;
  }

  // Ground plane cache
  const groundPlaneCache = new Map();
  function buildGroundPlane(seed){
    const key=String(seed); if(groundPlaneCache.has(key)) return groundPlaneCache.get(key);
    const off=document.createElement('canvas'); off.width=WORLD_PX; off.height=WORLD_PX; const g=off.getContext('2d');
    for(let gy=0;gy<GRID;gy++){
      for(let gx=0;gx<GRID;gx++){
        const grng=cubeRng(seed,gx,gy,0); const score=Math.floor(grng()*11); const variant=Math.floor(grng()*4);
        const tex=makeTexture(score,variant); g.drawImage(tex,gx*CUBE,gy*CUBE);
      }
    }
    groundPlaneCache.set(key,off); return off;
  }

  // ===== World generation =====
  function generateWorld(params={}){
    const seed = params.seed;
    const coverage = (params.coverage ?? 0.8);
    const stackProb = (params.stackProb ?? 0.35);
    const towerChance = (params.towerChance ?? 0.6);
    const maxTower = (params.maxTower ?? 6);
    const tallChance = (params.tallChance ?? 0.10);
    const tallMin = (params.tallMin ?? 10);
    const tallMax = (params.tallMax ?? 40); // doubled maximum tall tower height
    const finalSeed = (seed ?? ((Math.random()*2**32)>>>0));
    const rand=XorShift32(finalSeed);

    const filled=Array.from({length:MODGRID},()=>Array(MODGRID).fill(false));
    const target=Math.ceil(MODGRID*MODGRID*Math.max(0.75,coverage));
    let count=0; const order=[];
    for(let y=0;y<MODGRID;y++) for(let x=0;x<MODGRID;x++) order.push({x,y,r:rand()});
    order.sort((a,b)=>a.r-b.r);
    for(let i=0;i<order.length && count<target;i++){ const {x,y}=order[i]; filled[y][x]=true; count++; }

    const modules=[];
    for(let my=0;my<MODGRID;my++){
      for(let mx=0;mx<MODGRID;mx++){
        if(!filled[my][mx]) continue;
        let height=1;
        if(rand()<tallChance){ height = tallMin + Math.floor(rand()*(tallMax - tallMin + 1)); }
        else{
          if(rand()<stackProb) height=2+Math.floor(rand()*2);
          if(height>=2 && rand()<towerChance){ const extra=1+Math.floor(rand()*(maxTower-2)); height=Math.min(maxTower,height+extra); }
        }
        const rotation=[0,90,180,270][Math.floor(rand()*4)];
        const totalLayers = height*MODULE_LAYERS;
        const ramps=[];
        if(totalLayers>1){
          const corners=[[0,0],[5,0],[5,5],[0,5]];
          for(let l=0;l<totalLayers-1;l++){
            const c=corners[Math.floor(rand()*4)];
            ramps.push({ z:l, gx: mx*MODULE_SIDE + c[0], gy: my*MODULE_SIDE + c[1] });
          }
        }
        modules.push({ mx, my, rotation, height, ramps });
      }
    }

    const towers = modules.filter(m=>m.height>=2);
    const centers = towers.map(m=>({ x:m.mx*MODULE_PX+MODULE_PX/2, y:m.my*MODULE_PX+MODULE_PX/2 }));
    const bridges=[]; const used=new Set();
    for(let i=0;i<towers.length;i++){
      let best=-1, bestD=Infinity;
      for(let j=0;j<towers.length;j++){
        if(i===j) continue;
        const dx=centers[i].x-centers[j].x, dy=centers[i].y-centers[j].y; const d=dx*dx+dy*dy;
        if(d<bestD){ bestD=d; best=j; }
      }
      if(best>=0){ const key=[i,best].sort().join('-'); if(!used.has(key)){ used.add(key); bridges.push({aIdx:i,bIdx:best}); } }
    }
    return { seed:finalSeed, modules, towers, bridges };
  }

  // ===== DOM & state =====
  const leftCanvas=document.getElementById('leftCanvas');
  const rightCanvas=document.getElementById('rightCanvas');
  const leftHud=document.getElementById('hudLeft');
  const rightHud=document.getElementById('hudRight');
  const splitEl=document.getElementById('split');
  const divider=document.getElementById('divider');
  const panel=document.getElementById('panel');
  const regenBtn=document.getElementById('regenBtn');

  const leftTopBtn=document.getElementById('leftTopDown');
  const leftSideBtn=document.getElementById('leftSide');
  const rightTopBtn=document.getElementById('rightTopDown');
  const rightIsoBtn=document.getElementById('rightIso');

  const isoControls=document.getElementById('isoControls');
  const isoZoomIn=document.getElementById('isoZoomIn');
  const isoZoomOut=document.getElementById('isoZoomOut');
  const isoPanUp=document.getElementById('isoPanUp');
  const isoPanDown=document.getElementById('isoPanDown');
  const isoPanLeft=document.getElementById('isoPanLeft');
  const isoPanRight=document.getElementById('isoPanRight');
  const isoWireBtn=document.getElementById('isoWireBtn');
  const isoFollowChk=document.getElementById('isoFollow');

  // Mode UI
  const mode1El=document.getElementById('mode1');
  const mode2El=document.getElementById('mode2');
  let MODE=1; // 1=3D world, 2=2D ground-plane

  // Fatigue model
  const FATIGUE={ enabled:true, microRests:true, buildTurn:0.05, buildRamp:0.12, buildRough:0.10, decay:0.25, slowK:0.6, restThreshold:1.2, restDuration:0.5 };

  // Cameras
  const leftCam={ x:WORLD_PX/2, y:WORLD_PX/2, z:0.15 };
  const rightCam={ x:WORLD_PX/2, y:WORLD_PX/2, z:0.6 };
  const isoCam={ x:0, y:0, z:1 };

  let leftMode='top';
  let rightMode='top';
  let isoWireframe=true;
  let isoFollow=true;

  // Bots/UI
  const randomGoalsChk=document.getElementById('randomGoals');
  const greenThresholdEl=document.getElementById('greenThreshold');
  const threshLabel=document.getElementById('threshLabel');
  const lldSeverityEl=document.getElementById('lldSeverity');
  const lldSeverityLabel=document.getElementById('lldSeverityLabel');
  const wobbleEnabledEl=document.getElementById('wobbleEnabled');
  const wobbleAmpEl=document.getElementById('wobbleAmp');
  const wobbleAmpLabel=document.getElementById('wobbleAmpLabel');
  const trailWidthEl=document.getElementById('trailWidth');
  const trailWidthLabel=document.getElementById('trailWidthLabel');
  const fatigueEnabledEl=document.getElementById('fatigueEnabled');
  const microRestsEl=document.getElementById('microRests');
  const speed10xEl=document.getElementById('speed10x');
  const newGoalBtn=document.getElementById('newGoalBtn');
  const exportTrailsBtn=document.getElementById('exportTrailsBtn');
  const exportTrailsVectorBtn=document.getElementById('exportTrailsVectorBtn');
  const trailStrokeEl=document.getElementById('trailStroke');
  const trailStampEl=document.getElementById('trailStamp');
  let trailRenderer='stroke';

  // Time scale
  let timeScale=1, simTime=0;

  let randomGoals=true;
  let greenThreshold=0.5;
  if(lldSeverityLabel){ lldSeverityLabel.textContent=(LLD.severity??0).toFixed(2); }
  if(wobbleEnabledEl){ wobbleEnabledEl.checked=!!LLD.wobbleEnabled; }
  if(wobbleAmpEl){ wobbleAmpEl.value=String(LLD.wobbleAmp??0.25); if(wobbleAmpLabel) wobbleAmpLabel.textContent=(LLD.wobbleAmp??0.25).toFixed(2); }
  let trailThickness=parseFloat(trailWidthEl.value)||6;
  trailWidthEl.addEventListener('input',()=>{ trailThickness=parseFloat(trailWidthEl.value)||6; trailWidthLabel.textContent=String(trailThickness); });
  isoFollowChk.addEventListener('change',()=>{ isoFollow=isoFollowChk.checked; });

  // Accessibility grid (z=0 reference)
  let accGrid=null;

  // Trails
  const trailCanvas=document.createElement('canvas'); trailCanvas.width=WORLD_PX; trailCanvas.height=WORLD_PX;
  const trailCtx=trailCanvas.getContext('2d'); trailCtx.lineCap='round'; trailCtx.lineJoin='round';
  const trailSegs=[]; // {x1,y1,z1,x2,y2,z2,color,alpha,width}

  // Bots
  const bots=[];
  let goal=null; const wins={ orange:0, green:0 }; let pausedUntil=0; let pendingNewGoal=false; let firstArrived=null;

  let world=generateWorld({ coverage:0.8, stackProb:0.35, towerChance:0.6, maxTower:6 });

  // ===== Drawing =====
  function drawTopDown(ctx, cam, hud){
    ctx.save(); ctx.clearRect(0,0,ctx.canvas.width, ctx.canvas.height);
    ctx.translate(ctx.canvas.width/2, ctx.canvas.height/2);
    ctx.scale(cam.z, cam.z); ctx.translate(-cam.x, -cam.y);
    ctx.fillStyle='#0a0b0d'; ctx.fillRect(0,0,WORLD_PX,WORLD_PX);

    // Ground-plane
    const gplane=buildGroundPlane(world.seed); ctx.drawImage(gplane,0,0);

    if(MODE===1){
      // Module tops (visible layer)
      for (const m of world.modules){
        const px=m.mx*MODULE_PX, py=m.my*MODULE_PX;
        const visibleLayerIndex=m.height*MODULE_LAYERS - 1;
        for(let iy=0;iy<MODULE_SIDE;iy++){
          for(let ix=0;ix<MODULE_SIDE;ix++){
            let rx=ix, ry=iy;
            if(m.rotation===90){ rx=MODULE_SIDE-1-iy; ry=ix; }
            else if(m.rotation===180){ rx=MODULE_SIDE-1-ix; ry=MODULE_SIDE-1-iy; }
            else if(m.rotation===270){ rx=iy; ry=MODULE_SIDE-1-ix; }
            const gx=m.mx*MODULE_SIDE+rx, gy=m.my*MODULE_SIDE+ry;
            const rng=cubeRng(world.seed,gx,gy,visibleLayerIndex); const score=Math.floor(rng()*11); const variant=Math.floor(rng()*4);
            const tex=makeTexture(score,variant); ctx.drawImage(tex, px+ix*CUBE, py+iy*CUBE);
          }
        }
        ctx.strokeStyle='rgba(255,255,255,0.08)'; ctx.lineWidth=2; ctx.strokeRect(px,py,MODULE_PX,MODULE_PX);
      }
      // Skybridges
      if(world.towers && world.towers.length>1){
        ctx.globalAlpha=0.9; ctx.strokeStyle='rgba(255,255,255,0.35)'; ctx.lineWidth=12; ctx.lineCap='round';
        for (const br of world.bridges){
          const a=world.towers[br.aIdx], b=world.towers[br.bIdx]; if(!a||!b) continue;
          const ax=a.mx*MODULE_PX+MODULE_PX/2, ay=a.my*MODULE_PX+MODULE_PX/2;
          const bx=b.mx*MODULE_PX+MODULE_PX/2, by=b.my*MODULE_PX+MODULE_PX/2;
          ctx.beginPath(); ctx.moveTo(ax,ay); ctx.lineTo(bx,by); ctx.stroke();
        }
      }
    }

    // Trails & bots (screen-size aware)
    ctx.drawImage(trailCanvas,0,0);
    const invZ=1/(cam.z||1);
    if(goal){
      const gx=goal.gx*CUBE + CUBE/2, gy=goal.gy*CUBE + CUBE/2;
      ctx.save(); ctx.strokeStyle='white'; ctx.lineWidth=3*invZ; ctx.globalAlpha=0.9;
      ctx.beginPath(); ctx.arc(gx,gy,14*invZ,0,Math.PI*2); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(gx-10*invZ,gy); ctx.lineTo(gx+10*invZ,gy); ctx.moveTo(gx,gy-10*invZ); ctx.lineTo(gx,gy+10*invZ); ctx.stroke(); ctx.restore();
    }
    for(const b of bots){
      ctx.save(); ctx.fillStyle=b.color; ctx.strokeStyle='#0b0c0d'; ctx.lineWidth=3*invZ; ctx.globalAlpha=0.95;
      ctx.beginPath(); ctx.arc(b.x,b.y,9*invZ,0,Math.PI*2); ctx.fill(); ctx.stroke(); ctx.restore();
    }

    ctx.restore();
    const globalMax = Math.max(1, ...world.modules.map(m=>m.height));
    const fO=((bots[0]?.fatigue)||0).toFixed(2), fG=((bots[1]?.fatigue)||0).toFixed(2);
    if(hud) hud.textContent = `Top-down · Mode ${MODE===1?'3D':'2D'} · Modules ${world.modules.length} · Towers ${world.towers?.length||0} · Tallest ${globalMax} · Zoom ${cam.z.toFixed(2)}× · Fatigue O ${fO} · G ${fG}` + (goal?` · Goal z ${goal.gz}`:'');
  }

  function drawSide(ctx, hud){
    ctx.save(); ctx.clearRect(0,0,ctx.canvas.width, ctx.canvas.height);
    const w=ctx.canvas.width, h=ctx.canvas.height; ctx.fillStyle='#0a0b0d'; ctx.fillRect(0,0,w,h);

    const cols=MODGRID; const barW=w/cols; ctx.fillStyle='#6ad2a0';
    const globalMax=Math.max(1,...world.modules.map(m=>m.height));
    for(let x=0;x<MODGRID;x++){
      let maxH=0; for(let y=0;y<MODGRID;y++){ const m=world.modules.find(mm=>mm.mx===x&&mm.my===y); if(m) maxH=Math.max(maxH,m.height); }
      const bh=(maxH/globalMax)*(h*0.9); ctx.fillRect(x*barW+2, h-bh, barW-4, bh);
    }

    // bots (column vs z)
    const scaleZ=(h*0.9)/(globalMax*MODULE_LAYERS);
    for(const b of bots){
      const col=Math.floor(b.gx/MODULE_SIDE); const cx=col*barW+barW*0.5; const cy=h-(b.gz*scaleZ);
      ctx.save(); ctx.fillStyle=b.color; ctx.strokeStyle='#0b0c0d'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(cx,cy,6,0,Math.PI*2); ctx.fill(); ctx.stroke(); ctx.restore();
    }
    if(goal){ const gcol=Math.floor(goal.gx/MODULE_SIDE); const gx=gcol*barW+barW*0.5; const gy=h-(goal.gz*scaleZ); ctx.save(); ctx.strokeStyle='white'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(gx,gy,8,0,Math.PI*2); ctx.stroke(); ctx.restore(); }

    const fO=((bots[0]?.fatigue)||0).toFixed(2), fG=((bots[1]?.fatigue)||0).toFixed(2);
    if(hud) hud.textContent=`Side-on · Max height ${globalMax}` + (goal?` · Goal z ${goal.gz}`:'') + ` · Fatigue O ${fO} · G ${fG}`;
    ctx.restore();
  }

  function drawIso(ctx, hud){
    ctx.save(); ctx.clearRect(0,0,ctx.canvas.width, ctx.canvas.height);
    const w=ctx.canvas.width, h=ctx.canvas.height;
    ctx.translate(w/2 + isoCam.x, h*0.6 + isoCam.y);
    const base=0.6; const tile=MODULE_PX*0.5*base*isoCam.z;
    const iso=(ix,iy)=>[(ix-iy)*tile, (ix+iy)*tile*0.5];

    for(let my=0; my<MODGRID; my++){
      for(let mx=0; mx<MODGRID; mx++){
        const m=world.modules.find(mm=>mm.mx===mx && mm.my===my); if(!m) continue;
        const [sx,sy]=iso(mx,my); const hpx=(m.height*18)*isoCam.z; const ty=sy-hpx;
        if(!isoWireframe){
          const tex=buildModuleTop(world.seed,m);
          ctx.save();
          const a= tile/MODULE_PX, b=(tile*0.5)/MODULE_PX, c=-tile/MODULE_PX, d=(tile*0.5)/MODULE_PX, e=sx, f=ty;
          ctx.transform(a,b,c,d,e,f); ctx.drawImage(tex,0,0,MODULE_PX,MODULE_PX); ctx.restore();
        }
        ctx.beginPath(); ctx.moveTo(sx,ty - tile*0.5); ctx.lineTo(sx+tile,ty); ctx.lineTo(sx,ty+tile*0.5); ctx.lineTo(sx-tile,ty); ctx.closePath();
        ctx.strokeStyle=isoWireframe?'rgba(255,255,255,0.6)':'rgba(255,255,255,0.12)'; ctx.lineWidth=isoWireframe?1.2:1.0; ctx.stroke();
        // sides
        ctx.beginPath(); ctx.moveTo(sx,ty+tile*0.5); ctx.lineTo(sx+tile,ty); ctx.lineTo(sx+tile,ty+hpx); ctx.lineTo(sx,ty+tile*0.5+hpx); ctx.closePath();
        if(!isoWireframe){ ctx.fillStyle='hsl(210,25%,22%)'; ctx.fill(); } ctx.stroke();
        ctx.beginPath(); ctx.moveTo(sx,ty+tile*0.5); ctx.lineTo(sx-tile,ty); ctx.lineTo(sx-tile,ty+hpx); ctx.lineTo(sx,ty+tile*0.5+hpx); ctx.closePath();
        if(!isoWireframe){ ctx.fillStyle='hsl(210,20%,18%)'; ctx.fill(); } ctx.stroke();
      }
    }

    const globalMax=Math.max(1,...world.modules.map(m=>m.height));
    // Iso overlay project
    const isoFromWorld=(u,v)=>{ const ix=u/MODULE_PX, iy=v/MODULE_PX; return [(ix-iy)*tile,(ix+iy)*tile*0.5]; };
    const isoFromWorldZ=(u,v,z)=>{ const p=isoFromWorld(u,v); p[1]-=z*6*isoCam.z; return p; };

    for(const s of trailSegs){
      const z1=(s.z1??0), z2=(s.z2??z1);
      const p1=isoFromWorldZ(s.x1,s.y1,z1), p2=isoFromWorldZ(s.x2,s.y2,z2);
      ctx.save(); ctx.globalAlpha=(s.alpha??0.6); ctx.strokeStyle=s.color; ctx.lineWidth=(s.width??3);
      ctx.beginPath(); ctx.moveTo(p1[0],p1[1]); ctx.lineTo(p2[0],p2[1]); ctx.stroke(); ctx.restore();
    }
    if(goal){ const gu=goal.gx*CUBE+CUBE/2, gv=goal.gy*CUBE+CUBE/2; const gp=isoFromWorldZ(gu,gv,goal.gz||0); ctx.save(); ctx.strokeStyle='white'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(gp[0],gp[1],10,0,Math.PI*2); ctx.stroke(); ctx.restore(); }
    for(const b of bots){ const bp=isoFromWorldZ(b.x,b.y,b.gz||0); ctx.save(); ctx.fillStyle=b.color; ctx.strokeStyle='#0b0c0d'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(bp[0],bp[1],6,0,Math.PI*2); ctx.fill(); ctx.stroke(); ctx.restore(); }

    const fO=((bots[0]?.fatigue)||0).toFixed(2), fG=((bots[1]?.fatigue)||0).toFixed(2);
    if(hud) hud.textContent=`Isometric ${isoWireframe ? '(wireframe)' : ''} · Tallest ${globalMax} · Zoom ${isoCam.z.toFixed(2)}× · Modules ${world.modules.length}` + (goal?` · Goal z ${goal.gz}`:'') + ` · Fatigue O ${fO} · G ${fG}`;
    ctx.restore();
  }

  function drawAll(){
    const lctx=leftCanvas.getContext('2d');
    const rctx=rightCanvas.getContext('2d');
    if(leftMode==='top') drawTopDown(lctx,leftCam,leftHud); else drawSide(lctx,leftHud);
    if(rightMode==='top') drawTopDown(rctx,rightCam,rightHud); else drawIso(rctx,rightHud);
  }

  // ===== Pathfinding & Bots =====
  function buildAccGrid(seed){
    const grid=Array.from({length:GRID},()=>Array(GRID).fill(0));
    for(let y=0;y<GRID;y++){ for(let x=0;x<GRID;x++){ const r=cubeRng(seed,x,y,0); const score=Math.floor(r()*11); grid[y][x]=score/10; } }
    return grid;
  }

  // 3D navigation model
  let occ3D=null, rampUpSet=null, zMax=1;
  function key3(x,y,z){ return `${x}|${y}|${z}`; }
  function rebuildNav3D(){
    occ3D=new Set(); rampUpSet=new Set(); zMax=1;
    for(let y=0;y<GRID;y++) for(let x=0;x<GRID;x++) occ3D.add(key3(x,y,0)); // ground
    for(const m of world.modules){
      const H=m.height*MODULE_LAYERS; zMax=Math.max(zMax,H);
      const baseX=m.mx*MODULE_SIDE, baseY=m.my*MODULE_SIDE;
      for(let z=0; z<H; z++){ for(let ly=0; ly<MODULE_SIDE; ly++){ for(let lx=0; lx<MODULE_SIDE; lx++){ occ3D.add(key3(baseX+lx,baseY+ly,z)); } } }
      for(const r of (m.ramps||[])){ rampUpSet.add(key3(r.gx,r.gy,r.z)); }
    }
  }
  function hasFloor(x,y,z){ return occ3D?.has(key3(x,y,z)); }
  function hasRampUp(x,y,z){ return rampUpSet?.has(key3(x,y,z)); }
  function accAt(x,y,z){ const r=cubeRng(world.seed,x,y,z); const score=Math.floor(r()*11); return score/10; }

  function aStar3D(start,goal,passFn,stepCostFn){
    const sid=key3(start.x,start.y,start.z), gid=key3(goal.x,goal.y,goal.z);
    const open=[sid], inOpen=new Set([sid]); const gScore=new Map(), fScore=new Map(); const cameFrom={};
    const h=(x,y,z)=>Math.abs(x-goal.x)+Math.abs(y-goal.y)+Math.abs(z-goal.z);
    gScore.set(sid,0); fScore.set(sid,h(start.x,start.y,start.z));
    while(open.length){
      let besti=0, curId=open[0], bestF=fScore.get(open[0]) ?? Infinity;
      for(let i=1;i<open.length;i++){ const id=open[i]; const f=fScore.get(id) ?? Infinity; if(f<bestF){ bestF=f; curId=id; besti=i; } }
      open.splice(besti,1); inOpen.delete(curId);
      if(curId===gid){
        const path=[]; let c=gid; while(cameFrom[c]!=null){ const p=c.split('|'); path.push({x:+p[0],y:+p[1],z:+p[2]}); c=cameFrom[c]; } path.reverse(); return path;
      }
      const p=curId.split('|'); const cx=+p[0], cy=+p[1], cz=+p[2];
      const neigh=[]; const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
      for(const d of dirs){ const nx=cx+d[0], ny=cy+d[1], nz=cz; if(nx<0||ny<0||nx>=GRID||ny>=GRID) continue; if(hasFloor(nx,ny,nz)) neigh.push({x:nx,y:ny,z:nz}); }
      if(MODE===1 && hasRampUp(cx,cy,cz) && hasFloor(cx,cy,cz+1)) neigh.push({x:cx,y:cy,z:cz+1});
      if(MODE===1 && cz>0 && hasRampUp(cx,cy,cz-1) && hasFloor(cx,cy,cz-1)) neigh.push({x:cx,y:cy,z:cz-1});
      for(const n of neigh){
        if(!passFn(n.x,n.y,n.z)) continue;
        const nid=key3(n.x,n.y,n.z); const gcur=gScore.get(curId) ?? 0; const step=stepCostFn(cx,cy,cz,n.x,n.y,n.z); const tentative=gcur+step; const goldG=gScore.get(nid) ?? Infinity;
        if(tentative<goldG){ cameFrom[nid]=curId; gScore.set(nid,tentative); fScore.set(nid, tentative + h(n.x,n.y,n.z)); if(!inOpen.has(nid)){ open.push(nid); inOpen.add(nid); } }
      }
    }
    return null;
  }

  function aStar3DHeading(start,goal,strict,startHeading){
    const hx0=(startHeading && (startHeading.hx||startHeading.hx===0)) ? startHeading.hx : 1;
    const hy0=(startHeading && (startHeading.hy||startHeading.hy===0)) ? startHeading.hy : 0;
    function hidFromVec(hx,hy){ if(hx===0 && hy<0) return 0; if(hx>0 && hy===0) return 1; if(hx===0 && hy>0) return 2; if(hx<0 && hy===0) return 3; if(Math.abs(hx)>=Math.abs(hy)) return (hx>=0)?1:3; else return (hy>=0)?2:0; }
    const h0=hidFromVec(hx0,hy0);
    const sid=`${start.x}|${start.y}|${start.z}|${h0}`; const open=[sid], inOpen=new Set([sid]); const gScore=new Map(), fScore=new Map(), cameFrom={};
    const H=(x,y,z)=>Math.abs(x-goal.x)+Math.abs(y-goal.y)+Math.abs(z-goal.z);
    gScore.set(sid,0); fScore.set(sid,H(start.x,start.y,start.z));
    const dirs=[[1,0],[0,1],[-1,0],[0,-1]];
    function turnSignFromH(hcur,dx,dy){ const hv=dirs[(hcur+4)%4]; const cross=hv[0]*dy - hv[1]*dx; const dot=hv[0]*dx + hv[1]*dy; return {sign:Math.sign(cross), dot}; }
    while(open.length){
      let besti=0, curId=open[0], bestF=fScore.get(open[0]) ?? Infinity;
      for(let i=1;i<open.length;i++){ const id=open[i]; const f=fScore.get(id) ?? Infinity; if(f<bestF){ bestF=f; curId=id; besti=i; } }
      open.splice(besti,1); inOpen.delete(curId);
      const p=curId.split('|'); const cx=+p[0], cy=+p[1], cz=+p[2], ch=+p[3];
      if(cx===goal.x && cy===goal.y && cz===goal.z){
        const path=[]; let c=curId; while(cameFrom[c]!=null){ const q=c.split('|'); path.push({x:+q[0],y:+q[1],z:+q[2]}); c=cameFrom[c]; } path.reverse(); return path;
      }
      const horizDirs=[[1,0],[-1,0],[0,1],[0,-1]];
      for(const d of horizDirs){
        const dx=d[0], dy=d[1]; const nx=cx+dx, ny=cy+dy, nz=cz;
        if(nx<0||ny<0||nx>=GRID||ny>=GRID) continue;
        if(!hasFloor(nx,ny,nz)) continue;
        const a=accAt(nx,ny,nz); if(strict && a<greenThreshold) continue;
        const nh=hidFromVec(dx,dy); const ts=turnSignFromH(ch,dx,dy);
        let dirPen=0; if(LLD.enabled && LLD.leftShort){ if(ts.sign<0) dirPen+=LLD.driftBias*LLD.severity; if(ts.dot<0) dirPen+=0.05*LLD.severity; }
        const instability=Math.max(0,0.6 - a)*LLD.roughBoost*LLD.severity;
        const basePenalty = strict ? 0 : Math.max(0, greenThreshold - a) * 4;
        const step = 1 + basePenalty + dirPen + instability;
        const nid=`${nx}|${ny}|${nz}|${nh}`;
        const gcur=gScore.get(curId) ?? 0; const tentative=gcur+step; const goldG=gScore.get(nid) ?? Infinity;
        if(tentative<goldG){ cameFrom[nid]=curId; gScore.set(nid,tentative); fScore.set(nid, tentative + H(nx,ny,nz)); if(!inOpen.has(nid)){ open.push(nid); inOpen.add(nid); } }
      }
      if(MODE===1 && hasRampUp(cx,cy,cz) && hasFloor(cx,cy,cz+1)){
        const nx=cx, ny=cy, nz=cz+1; const a=accAt(nx,ny,nz); if(!strict || a>=greenThreshold){
          const basePenalty = strict ? 0 : Math.max(0, greenThreshold - a) * 4;
          const rampPen = LLD.enabled ? LLD.rampBias * LLD.severity : 0;
          const instability=Math.max(0,0.6 - a)*LLD.roughBoost*LLD.severity;
          const step=1+0.3+basePenalty+rampPen+instability;
          const nid=`${nx}|${ny}|${nz}|${ch}`; const gcur=gScore.get(curId) ?? 0; const tentative=gcur+step; const goldG=gScore.get(nid) ?? Infinity;
          if(tentative<goldG){ cameFrom[nid]=curId; gScore.set(nid,tentative); fScore.set(nid, tentative + H(nx,ny,nz)); if(!inOpen.has(nid)){ open.push(nid); inOpen.add(nid); } }
        }
      }
      if(MODE===1 && cz>0 && hasRampUp(cx,cy,cz-1) && hasFloor(cx,cy,cz-1)){
        const nx=cx, ny=cy, nz=cz-1; const a=accAt(nx,ny,nz); if(!strict || a>=greenThreshold){
          const basePenalty = strict ? 0 : Math.max(0, greenThreshold - a) * 4;
          const rampPen = LLD.enabled ? LLD.rampBias * LLD.severity * 0.8 : 0;
          const instability=Math.max(0,0.6 - a)*LLD.roughBoost*LLD.severity;
          const step=1+0.3+basePenalty+rampPen+instability;
          const nid=`${nx}|${ny}|${nz}|${ch}`; const gcur=gScore.get(curId) ?? 0; const tentative=gcur+step; const goldG=gScore.get(nid) ?? Infinity;
          if(tentative<goldG){ cameFrom[nid]=curId; gScore.set(nid,tentative); fScore.set(nid, tentative + H(nx,ny,nz)); if(!inOpen.has(nid)){ open.push(nid); inOpen.add(nid); } }
        }
      }
    }
    return null;
  }

  function planForOrange(bot,goalCell){
    const start={x:bot.gx,y:bot.gy,z:bot.gz}, end={x:goalCell.gx,y:goalCell.gy,z:goalCell.gz};
    const pass=(x,y,z)=>hasFloor(x,y,z);
    const step=(cx,cy,cz,nx,ny,nz)=>1 + (nz!==cz ? 0.2 : 0);
    const path=aStar3D(start,end,pass,step);
    bot.path=(path||[]).map(p=>{ const c=cellCenter(p.x,p.y); return { gx:p.x, gy:p.y, gz:p.z, x:c.x, y:c.y }; });
  }

  function planForGreen(bot,goalCell){
    const start={x:bot.gx,y:bot.gy,z:bot.gz}, end={x:goalCell.gx,y:goalCell.gy,z:goalCell.gz};
    const startHeading={ hx:bot.hx ?? 1, hy:bot.hy ?? 0 };
    let path=aStar3DHeading(start,end,true,startHeading);
    if(!path) path=aStar3DHeading(start,end,false,startHeading);
    bot.path=(path||[]).map(p=>{ const c=cellCenter(p.x,p.y); return { gx:p.x, gy:p.y, gz:p.z, x:c.x, y:c.y }; });
  }

  function cellCenter(gx,gy){ return { x: gx*CUBE + CUBE/2, y: gy*CUBE + CUBE/2 }; }
  function randomCell(){ return { gx: Math.floor(Math.random()*GRID), gy: Math.floor(Math.random()*GRID) }; }
  function makeBot(name,color){ return { name, color, gx:0, gy:0, gz:0, x:0, y:0, path:[], speed:200, baseSpeed:200, phase:0, hx:1, hy:0, fatigue:0, restUntil:0 }; }

  function setGoalRandom(){
    // In Mode 2, goals are forced to z=0 ; in Mode 1, 10% chance to pick higher floors
    let attempts=0; let g=null; let pO=null, pG=null;
    do{
      attempts++;
      let gz;
      if (MODE===2){ gz=0; }
      else if (Math.random()<0.10 && zMax>1){ const hiMin=Math.max(1,Math.floor(zMax*0.66)); gz=hiMin + Math.floor(Math.random()*Math.max(1,(zMax - hiMin))); }
      else { gz=Math.floor(Math.random()*Math.max(1,zMax)); }

      const ggx=Math.floor(Math.random()*GRID), ggy=Math.floor(Math.random()*GRID);
      if(!hasFloor(ggx,ggy,gz)) continue;
      if((bots[0] && bots[0].gx===ggx && bots[0].gy===ggy && bots[0].gz===gz) || (bots[1] && bots[1].gx===ggx && bots[1].gy===ggy && bots[1].gz===gz)) continue;
      g={ gx:ggx, gy:ggy, gz };

      const startO={x:bots[0].gx,y:bots[0].gy,z:bots[0].gz};
      const startG={x:bots[1].gx,y:bots[1].gy,z:bots[1].gz};
      pO=aStar3D(startO,g,(x,y,z)=>hasFloor(x,y,z),(cx,cy,cz,nx,ny,nz)=>1+(nz!==cz?0.2:0));
      if(!pO) continue;
      pG=aStar3D(startG,g,(x,y,z)=>hasFloor(x,y,z) && accAt(x,y,z)>=Math.min(greenThreshold,1),(cx,cy,cz,nx,ny,nz)=>1+Math.max(0,greenThreshold-accAt(nx,ny,nz))*4+(nz!==cz?0.3:0));
    } while((!g || !pO || !pG) && attempts<200);
    if(!g){ g={ gx:Math.floor(Math.random()*GRID), gy:Math.floor(Math.random()*GRID), gz:0 }; }
    goal=g; pendingNewGoal=false; planForOrange(bots[0],goal); planForGreen(bots[1],goal);
  }

  function resetBots(){
    trailCtx.clearRect(0,0,trailCanvas.width,trailCanvas.height); trailSegs.length=0;
    wins.orange=0; wins.green=0; bots.length=0;
    const o=makeBot('orange','#ff9f2e'); const g=makeBot('green','#69f0a2');
    const s1=randomCell(), s2=randomCell();
    o.gx=s1.gx; o.gy=s1.gy; o.gz=0; const c1=cellCenter(o.gx,o.gy); o.x=c1.x; o.y=c1.y;
    g.gx=s2.gx; g.gy=s2.gy; g.gz=0; const c2=cellCenter(g.gx,g.gy); g.x=c2.x; g.y=c2.y;
    rightCam.x=g.x; rightCam.y=g.y;
    bots.push(o); bots.push(g);
    setGoalRandom();
  }

  // ---- Trail renderer helpers ----
  function stampTrail(ctx, x1,y1, x2,y2, width, color, alpha=1){
    const r = Math.max(0.5, width * 0.5);
    const dx = x2-x1, dy = y2-y1;
    const d = Math.hypot(dx,dy) || 1;
    const step = Math.max(1, r * 0.6);
    const nx = dx / d, ny = dy / d;
    ctx.save();
    ctx.fillStyle = color; ctx.globalAlpha = alpha;
    for(let t=0; t<=d; t+=step){
      const px = x1 + nx*t, py = y1 + ny*t;
      ctx.beginPath(); ctx.arc(px, py, r, 0, Math.PI*2); ctx.fill();
    }
    ctx.beginPath(); ctx.arc(x2, y2, r, 0, Math.PI*2); ctx.fill();
    ctx.restore();
  }
  function drawTrailSegment(bot, x1,y1,z1, x2,y2,z2, alpha, width){
    if(trailRenderer === 'stamp'){
      stampTrail(trailCtx, x1,y1, x2,y2, width, bot.color, alpha);
    } else {
      trailCtx.strokeStyle = bot.color;
      trailCtx.lineWidth = width;
      trailCtx.globalAlpha = alpha;
      trailCtx.beginPath(); trailCtx.moveTo(x1,y1); trailCtx.lineTo(x2,y2); trailCtx.stroke();
    }
    trailSegs.push({x1:x1,y1:y1,z1:z1,x2:x2,y2:y2,z2:z2,color:bot.color,alpha:alpha,width:width});
  }
  // Vector export (re-renders segments at chosen scale)
  function exportTrailsVector(scale=2){
    const w = WORLD_PX * scale, h = WORLD_PX * scale;
    const off = document.createElement('canvas'); off.width=w; off.height=h;
    const g = off.getContext('2d');
    g.lineCap='round'; g.lineJoin='round'; g.imageSmoothingEnabled = false;
    for(const s of trailSegs){
      g.strokeStyle = s.color;
      g.globalAlpha = (s.alpha ?? 1);
      g.lineWidth = (s.width ?? 3) * scale;
      g.beginPath();
      g.moveTo(s.x1*scale, s.y1*scale);
      g.lineTo(s.x2*scale, s.y2*scale);
      g.stroke();
    }
    const url = off.toDataURL('image/png');
    const a = document.createElement('a');
    const ts = new Date().toISOString().replace(/[:.]/g,'-');
    a.href = url; a.download = `trails_vector_${world.seed}_${ts}@${scale}x.png`;
    document.body.appendChild(a); a.click(); a.remove();
  }

  // -- Curved step for green bot (leftward arc + wobble affects physics) --
  function curvedStep(bot, dx, dy, step){
    let vx = dx/(Math.hypot(dx,dy)||1), vy = dy/(Math.hypot(dx,dy)||1);
    if(bot.name==='green' && LLD.enabled){
      const fatigue = (bot.fatigue||0);
      // base leftward curvature
      const curveBase = 0.25 * LLD.severity * (1 + 0.5*fatigue);
      const curve = clamp(curveBase, 0, 0.6);
      let tvx=vx, tvy=vy;
      vx += (-tvy) * curve; // left of motion
      vy += ( tvx) * curve;
      // gait-synced lateral wobble (physics-impacting)
      if(LLD.wobbleEnabled){
        const s = Math.sin(bot.phase||0);
        const shape = s + (LLD.wobbleBias||0)*Math.max(0, s); // lean more on left stance
        const wob = clamp((LLD.wobbleAmp||0.25) * (0.5+0.5*LLD.severity) * (1+0.5*fatigue) * shape, -0.6, 0.6);
        tvx=vx; tvy=vy;
        vx += (-tvy) * wob;
        vy += ( tvx) * wob;
      }
      const vlen = Math.hypot(vx,vy) || 1; vx/=vlen; vy/=vlen;
    }
    return { nx: bot.x + vx*step, ny: bot.y + vy*step, vx, vy };
  }

  // ===== Mode switching =====
  function updateUIForMode(){
    const is2D=(MODE===2);
    leftSideBtn.disabled=is2D;
    rightIsoBtn.disabled=is2D;
    if(is2D){
      if(leftMode!=='top'){ leftMode='top'; setActive(leftTopBtn,leftSideBtn); }
      if(rightMode!=='top'){ rightMode='top'; setActive(rightTopBtn,rightIsoBtn); }
      isoControls.style.display='none';
    } else {
      if(rightMode==='iso') isoControls.style.display='inline-flex';
    }
  }
  function setMode(m){
    MODE=m;
    if(mode1El) mode1El.checked=(m===1);
    if(mode2El) mode2El.checked=(m===2);
    updateUIForMode();
    if(MODE===2){
      for(const b of bots){ b.gz=0; b.path=[]; }
      if(goal){ goal.gz=0; }
      setGoalRandom();
    } else {
      if(goal){ planForOrange(bots[0],goal); planForGreen(bots[1],goal); }
    }
    drawAll();
  }
  mode1El.addEventListener('change',()=>{ if(mode1El.checked) setMode(1); });
  mode2El.addEventListener('change',()=>{ if(mode2El.checked) setMode(2); });

  // UI wiring
  randomGoalsChk.addEventListener('change',()=>{ randomGoals=randomGoalsChk.checked; });
  greenThresholdEl.addEventListener('input',()=>{
    greenThreshold=parseFloat(greenThresholdEl.value||'0.5'); threshLabel.textContent=greenThreshold.toFixed(2);
    if(bots[1]) planForGreen(bots[1],goal);
  });
  lldSeverityEl.addEventListener('input',()=>{ LLD.severity=parseFloat(lldSeverityEl.value||'0'); if(lldSeverityLabel) lldSeverityLabel.textContent=LLD.severity.toFixed(2); });
  if(wobbleEnabledEl){ wobbleEnabledEl.addEventListener('change',()=>{ LLD.wobbleEnabled=wobbleEnabledEl.checked; }); }
  if(wobbleAmpEl){ wobbleAmpEl.addEventListener('input',()=>{ LLD.wobbleAmp=parseFloat(wobbleAmpEl.value||'0'); if(wobbleAmpLabel) wobbleAmpLabel.textContent=LLD.wobbleAmp.toFixed(2); }); }

  newGoalBtn.addEventListener('click',()=>{ pendingNewGoal=false; setGoalRandom(); drawAll(); });
  exportTrailsBtn.addEventListener('click', (e)=>{ exportTrailsPNG(e.shiftKey?1:2); });
  exportTrailsVectorBtn.addEventListener('click', (e)=>{ exportTrailsVector(e.shiftKey?1:2); });
  trailStrokeEl.addEventListener('change', ()=>{ if(trailStrokeEl.checked) trailRenderer='stroke'; });
  trailStampEl.addEventListener('change', ()=>{ if(trailStampEl.checked) trailRenderer='stamp'; });
  fatigueEnabledEl.addEventListener('change',()=>{ FATIGUE.enabled=fatigueEnabledEl.checked; });
  microRestsEl.addEventListener('change',()=>{ FATIGUE.microRests=microRestsEl.checked; });
  speed10xEl.addEventListener('change',()=>{ timeScale=speed10xEl.checked?10:1; });

  // Panel keys & regenerate
  document.addEventListener('keydown', e=>{
    if(e.key==='h' || e.key==='H') panel.classList.toggle('hidden');
    if(e.key==='r' || e.key==='R'){
      moduleTopCache.clear(); groundPlaneCache.clear();
      world=generateWorld({ coverage:0.8, stackProb:0.35, towerChance:0.6, maxTower:6 });
      accGrid=buildAccGrid(world.seed); rebuildNav3D(); updateUIForMode(); resetBots(); drawAll();
    }
  });
  regenBtn.addEventListener('click', ()=>{
    moduleTopCache.clear(); groundPlaneCache.clear();
    world=generateWorld({ coverage:0.8, stackProb:0.35, towerChance:0.6, maxTower:6 });
    accGrid=buildAccGrid(world.seed); rebuildNav3D(); updateUIForMode(); resetBots(); drawAll();
  });

  // ===== Boot =====
  function resize(){ leftCanvas.width=leftCanvas.clientWidth; leftCanvas.height=leftCanvas.clientHeight; rightCanvas.width=rightCanvas.clientWidth; rightCanvas.height=rightCanvas.clientHeight; }
  window.addEventListener('resize',()=>{ resize(); drawAll(); });
  resize();
  accGrid=buildAccGrid(world.seed);
  rebuildNav3D();
  updateUIForMode();
  resetBots();
  drawAll();

  // Export just the trails as a hi-res PNG (transparent background) default 2×
  function exportTrailsPNG(scale=2){
    const w=Math.floor(WORLD_PX*scale), h=Math.floor(WORLD_PX*scale);
    const off=document.createElement('canvas'); off.width=w; off.height=h; const g=off.getContext('2d');
    g.clearRect(0,0,w,h); g.imageSmoothingEnabled=false; g.drawImage(trailCanvas,0,0,w,h);
    const url=off.toDataURL('image/png'); const a=document.createElement('a'); const ts=new Date().toISOString().replace(/[:.]/g,'-');
    a.href=url; a.download=`trails_${world.seed}_${ts}@${scale}x.png`; document.body.appendChild(a); a.click(); a.remove();
  }

  // Animation loop
  let lastT=0;
  function tick(t){
    if(!lastT) lastT=t; let dt=(t-lastT)/1000; lastT=t;
    const dtScaled=dt*timeScale; simTime+=dtScaled; const now=simTime;

    if(now<pausedUntil){ drawAll(); requestAnimationFrame(tick); return; }
    if(pausedUntil && now>=pausedUntil){ pausedUntil=0; afterPause(); }

    moveBot(bots[0],dtScaled,now); moveBot(bots[1],dtScaled,now);

    for(const b of bots){
      if((!b.path || b.path.length===0) && goal && (b.gx!==goal.gx || b.gy!==goal.gy || b.gz!==goal.gz)){
        if(b.name==='orange') planForOrange(b,goal); else planForGreen(b,goal);
      }
    }

    if(rightMode==='top' && bots.length>1){
      const fx=bots[1].x, fy=bots[1].y; const a=0.2; rightCam.x+=(fx-rightCam.x)*a; rightCam.y+=(fy-rightCam.y)*a;
    }
    if(rightMode==='iso' && isoFollow && bots.length>1){
      const b=bots[1]; const base=0.6; const tile=MODULE_PX*0.5*base*isoCam.z;
      const ix=b.x/MODULE_PX, iy=b.y/MODULE_PX; const projX=(ix-iy)*tile; const projY=(ix+iy)*tile*0.5 - (b.gz*6*isoCam.z);
      const w=rightCanvas.width, h=rightCanvas.height; const tx=-projX; const ty=(h*0.5 - h*0.6) - projY; const a=0.15;
      isoCam.x+=(tx-isoCam.x)*a; isoCam.y+=(ty-isoCam.y)*a; const targetZ=1.3; isoCam.z+=(targetZ-isoCam.z)*0.08;
    }

    checkArrivals(now); drawAll(); requestAnimationFrame(tick);
  }

  function checkArrivals(now){
    if(!goal) return;
    for(const b of bots){ if(b.gx===goal.gx && b.gy===goal.gy && b.gz===goal.gz){ if(!b._arrived){ b._arrived=true; b._arriveTime=now; } } }
    const arrived=bots.filter(b=>b._arrived).sort((a,b)=>a._arriveTime-b._arriveTime);
    if(arrived.length){
      if(!firstArrived){
        const winner=arrived[0]; firstArrived=winner.name; if(winner.name==='orange') wins.orange++; else wins.green++;
        pausedUntil=now+1.0; pendingNewGoal=randomGoals;
      }
    }
  }
  function afterPause(){
    for(const b of bots){ b._arrived=false; b._arriveTime=0; }
    firstArrived=null;
    if(pendingNewGoal){ setGoalRandom(); } else { planForOrange(bots[0],goal); planForGreen(bots[1],goal); }
  }

  requestAnimationFrame(tick);
  </script>
</body>
</html>

